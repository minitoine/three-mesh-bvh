{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,U,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SC0BA,IAAM,EAAsB,IAAI,EAAA,WAAU,CACpC,EAA0B,IAAI,EAAA,IAAG,CAC1B,EAAkB,CAC9B,SAAU,EAAA,MAAK,CACf,SAAU,GACV,YAAa,GACb,qBAAsB,CAAA,EACtB,eAAgB,CAAA,EAChB,WAAY,KACZ,SAAU,CAAA,EACV,QAAS,CAAA,CACV,CAEO,OAAM,EAEZ,OAAO,UAAW,CAAG,CAAE,EAAU,CAAC,CAAC,CAAG,CAErC,EAAU,CACT,aAAc,CAAA,EACd,GAAG,CAAO,AACX,EAEA,IAAM,EAAW,EAAI,QAAQ,CACvB,EAAW,EAAI,MAAM,CACrB,EAAiB,EAAI,eAAe,CACpC,EAAiB,EAAS,QAAQ,GAoBxC,OAlBK,EAAQ,YAAY,CAEf,CACR,MAAO,EAAS,GAAG,CAAE,AAAA,GAAQ,EAAK,KAAK,IACvC,MAAO,EAAiB,EAAe,KAAK,CAAC,KAAK,GAAK,KACvD,eAAgB,EAAiB,EAAe,KAAK,GAAK,IAC3D,EAIS,CACR,MAAO,EACP,MAAO,EAAiB,EAAe,KAAK,CAAG,KAC/C,eAAgB,CACjB,CAMF,CAEA,OAAO,YAAa,CAAI,CAAE,CAAQ,CAAE,EAAU,CAAC,CAAC,CAAG,CAElD,EAAU,CACT,SAAU,CAAA,EACV,SAAU,CAAA,CAAS,EAAK,cAAc,CACtC,GAAG,CAAO,AACX,EAEA,GAAM,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","sources":["<anon>","src/core/MeshBVH.js","src/core/Constants.js","src/core/build/buildTree.js","src/core/build/geometryUtils.js","src/core/build/computeBoundsUtils.js","src/core/build/splitUtils.js","src/utils/ArrayBoxUtilities.js","src/core/MeshBVHNode.js","src/core/build/sortUtils.generated.js","src/core/build/sortUtils_indirect.generated.js","src/core/build/buildUtils.js","src/core/utils/nodeBufferUtils.js","src/math/OrientedBox.js","src/utils/ExtendedTrianglePool.js","src/utils/PrimitivePool.js","src/core/cast/shapecast.js","src/core/utils/BufferStack.js","src/core/cast/closestPointToPoint.js","src/core/utils/iterationUtils.generated.js","src/utils/ThreeRayIntersectUtilities.js","src/utils/TriangleUtilities.js","src/core/cast/refit.generated.js","src/core/cast/raycast.generated.js","src/core/utils/intersectUtils.js","src/core/cast/raycastFirst.generated.js","src/core/cast/intersectsGeometry.generated.js","src/core/cast/closestPointToGeometry.generated.js","src/core/utils/iterationUtils_indirect.generated.js","src/core/cast/refit_indirect.generated.js","src/core/cast/raycast_indirect.generated.js","src/core/cast/raycastFirst_indirect.generated.js","src/core/cast/intersectsGeometry_indirect.generated.js","src/core/cast/closestPointToGeometry_indirect.generated.js","src/utils/BufferUtils.js","src/core/cast/bvhcast.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"ff8ed\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVH\", () => $b18ea3b4dfb4ebb9$export$9d614b3bc2c4eacf);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n\nvar $4ARWa = parcelRequire(\"4ARWa\");\n\nvar $4ytBV = parcelRequire(\"4ytBV\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $6DMlg = parcelRequire(\"6DMlg\");\n\nvar $aPqeh = parcelRequire(\"aPqeh\");\n\nvar $38TIa = parcelRequire(\"38TIa\");\n\nvar $8Nb8u = parcelRequire(\"8Nb8u\");\n\nvar $6pOPX = parcelRequire(\"6pOPX\");\n\nvar $01T8e = parcelRequire(\"01T8e\");\n\nvar $9Aami = parcelRequire(\"9Aami\");\n\nvar $iWlby = parcelRequire(\"iWlby\");\n\nvar $hKG28 = parcelRequire(\"hKG28\");\n\nvar $jRigT = parcelRequire(\"jRigT\");\n\nvar $fRYTF = parcelRequire(\"fRYTF\");\n\nvar $6O8bC = parcelRequire(\"6O8bC\");\n\nvar $cmjuj = parcelRequire(\"cmjuj\");\n\nvar $7rVal = parcelRequire(\"7rVal\");\n\nvar $ipmev = parcelRequire(\"ipmev\");\n\nvar $2zRsl = parcelRequire(\"2zRsl\");\n\nvar $2GwQ0 = parcelRequire(\"2GwQ0\");\n\nvar $eLAt7 = parcelRequire(\"eLAt7\");\nconst $b18ea3b4dfb4ebb9$var$obb = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nconst $b18ea3b4dfb4ebb9$var$tempBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nconst $b18ea3b4dfb4ebb9$export$93ca5d3f8675ae4c = {\n    strategy: (0, $Mleu6.CENTER),\n    maxDepth: 40,\n    maxLeafTris: 10,\n    useSharedArrayBuffer: false,\n    setBoundingBox: true,\n    onProgress: null,\n    indirect: false,\n    verbose: true\n};\nclass $b18ea3b4dfb4ebb9$export$9d614b3bc2c4eacf {\n    static serialize(bvh, options = {}) {\n        options = {\n            cloneBuffers: true,\n            ...options\n        };\n        const geometry = bvh.geometry;\n        const rootData = bvh._roots;\n        const indirectBuffer = bvh._indirectBuffer;\n        const indexAttribute = geometry.getIndex();\n        let result;\n        if (options.cloneBuffers) result = {\n            roots: rootData.map((root)=>root.slice()),\n            index: indexAttribute ? indexAttribute.array.slice() : null,\n            indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n        };\n        else result = {\n            roots: rootData,\n            index: indexAttribute ? indexAttribute.array : null,\n            indirectBuffer: indirectBuffer\n        };\n        return result;\n    }\n    static deserialize(data, geometry, options = {}) {\n        options = {\n            setIndex: true,\n            indirect: Boolean(data.indirectBuffer),\n            ...options\n        };\n        const { index: index, roots: roots, indirectBuffer: indirectBuffer } = data;\n        const bvh = new $b18ea3b4dfb4ebb9$export$9d614b3bc2c4eacf(geometry, {\n            ...options,\n            [(0, $Mleu6.SKIP_GENERATION)]: true\n        });\n        bvh._roots = roots;\n        bvh._indirectBuffer = indirectBuffer || null;\n        if (options.setIndex) {\n            const indexAttribute = geometry.getIndex();\n            if (indexAttribute === null) {\n                const newIndex = new (0, $ilwiq.BufferAttribute)(data.index, 1, false);\n                geometry.setIndex(newIndex);\n            } else if (indexAttribute.array !== index) {\n                indexAttribute.array.set(index);\n                indexAttribute.needsUpdate = true;\n            }\n        }\n        return bvh;\n    }\n    get indirect() {\n        return !!this._indirectBuffer;\n    }\n    constructor(geometry, options = {}){\n        if (!geometry.isBufferGeometry) throw new Error(\"MeshBVH: Only BufferGeometries are supported.\");\n        else if (geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.\");\n        // default options\n        options = Object.assign({\n            ...$b18ea3b4dfb4ebb9$export$93ca5d3f8675ae4c,\n            // undocumented options\n            // Whether to skip generating the tree. Used for deserialization.\n            [(0, $Mleu6.SKIP_GENERATION)]: false\n        }, options);\n        if (options.useSharedArrayBuffer && !(0, $2zRsl.isSharedArrayBufferSupported)()) throw new Error(\"MeshBVH: SharedArrayBuffer is not available.\");\n        // retain references to the geometry so we can use them it without having to\n        // take a geometry reference in every function.\n        this.geometry = geometry;\n        this._roots = null;\n        this._indirectBuffer = null;\n        if (!options[0, $Mleu6.SKIP_GENERATION]) {\n            (0, $4ARWa.buildPackedTree)(this, options);\n            if (!geometry.boundingBox && options.setBoundingBox) geometry.boundingBox = this.getBoundingBox(new (0, $ilwiq.Box3)());\n        }\n        const { _indirectBuffer: _indirectBuffer } = this;\n        this.resolveTriangleIndex = options.indirect ? (i)=>_indirectBuffer[i] : (i)=>i;\n    }\n    refit(nodeIndices = null) {\n        const refitFunc = this.indirect ? (0, $fRYTF.refit_indirect) : (0, $6pOPX.refit);\n        return refitFunc(this, nodeIndices);\n    }\n    traverse(callback, rootIndex = 0) {\n        const buffer = this._roots[rootIndex];\n        const uint32Array = new Uint32Array(buffer);\n        const uint16Array = new Uint16Array(buffer);\n        _traverse(0);\n        function _traverse(node32Index, depth = 0) {\n            const node16Index = node32Index * 2;\n            const isLeaf = uint16Array[node16Index + 15] === (0, $Mleu6.IS_LEAFNODE_FLAG);\n            if (isLeaf) {\n                const offset = uint32Array[node32Index + 6];\n                const count = uint16Array[node16Index + 14];\n                callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n            } else {\n                // TODO: use node functions here\n                const left = node32Index + (0, $Mleu6.BYTES_PER_NODE) / 4;\n                const right = uint32Array[node32Index + 6];\n                const splitAxis = uint32Array[node32Index + 7];\n                const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n                if (!stopTraversal) {\n                    _traverse(left, depth + 1);\n                    _traverse(right, depth + 1);\n                }\n            }\n        }\n    }\n    /* Core Cast Functions */ raycast(ray, materialOrSide = (0, $ilwiq.FrontSide)) {\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const intersects = [];\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFunc = this.indirect ? (0, $6O8bC.raycast_indirect) : (0, $01T8e.raycast);\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const startCount = intersects.length;\n            raycastFunc(this, i, materialSide, ray, intersects);\n            if (isArrayMaterial) {\n                const materialIndex = groups[i].materialIndex;\n                for(let j = startCount, jl = intersects.length; j < jl; j++)intersects[j].face.materialIndex = materialIndex;\n            }\n        }\n        return intersects;\n    }\n    raycastFirst(ray, materialOrSide = (0, $ilwiq.FrontSide)) {\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        let closestResult = null;\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFirstFunc = this.indirect ? (0, $cmjuj.raycastFirst_indirect) : (0, $9Aami.raycastFirst);\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const result = raycastFirstFunc(this, i, materialSide, ray);\n            if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n                closestResult = result;\n                if (isArrayMaterial) result.face.materialIndex = groups[i].materialIndex;\n            }\n        }\n        return closestResult;\n    }\n    intersectsGeometry(otherGeometry, geomToMesh) {\n        let result = false;\n        const roots = this._roots;\n        const intersectsGeometryFunc = this.indirect ? (0, $7rVal.intersectsGeometry_indirect) : (0, $iWlby.intersectsGeometry);\n        for(let i = 0, l = roots.length; i < l; i++){\n            result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n            if (result) break;\n        }\n        return result;\n    }\n    shapecast(callbacks) {\n        const triangle = (0, $6DMlg.ExtendedTrianglePool).getPrimitive();\n        const iterateFunc = this.indirect ? (0, $jRigT.iterateOverTriangles_indirect) : (0, $8Nb8u.iterateOverTriangles);\n        let { boundsTraverseOrder: boundsTraverseOrder, intersectsBounds: intersectsBounds, intersectsRange: intersectsRange, intersectsTriangle: intersectsTriangle } = callbacks;\n        // wrap the intersectsRange function\n        if (intersectsRange && intersectsTriangle) {\n            const originalIntersectsRange = intersectsRange;\n            intersectsRange = (offset, count, contained, depth, nodeIndex)=>{\n                if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n                return true;\n            };\n        } else if (!intersectsRange) {\n            if (intersectsTriangle) intersectsRange = (offset, count, contained, depth)=>{\n                return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n            };\n            else intersectsRange = (offset, count, contained)=>{\n                return contained;\n            };\n        }\n        // run shapecast\n        let result = false;\n        let byteOffset = 0;\n        const roots = this._roots;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const root = roots[i];\n            result = (0, $aPqeh.shapecast)(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n            if (result) break;\n            byteOffset += root.byteLength;\n        }\n        (0, $6DMlg.ExtendedTrianglePool).releasePrimitive(triangle);\n        return result;\n    }\n    bvhcast(otherBvh, matrixToLocal, callbacks) {\n        let { intersectsRanges: intersectsRanges, intersectsTriangles: intersectsTriangles } = callbacks;\n        const triangle1 = (0, $6DMlg.ExtendedTrianglePool).getPrimitive();\n        const indexAttr1 = this.geometry.index;\n        const positionAttr1 = this.geometry.attributes.position;\n        const assignTriangle1 = this.indirect ? (i1)=>{\n            const ti = this.resolveTriangleIndex(i1);\n            (0, $2GwQ0.setTriangle)(triangle1, ti * 3, indexAttr1, positionAttr1);\n        } : (i1)=>{\n            (0, $2GwQ0.setTriangle)(triangle1, i1 * 3, indexAttr1, positionAttr1);\n        };\n        const triangle2 = (0, $6DMlg.ExtendedTrianglePool).getPrimitive();\n        const indexAttr2 = otherBvh.geometry.index;\n        const positionAttr2 = otherBvh.geometry.attributes.position;\n        const assignTriangle2 = otherBvh.indirect ? (i2)=>{\n            const ti2 = otherBvh.resolveTriangleIndex(i2);\n            (0, $2GwQ0.setTriangle)(triangle2, ti2 * 3, indexAttr2, positionAttr2);\n        } : (i2)=>{\n            (0, $2GwQ0.setTriangle)(triangle2, i2 * 3, indexAttr2, positionAttr2);\n        };\n        // generate triangle callback if needed\n        if (intersectsTriangles) {\n            const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2)=>{\n                for(let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++){\n                    assignTriangle2(i2);\n                    triangle2.a.applyMatrix4(matrixToLocal);\n                    triangle2.b.applyMatrix4(matrixToLocal);\n                    triangle2.c.applyMatrix4(matrixToLocal);\n                    triangle2.needsUpdate = true;\n                    for(let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++){\n                        assignTriangle1(i1);\n                        triangle1.needsUpdate = true;\n                        if (intersectsTriangles(triangle1, triangle2, i1, i2, depth1, index1, depth2, index2)) return true;\n                    }\n                }\n                return false;\n            };\n            if (intersectsRanges) {\n                const originalIntersectsRanges = intersectsRanges;\n                intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n                    if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n                    return true;\n                };\n            } else intersectsRanges = iterateOverDoubleTriangles;\n        }\n        return (0, $eLAt7.bvhcast)(this, otherBvh, matrixToLocal, intersectsRanges);\n    }\n    /* Derived Cast Functions */ intersectsBox(box, boxToMesh) {\n        $b18ea3b4dfb4ebb9$var$obb.set(box.min, box.max, boxToMesh);\n        $b18ea3b4dfb4ebb9$var$obb.needsUpdate = true;\n        return this.shapecast({\n            intersectsBounds: (box)=>$b18ea3b4dfb4ebb9$var$obb.intersectsBox(box),\n            intersectsTriangle: (tri)=>$b18ea3b4dfb4ebb9$var$obb.intersectsTriangle(tri)\n        });\n    }\n    intersectsSphere(sphere) {\n        return this.shapecast({\n            intersectsBounds: (box)=>sphere.intersectsBox(box),\n            intersectsTriangle: (tri)=>tri.intersectsSphere(sphere)\n        });\n    }\n    closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n        const closestPointToGeometryFunc = this.indirect ? (0, $ipmev.closestPointToGeometry_indirect) : (0, $hKG28.closestPointToGeometry);\n        return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n    }\n    closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n        return (0, $38TIa.closestPointToPoint)(this, point, target, minThreshold, maxThreshold);\n    }\n    getBoundingBox(target) {\n        target.makeEmpty();\n        const roots = this._roots;\n        roots.forEach((buffer)=>{\n            (0, $aw71y.arrayToBox)(0, new Float32Array(buffer), $b18ea3b4dfb4ebb9$var$tempBox);\n            target.union($b18ea3b4dfb4ebb9$var$tempBox);\n        });\n        return target;\n    }\n}\n\n});\nparcelRegister(\"Mleu6\", function(module, exports) {\n\n$parcel$export(module.exports, \"CENTER\", () => $0914f42a72aa7e13$export$91c2158bc24c63d4);\n$parcel$export(module.exports, \"AVERAGE\", () => $0914f42a72aa7e13$export$d3bfe4097a2a8542);\n$parcel$export(module.exports, \"SAH\", () => $0914f42a72aa7e13$export$2b2cc3fb4f03d723);\n$parcel$export(module.exports, \"NOT_INTERSECTED\", () => $0914f42a72aa7e13$export$34b5498ca69d033);\n$parcel$export(module.exports, \"INTERSECTED\", () => $0914f42a72aa7e13$export$a26e00882057cd76);\n$parcel$export(module.exports, \"CONTAINED\", () => $0914f42a72aa7e13$export$82ad94f0a038b67a);\n$parcel$export(module.exports, \"TRIANGLE_INTERSECT_COST\", () => $0914f42a72aa7e13$export$22e1995328fd3cd9);\n$parcel$export(module.exports, \"TRAVERSAL_COST\", () => $0914f42a72aa7e13$export$f4b101accf1b23d1);\n$parcel$export(module.exports, \"BYTES_PER_NODE\", () => $0914f42a72aa7e13$export$a08e7d18fbc53be5);\n$parcel$export(module.exports, \"IS_LEAFNODE_FLAG\", () => $0914f42a72aa7e13$export$661fddb62bfe0e42);\n$parcel$export(module.exports, \"FLOAT32_EPSILON\", () => $0914f42a72aa7e13$export$859129fb5c8f4dc1);\n$parcel$export(module.exports, \"SKIP_GENERATION\", () => $0914f42a72aa7e13$export$abef70518a11a6ba);\n// Split strategy constants\nconst $0914f42a72aa7e13$export$91c2158bc24c63d4 = 0;\nconst $0914f42a72aa7e13$export$d3bfe4097a2a8542 = 1;\nconst $0914f42a72aa7e13$export$2b2cc3fb4f03d723 = 2;\nconst $0914f42a72aa7e13$export$34b5498ca69d033 = 0;\nconst $0914f42a72aa7e13$export$a26e00882057cd76 = 1;\nconst $0914f42a72aa7e13$export$82ad94f0a038b67a = 2;\nconst $0914f42a72aa7e13$export$22e1995328fd3cd9 = 1.25;\nconst $0914f42a72aa7e13$export$f4b101accf1b23d1 = 1;\nconst $0914f42a72aa7e13$export$a08e7d18fbc53be5 = 32;\nconst $0914f42a72aa7e13$export$661fddb62bfe0e42 = 0xFFFF;\nconst $0914f42a72aa7e13$export$859129fb5c8f4dc1 = Math.pow(2, -24);\nconst $0914f42a72aa7e13$export$abef70518a11a6ba = Symbol(\"SKIP_GENERATION\");\n\n});\n\nparcelRegister(\"4ARWa\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildPackedTree\", () => $35845d08f06466da$export$e63bca57f220b8e3);\n\nvar $aBE3W = parcelRequire(\"aBE3W\");\n\nvar $1EkjE = parcelRequire(\"1EkjE\");\n\nvar $kgX4U = parcelRequire(\"kgX4U\");\n\nvar $43QJu = parcelRequire(\"43QJu\");\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n\nvar $1mLHb = parcelRequire(\"1mLHb\");\n\nvar $7OpkL = parcelRequire(\"7OpkL\");\n\nvar $dxzVn = parcelRequire(\"dxzVn\");\nfunction $35845d08f06466da$export$6008de7a0114426c(geometry, useSharedArrayBuffer) {\n    const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    const useUint32 = triCount > 2 ** 16;\n    const byteCount = useUint32 ? 4 : 2;\n    const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n    const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n    for(let i = 0, l = indirectBuffer.length; i < l; i++)indirectBuffer[i] = i;\n    return indirectBuffer;\n}\nfunction $35845d08f06466da$export$9896244d8c99a4d0(bvh, triangleBounds, offset, count, options) {\n    // epxand variables\n    const { maxDepth: maxDepth, verbose: verbose, maxLeafTris: maxLeafTris, strategy: strategy, onProgress: onProgress, indirect: indirect } = options;\n    const indirectBuffer = bvh._indirectBuffer;\n    const geometry = bvh.geometry;\n    const indexArray = geometry.index ? geometry.index.array : null;\n    const partionFunc = indirect ? (0, $7OpkL.partition_indirect) : (0, $1mLHb.partition);\n    // generate intermediate variables\n    const totalTriangles = (0, $aBE3W.getTriCount)(geometry);\n    const cacheCentroidBoundingData = new Float32Array(6);\n    let reachedMaxDepth = false;\n    const root = new (0, $43QJu.MeshBVHNode)();\n    (0, $1EkjE.getBounds)(triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData);\n    splitNode(root, offset, count, cacheCentroidBoundingData);\n    return root;\n    function triggerProgress(trianglesProcessed) {\n        if (onProgress) onProgress(trianglesProcessed / totalTriangles);\n    }\n    // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n    // recording the offset and count of its triangles and writing them into the reordered geometry index.\n    function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {\n        if (!reachedMaxDepth && depth >= maxDepth) {\n            reachedMaxDepth = true;\n            if (verbose) {\n                console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n                console.warn(geometry);\n            }\n        }\n        // early out if we've met our capacity\n        if (count <= maxLeafTris || depth >= maxDepth) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        // Find where to split the volume\n        const split = (0, $kgX4U.getOptimalSplit)(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n        if (split.axis === -1) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n        // create the two new child nodes\n        if (splitOffset === offset || splitOffset === offset + count) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n        } else {\n            node.splitAxis = split.axis;\n            // create the left child and compute its bounding box\n            const left = new (0, $43QJu.MeshBVHNode)();\n            const lstart = offset;\n            const lcount = splitOffset - offset;\n            node.left = left;\n            (0, $1EkjE.getBounds)(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n            splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n            // repeat for right\n            const right = new (0, $43QJu.MeshBVHNode)();\n            const rstart = splitOffset;\n            const rcount = count - lcount;\n            node.right = right;\n            (0, $1EkjE.getBounds)(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n            splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n        }\n        return node;\n    }\n}\nfunction $35845d08f06466da$export$e63bca57f220b8e3(bvh, options) {\n    const geometry = bvh.geometry;\n    if (options.indirect) {\n        bvh._indirectBuffer = $35845d08f06466da$export$6008de7a0114426c(geometry, options.useSharedArrayBuffer);\n        if ((0, $aBE3W.hasGroupGaps)(geometry) && !options.verbose) console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n    if (!bvh._indirectBuffer) (0, $aBE3W.ensureIndex)(geometry, options);\n    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    const triangleBounds = (0, $1EkjE.computeTriangleBounds)(geometry);\n    const geometryRanges = options.indirect ? (0, $aBE3W.getFullGeometryRange)(geometry) : (0, $aBE3W.getRootIndexRanges)(geometry);\n    bvh._roots = geometryRanges.map((range)=>{\n        const root = $35845d08f06466da$export$9896244d8c99a4d0(bvh, triangleBounds, range.offset, range.count, options);\n        const nodeCount = (0, $dxzVn.countNodes)(root);\n        const buffer = new BufferConstructor((0, $Mleu6.BYTES_PER_NODE) * nodeCount);\n        (0, $dxzVn.populateBuffer)(0, root, buffer);\n        return buffer;\n    });\n}\n\n});\nparcelRegister(\"aBE3W\", function(module, exports) {\n\n$parcel$export(module.exports, \"getVertexCount\", () => $7b8c6fb2f021bdd3$export$bb010cc24ecaa644);\n$parcel$export(module.exports, \"getTriCount\", () => $7b8c6fb2f021bdd3$export$c56c51fae37b2d63);\n$parcel$export(module.exports, \"getIndexArray\", () => $7b8c6fb2f021bdd3$export$62808f0201824da2);\n$parcel$export(module.exports, \"ensureIndex\", () => $7b8c6fb2f021bdd3$export$90fd303420808ebb);\n$parcel$export(module.exports, \"getFullGeometryRange\", () => $7b8c6fb2f021bdd3$export$8c9d42783264c26e);\n$parcel$export(module.exports, \"getRootIndexRanges\", () => $7b8c6fb2f021bdd3$export$fd7a16c461f5043c);\n$parcel$export(module.exports, \"hasGroupGaps\", () => $7b8c6fb2f021bdd3$export$d3cf4eabab21775d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $7b8c6fb2f021bdd3$export$bb010cc24ecaa644(geo) {\n    return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nfunction $7b8c6fb2f021bdd3$export$c56c51fae37b2d63(geo) {\n    return $7b8c6fb2f021bdd3$export$bb010cc24ecaa644(geo) / 3;\n}\nfunction $7b8c6fb2f021bdd3$export$62808f0201824da2(vertexCount, BufferConstructor = ArrayBuffer) {\n    if (vertexCount > 65535) return new Uint32Array(new BufferConstructor(4 * vertexCount));\n    else return new Uint16Array(new BufferConstructor(2 * vertexCount));\n}\nfunction $7b8c6fb2f021bdd3$export$90fd303420808ebb(geo, options) {\n    if (!geo.index) {\n        const vertexCount = geo.attributes.position.count;\n        const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n        const index = $7b8c6fb2f021bdd3$export$62808f0201824da2(vertexCount, BufferConstructor);\n        geo.setIndex(new (0, $ilwiq.BufferAttribute)(index, 1));\n        for(let i = 0; i < vertexCount; i++)index[i] = i;\n    }\n}\nfunction $7b8c6fb2f021bdd3$export$8c9d42783264c26e(geo) {\n    const triCount = $7b8c6fb2f021bdd3$export$c56c51fae37b2d63(geo);\n    const drawRange = geo.drawRange;\n    const start = drawRange.start / 3;\n    const end = (drawRange.start + drawRange.count) / 3;\n    const offset = Math.max(0, start);\n    const count = Math.min(triCount, end) - offset;\n    return [\n        {\n            offset: Math.floor(offset),\n            count: Math.floor(count)\n        }\n    ];\n}\nfunction $7b8c6fb2f021bdd3$export$fd7a16c461f5043c(geo) {\n    if (!geo.groups || !geo.groups.length) return $7b8c6fb2f021bdd3$export$8c9d42783264c26e(geo);\n    const ranges = [];\n    const rangeBoundaries = new Set();\n    const drawRange = geo.drawRange;\n    const drawRangeStart = drawRange.start / 3;\n    const drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n    for (const group of geo.groups){\n        const groupStart = group.start / 3;\n        const groupEnd = (group.start + group.count) / 3;\n        rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n        rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n    }\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n    const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b)=>a - b);\n    for(let i = 0; i < sortedBoundaries.length - 1; i++){\n        const start = sortedBoundaries[i];\n        const end = sortedBoundaries[i + 1];\n        ranges.push({\n            offset: Math.floor(start),\n            count: Math.floor(end - start)\n        });\n    }\n    return ranges;\n}\nfunction $7b8c6fb2f021bdd3$export$d3cf4eabab21775d(geometry) {\n    if (geometry.groups.length === 0) return false;\n    const vertexCount = $7b8c6fb2f021bdd3$export$c56c51fae37b2d63(geometry);\n    const groups = $7b8c6fb2f021bdd3$export$fd7a16c461f5043c(geometry).sort((a, b)=>a.offset - b.offset);\n    const finalGroup = groups[groups.length - 1];\n    finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n    let total = 0;\n    groups.forEach(({ count: count })=>total += count);\n    return vertexCount !== total;\n}\n\n});\n\nparcelRegister(\"1EkjE\", function(module, exports) {\n\n$parcel$export(module.exports, \"getBounds\", () => $13394934ac4ef772$export$becd1e645219fa23);\n$parcel$export(module.exports, \"computeTriangleBounds\", () => $13394934ac4ef772$export$b3cc4d5d5179e78c);\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n\nvar $aBE3W = parcelRequire(\"aBE3W\");\nfunction $13394934ac4ef772$export$becd1e645219fa23(triangleBounds, offset, count, target, centroidTarget) {\n    let minx = Infinity;\n    let miny = Infinity;\n    let minz = Infinity;\n    let maxx = -Infinity;\n    let maxy = -Infinity;\n    let maxz = -Infinity;\n    let cminx = Infinity;\n    let cminy = Infinity;\n    let cminz = Infinity;\n    let cmaxx = -Infinity;\n    let cmaxy = -Infinity;\n    let cmaxz = -Infinity;\n    for(let i = offset * 6, end = (offset + count) * 6; i < end; i += 6){\n        const cx = triangleBounds[i + 0];\n        const hx = triangleBounds[i + 1];\n        const lx = cx - hx;\n        const rx = cx + hx;\n        if (lx < minx) minx = lx;\n        if (rx > maxx) maxx = rx;\n        if (cx < cminx) cminx = cx;\n        if (cx > cmaxx) cmaxx = cx;\n        const cy = triangleBounds[i + 2];\n        const hy = triangleBounds[i + 3];\n        const ly = cy - hy;\n        const ry = cy + hy;\n        if (ly < miny) miny = ly;\n        if (ry > maxy) maxy = ry;\n        if (cy < cminy) cminy = cy;\n        if (cy > cmaxy) cmaxy = cy;\n        const cz = triangleBounds[i + 4];\n        const hz = triangleBounds[i + 5];\n        const lz = cz - hz;\n        const rz = cz + hz;\n        if (lz < minz) minz = lz;\n        if (rz > maxz) maxz = rz;\n        if (cz < cminz) cminz = cz;\n        if (cz > cmaxz) cmaxz = cz;\n    }\n    target[0] = minx;\n    target[1] = miny;\n    target[2] = minz;\n    target[3] = maxx;\n    target[4] = maxy;\n    target[5] = maxz;\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n}\nfunction $13394934ac4ef772$export$b3cc4d5d5179e78c(geo, target = null, offset = null, count = null) {\n    const posAttr = geo.attributes.position;\n    const index = geo.index ? geo.index.array : null;\n    const triCount = (0, $aBE3W.getTriCount)(geo);\n    const normalized = posAttr.normalized;\n    let triangleBounds;\n    if (target === null) {\n        triangleBounds = new Float32Array(triCount * 24);\n        offset = 0;\n        count = triCount;\n    } else {\n        triangleBounds = target;\n        offset = offset || 0;\n        count = count || triCount;\n    }\n    // used for non-normalized positions\n    const posArr = posAttr.array;\n    // support for an interleaved position buffer\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n    if (posAttr.isInterleavedBufferAttribute) stride = posAttr.data.stride;\n    // used for normalized positions\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\"\n    ];\n    for(let tri = offset; tri < offset + count; tri++){\n        const tri3 = tri * 3;\n        const tri6 = tri * 6;\n        let ai = tri3 + 0;\n        let bi = tri3 + 1;\n        let ci = tri3 + 2;\n        if (index) {\n            ai = index[ai];\n            bi = index[bi];\n            ci = index[ci];\n        }\n        // we add the stride and offset here since we access the array directly\n        // below for the sake of performance\n        if (!normalized) {\n            ai = ai * stride + bufferOffset;\n            bi = bi * stride + bufferOffset;\n            ci = ci * stride + bufferOffset;\n        }\n        for(let el = 0; el < 3; el++){\n            let a, b, c;\n            if (normalized) {\n                a = posAttr[getters[el]](ai);\n                b = posAttr[getters[el]](bi);\n                c = posAttr[getters[el]](ci);\n            } else {\n                a = posArr[ai + el];\n                b = posArr[bi + el];\n                c = posArr[ci + el];\n            }\n            let min = a;\n            if (b < min) min = b;\n            if (c < min) min = c;\n            let max = a;\n            if (b > max) max = b;\n            if (c > max) max = c;\n            // Increase the bounds size by float32 epsilon to avoid precision errors when\n            // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n            // worked with.\n            const halfExtents = (max - min) / 2;\n            const el2 = el * 2;\n            triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n            triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * (0, $Mleu6.FLOAT32_EPSILON);\n        }\n    }\n    return triangleBounds;\n}\n\n});\n\nparcelRegister(\"kgX4U\", function(module, exports) {\n\n$parcel$export(module.exports, \"getOptimalSplit\", () => $ec2320f915f98c17$export$9e40712018083c80);\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\nconst $ec2320f915f98c17$var$BIN_COUNT = 32;\nconst $ec2320f915f98c17$var$binsSort = (a, b)=>a.candidate - b.candidate;\nconst $ec2320f915f98c17$var$sahBins = new Array($ec2320f915f98c17$var$BIN_COUNT).fill().map(()=>{\n    return {\n        count: 0,\n        bounds: new Float32Array(6),\n        rightCacheBounds: new Float32Array(6),\n        leftCacheBounds: new Float32Array(6),\n        candidate: 0\n    };\n});\nconst $ec2320f915f98c17$var$leftBounds = new Float32Array(6);\nfunction $ec2320f915f98c17$export$9e40712018083c80(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n    let axis = -1;\n    let pos = 0;\n    // Center\n    if (strategy === (0, $Mleu6.CENTER)) {\n        axis = (0, $aw71y.getLongestEdgeIndex)(centroidBoundingData);\n        if (axis !== -1) pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    } else if (strategy === (0, $Mleu6.AVERAGE)) {\n        axis = (0, $aw71y.getLongestEdgeIndex)(nodeBoundingData);\n        if (axis !== -1) pos = $ec2320f915f98c17$var$getAverage(triangleBounds, offset, count, axis);\n    } else if (strategy === (0, $Mleu6.SAH)) {\n        const rootSurfaceArea = (0, $aw71y.computeSurfaceArea)(nodeBoundingData);\n        let bestCost = (0, $Mleu6.TRIANGLE_INTERSECT_COST) * count;\n        // iterate over all axes\n        const cStart = offset * 6;\n        const cEnd = (offset + count) * 6;\n        for(let a = 0; a < 3; a++){\n            const axisLeft = centroidBoundingData[a];\n            const axisRight = centroidBoundingData[a + 3];\n            const axisLength = axisRight - axisLeft;\n            const binWidth = axisLength / $ec2320f915f98c17$var$BIN_COUNT;\n            // If we have fewer triangles than we're planning to split then just check all\n            // the triangle positions because it will be faster.\n            if (count < $ec2320f915f98c17$var$BIN_COUNT / 4) {\n                // initialize the bin candidates\n                const truncatedBins = [\n                    ...$ec2320f915f98c17$var$sahBins\n                ];\n                truncatedBins.length = count;\n                // set the candidates\n                let b = 0;\n                for(let c = cStart; c < cEnd; c += 6, b++){\n                    const bin = truncatedBins[b];\n                    bin.candidate = triangleBounds[c + 2 * a];\n                    bin.count = 0;\n                    const { bounds: bounds, leftCacheBounds: leftCacheBounds, rightCacheBounds: rightCacheBounds } = bin;\n                    for(let d = 0; d < 3; d++){\n                        rightCacheBounds[d] = Infinity;\n                        rightCacheBounds[d + 3] = -Infinity;\n                        leftCacheBounds[d] = Infinity;\n                        leftCacheBounds[d + 3] = -Infinity;\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                    (0, $aw71y.expandByTriangleBounds)(c, triangleBounds, bounds);\n                }\n                truncatedBins.sort($ec2320f915f98c17$var$binsSort);\n                // remove redundant splits\n                let splitCount = count;\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    while(bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate){\n                        truncatedBins.splice(bi + 1, 1);\n                        splitCount--;\n                    }\n                }\n                // find the appropriate bin for each triangle and expand the bounds.\n                for(let c = cStart; c < cEnd; c += 6){\n                    const center = triangleBounds[c + 2 * a];\n                    for(let bi = 0; bi < splitCount; bi++){\n                        const bin = truncatedBins[bi];\n                        if (center >= bin.candidate) (0, $aw71y.expandByTriangleBounds)(c, triangleBounds, bin.rightCacheBounds);\n                        else {\n                            (0, $aw71y.expandByTriangleBounds)(c, triangleBounds, bin.leftCacheBounds);\n                            bin.count++;\n                        }\n                    }\n                }\n                // expand all the bounds\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    const leftCount = bin.count;\n                    const rightCount = count - bin.count;\n                    // check the cost of this split\n                    const leftBounds = bin.leftCacheBounds;\n                    const rightBounds = bin.rightCacheBounds;\n                    let leftProb = 0;\n                    if (leftCount !== 0) leftProb = (0, $aw71y.computeSurfaceArea)(leftBounds) / rootSurfaceArea;\n                    let rightProb = 0;\n                    if (rightCount !== 0) rightProb = (0, $aw71y.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n                    const cost = (0, $Mleu6.TRAVERSAL_COST) + (0, $Mleu6.TRIANGLE_INTERSECT_COST) * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            } else {\n                // reset the bins\n                for(let i = 0; i < $ec2320f915f98c17$var$BIN_COUNT; i++){\n                    const bin = $ec2320f915f98c17$var$sahBins[i];\n                    bin.count = 0;\n                    bin.candidate = axisLeft + binWidth + i * binWidth;\n                    const bounds = bin.bounds;\n                    for(let d = 0; d < 3; d++){\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                }\n                // iterate over all center positions\n                for(let c = cStart; c < cEnd; c += 6){\n                    const triCenter = triangleBounds[c + 2 * a];\n                    const relativeCenter = triCenter - axisLeft;\n                    // in the partition function if the centroid lies on the split plane then it is\n                    // considered to be on the right side of the split\n                    let binIndex = ~~(relativeCenter / binWidth);\n                    if (binIndex >= $ec2320f915f98c17$var$BIN_COUNT) binIndex = $ec2320f915f98c17$var$BIN_COUNT - 1;\n                    const bin = $ec2320f915f98c17$var$sahBins[binIndex];\n                    bin.count++;\n                    (0, $aw71y.expandByTriangleBounds)(c, triangleBounds, bin.bounds);\n                }\n                // cache the unioned bounds from right to left so we don't have to regenerate them each time\n                const lastBin = $ec2320f915f98c17$var$sahBins[$ec2320f915f98c17$var$BIN_COUNT - 1];\n                (0, $aw71y.copyBounds)(lastBin.bounds, lastBin.rightCacheBounds);\n                for(let i = $ec2320f915f98c17$var$BIN_COUNT - 2; i >= 0; i--){\n                    const bin = $ec2320f915f98c17$var$sahBins[i];\n                    const nextBin = $ec2320f915f98c17$var$sahBins[i + 1];\n                    (0, $aw71y.unionBounds)(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);\n                }\n                let leftCount = 0;\n                for(let i = 0; i < $ec2320f915f98c17$var$BIN_COUNT - 1; i++){\n                    const bin = $ec2320f915f98c17$var$sahBins[i];\n                    const binCount = bin.count;\n                    const bounds = bin.bounds;\n                    const nextBin = $ec2320f915f98c17$var$sahBins[i + 1];\n                    const rightBounds = nextBin.rightCacheBounds;\n                    // don't do anything with the bounds if the new bounds have no triangles\n                    if (binCount !== 0) {\n                        if (leftCount === 0) (0, $aw71y.copyBounds)(bounds, $ec2320f915f98c17$var$leftBounds);\n                        else (0, $aw71y.unionBounds)(bounds, $ec2320f915f98c17$var$leftBounds, $ec2320f915f98c17$var$leftBounds);\n                    }\n                    leftCount += binCount;\n                    // check the cost of this split\n                    let leftProb = 0;\n                    let rightProb = 0;\n                    if (leftCount !== 0) leftProb = (0, $aw71y.computeSurfaceArea)($ec2320f915f98c17$var$leftBounds) / rootSurfaceArea;\n                    const rightCount = count - leftCount;\n                    if (rightCount !== 0) rightProb = (0, $aw71y.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n                    const cost = (0, $Mleu6.TRAVERSAL_COST) + (0, $Mleu6.TRIANGLE_INTERSECT_COST) * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            }\n        }\n    } else console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);\n    return {\n        axis: axis,\n        pos: pos\n    };\n}\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction $ec2320f915f98c17$var$getAverage(triangleBounds, offset, count, axis) {\n    let avg = 0;\n    for(let i = offset, end = offset + count; i < end; i++)avg += triangleBounds[i * 6 + axis * 2];\n    return avg / count;\n}\n\n});\nparcelRegister(\"aw71y\", function(module, exports) {\n\n$parcel$export(module.exports, \"arrayToBox\", () => $7a82575c26570b10$export$40b9a5e446bf11e0);\n$parcel$export(module.exports, \"getLongestEdgeIndex\", () => $7a82575c26570b10$export$dcdc414399b99746);\n$parcel$export(module.exports, \"copyBounds\", () => $7a82575c26570b10$export$14b050a767b4a3a7);\n$parcel$export(module.exports, \"unionBounds\", () => $7a82575c26570b10$export$a8a7063dce01a911);\n$parcel$export(module.exports, \"expandByTriangleBounds\", () => $7a82575c26570b10$export$c989e53c4b24c2f5);\n$parcel$export(module.exports, \"computeSurfaceArea\", () => $7a82575c26570b10$export$dbf4320364dc239e);\nfunction $7a82575c26570b10$export$40b9a5e446bf11e0(nodeIndex32, array, target) {\n    target.min.x = array[nodeIndex32];\n    target.min.y = array[nodeIndex32 + 1];\n    target.min.z = array[nodeIndex32 + 2];\n    target.max.x = array[nodeIndex32 + 3];\n    target.max.y = array[nodeIndex32 + 4];\n    target.max.z = array[nodeIndex32 + 5];\n    return target;\n}\nfunction $7a82575c26570b10$export$8737d658f04762d3(target) {\n    target[0] = target[1] = target[2] = Infinity;\n    target[3] = target[4] = target[5] = -Infinity;\n}\nfunction $7a82575c26570b10$export$dcdc414399b99746(bounds) {\n    let splitDimIdx = -1;\n    let splitDist = -Infinity;\n    for(let i = 0; i < 3; i++){\n        const dist = bounds[i + 3] - bounds[i];\n        if (dist > splitDist) {\n            splitDist = dist;\n            splitDimIdx = i;\n        }\n    }\n    return splitDimIdx;\n}\nfunction $7a82575c26570b10$export$14b050a767b4a3a7(source, target) {\n    target.set(source);\n}\nfunction $7a82575c26570b10$export$a8a7063dce01a911(a, b, target) {\n    let aVal, bVal;\n    for(let d = 0; d < 3; d++){\n        const d3 = d + 3;\n        // set the minimum values\n        aVal = a[d];\n        bVal = b[d];\n        target[d] = aVal < bVal ? aVal : bVal;\n        // set the max values\n        aVal = a[d3];\n        bVal = b[d3];\n        target[d3] = aVal > bVal ? aVal : bVal;\n    }\n}\nfunction $7a82575c26570b10$export$c989e53c4b24c2f5(startIndex, triangleBounds, bounds) {\n    for(let d = 0; d < 3; d++){\n        const tCenter = triangleBounds[startIndex + 2 * d];\n        const tHalf = triangleBounds[startIndex + 2 * d + 1];\n        const tMin = tCenter - tHalf;\n        const tMax = tCenter + tHalf;\n        if (tMin < bounds[d]) bounds[d] = tMin;\n        if (tMax > bounds[d + 3]) bounds[d + 3] = tMax;\n    }\n}\nfunction $7a82575c26570b10$export$dbf4320364dc239e(bounds) {\n    const d0 = bounds[3] - bounds[0];\n    const d1 = bounds[4] - bounds[1];\n    const d2 = bounds[5] - bounds[2];\n    return 2 * (d0 * d1 + d1 * d2 + d2 * d0);\n}\n\n});\n\n\nparcelRegister(\"43QJu\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHNode\", () => $2f5058de141a77f6$export$6f473cc5f89b0a1c);\nclass $2f5058de141a77f6$export$6f473cc5f89b0a1c {\n    constructor(){\n        // internal nodes have boundingData, left, right, and splitAxis\n        // leaf nodes have offset and count (referring to primitives in the mesh geometry)\n        this.boundingData = new Float32Array(6);\n    }\n}\n\n});\n\nparcelRegister(\"1mLHb\", function(module, exports) {\n\n$parcel$export(module.exports, \"partition\", () => $0fecd7d9c2036607$export$b29f828819edca8d);\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction $0fecd7d9c2036607$export$b29f828819edca8d(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos)left++;\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos)right--;\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            for(let i = 0; i < 3; i++){\n                let t0 = index[left * 3 + i];\n                index[left * 3 + i] = index[right * 3 + i];\n                index[right * 3 + i] = t0;\n            }\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else return left;\n    }\n}\n\n});\n\nparcelRegister(\"7OpkL\", function(module, exports) {\n\n$parcel$export(module.exports, \"partition_indirect\", () => $5b00dab01798f87b$export$7cee363d477551d0);\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction $5b00dab01798f87b$export$7cee363d477551d0(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos)left++;\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos)right--;\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            let t = indirectBuffer[left];\n            indirectBuffer[left] = indirectBuffer[right];\n            indirectBuffer[right] = t;\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else return left;\n    }\n}\n\n});\n\nparcelRegister(\"dxzVn\", function(module, exports) {\n\n$parcel$export(module.exports, \"countNodes\", () => $9dba3941aecf6621$export$1daf15cbaf649dad);\n$parcel$export(module.exports, \"populateBuffer\", () => $9dba3941aecf6621$export$faac1b763a0eceb5);\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\nlet $9dba3941aecf6621$var$float32Array, $9dba3941aecf6621$var$uint32Array, $9dba3941aecf6621$var$uint16Array, $9dba3941aecf6621$var$uint8Array;\nconst $9dba3941aecf6621$var$MAX_POINTER = Math.pow(2, 32);\nfunction $9dba3941aecf6621$export$1daf15cbaf649dad(node) {\n    if (\"count\" in node) return 1;\n    else return 1 + $9dba3941aecf6621$export$1daf15cbaf649dad(node.left) + $9dba3941aecf6621$export$1daf15cbaf649dad(node.right);\n}\nfunction $9dba3941aecf6621$export$faac1b763a0eceb5(byteOffset, node, buffer) {\n    $9dba3941aecf6621$var$float32Array = new Float32Array(buffer);\n    $9dba3941aecf6621$var$uint32Array = new Uint32Array(buffer);\n    $9dba3941aecf6621$var$uint16Array = new Uint16Array(buffer);\n    $9dba3941aecf6621$var$uint8Array = new Uint8Array(buffer);\n    return $9dba3941aecf6621$var$_populateBuffer(byteOffset, node);\n}\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction $9dba3941aecf6621$var$_populateBuffer(byteOffset, node) {\n    const stride4Offset = byteOffset / 4;\n    const stride2Offset = byteOffset / 2;\n    const isLeaf = \"count\" in node;\n    const boundingData = node.boundingData;\n    for(let i = 0; i < 6; i++)$9dba3941aecf6621$var$float32Array[stride4Offset + i] = boundingData[i];\n    if (isLeaf) {\n        if (node.buffer) {\n            const buffer = node.buffer;\n            $9dba3941aecf6621$var$uint8Array.set(new Uint8Array(buffer), byteOffset);\n            for(let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += (0, $Mleu6.BYTES_PER_NODE)){\n                const offset2 = offset / 2;\n                if (!(0, $8kAF9.IS_LEAF)(offset2, $9dba3941aecf6621$var$uint16Array)) $9dba3941aecf6621$var$uint32Array[offset / 4 + 6] += stride4Offset;\n            }\n            return byteOffset + buffer.byteLength;\n        } else {\n            const offset = node.offset;\n            const count = node.count;\n            $9dba3941aecf6621$var$uint32Array[stride4Offset + 6] = offset;\n            $9dba3941aecf6621$var$uint16Array[stride2Offset + 14] = count;\n            $9dba3941aecf6621$var$uint16Array[stride2Offset + 15] = (0, $Mleu6.IS_LEAFNODE_FLAG);\n            return byteOffset + (0, $Mleu6.BYTES_PER_NODE);\n        }\n    } else {\n        const left = node.left;\n        const right = node.right;\n        const splitAxis = node.splitAxis;\n        let nextUnusedPointer;\n        nextUnusedPointer = $9dba3941aecf6621$var$_populateBuffer(byteOffset + (0, $Mleu6.BYTES_PER_NODE), left);\n        if (nextUnusedPointer / 4 > $9dba3941aecf6621$var$MAX_POINTER) throw new Error(\"MeshBVH: Cannot store child pointer greater than 32 bits.\");\n        $9dba3941aecf6621$var$uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n        nextUnusedPointer = $9dba3941aecf6621$var$_populateBuffer(nextUnusedPointer, right);\n        $9dba3941aecf6621$var$uint32Array[stride4Offset + 7] = splitAxis;\n        return nextUnusedPointer;\n    }\n}\n\n});\nparcelRegister(\"8kAF9\", function(module, exports) {\n\n$parcel$export(module.exports, \"IS_LEAF\", () => $610ca16d2524dbb1$export$bc7cbaf27fbe938e);\n$parcel$export(module.exports, \"OFFSET\", () => $610ca16d2524dbb1$export$3231e969238304f3);\n$parcel$export(module.exports, \"COUNT\", () => $610ca16d2524dbb1$export$d61684373eacdf61);\n$parcel$export(module.exports, \"LEFT_NODE\", () => $610ca16d2524dbb1$export$7a68bc00425859d);\n$parcel$export(module.exports, \"RIGHT_NODE\", () => $610ca16d2524dbb1$export$4f44f52d9f75fa31);\n$parcel$export(module.exports, \"SPLIT_AXIS\", () => $610ca16d2524dbb1$export$b43717b3ca95505);\n$parcel$export(module.exports, \"BOUNDING_DATA_INDEX\", () => $610ca16d2524dbb1$export$b5b7e27a1440579d);\nfunction $610ca16d2524dbb1$export$bc7cbaf27fbe938e(n16, uint16Array) {\n    return uint16Array[n16 + 15] === 0xFFFF;\n}\nfunction $610ca16d2524dbb1$export$3231e969238304f3(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\nfunction $610ca16d2524dbb1$export$d61684373eacdf61(n16, uint16Array) {\n    return uint16Array[n16 + 14];\n}\nfunction $610ca16d2524dbb1$export$7a68bc00425859d(n32) {\n    return n32 + 8;\n}\nfunction $610ca16d2524dbb1$export$4f44f52d9f75fa31(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\nfunction $610ca16d2524dbb1$export$b43717b3ca95505(n32, uint32Array) {\n    return uint32Array[n32 + 7];\n}\nfunction $610ca16d2524dbb1$export$b5b7e27a1440579d(n32) {\n    return n32;\n}\n\n});\n\n\n\nparcelRegister(\"4ytBV\", function(module, exports) {\n\n$parcel$export(module.exports, \"OrientedBox\", () => $35114e71c81906a5$export$4ccecd8ac6ee0e58);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $9wcBV = parcelRequire(\"9wcBV\");\n\nvar $g90Dw = parcelRequire(\"g90Dw\");\n\nvar $iGy84 = parcelRequire(\"iGy84\");\nclass $35114e71c81906a5$export$4ccecd8ac6ee0e58 {\n    constructor(min, max, matrix){\n        this.isOrientedBox = true;\n        this.min = new (0, $ilwiq.Vector3)();\n        this.max = new (0, $ilwiq.Vector3)();\n        this.matrix = new (0, $ilwiq.Matrix4)();\n        this.invMatrix = new (0, $ilwiq.Matrix4)();\n        this.points = new Array(8).fill().map(()=>new (0, $ilwiq.Vector3)());\n        this.satAxes = new Array(3).fill().map(()=>new (0, $ilwiq.Vector3)());\n        this.satBounds = new Array(3).fill().map(()=>new (0, $9wcBV.SeparatingAxisBounds)());\n        this.alignedSatBounds = new Array(3).fill().map(()=>new (0, $9wcBV.SeparatingAxisBounds)());\n        this.needsUpdate = false;\n        if (min) this.min.copy(min);\n        if (max) this.max.copy(max);\n        if (matrix) this.matrix.copy(matrix);\n    }\n    set(min, max, matrix) {\n        this.min.copy(min);\n        this.max.copy(max);\n        this.matrix.copy(matrix);\n        this.needsUpdate = true;\n    }\n    copy(other) {\n        this.min.copy(other.min);\n        this.max.copy(other.max);\n        this.matrix.copy(other.matrix);\n        this.needsUpdate = true;\n    }\n}\n$35114e71c81906a5$export$4ccecd8ac6ee0e58.prototype.update = function() {\n    return function update() {\n        const matrix = this.matrix;\n        const min = this.min;\n        const max = this.max;\n        const points = this.points;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                const i = 1 * x | 2 * y | 4 * z;\n                const v = points[i];\n                v.x = x ? max.x : min.x;\n                v.y = y ? max.y : min.y;\n                v.z = z ? max.z : min.z;\n                v.applyMatrix4(matrix);\n            }\n        }\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const minVec = points[0];\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            const index = 1 << i;\n            const pi = points[index];\n            axis.subVectors(minVec, pi);\n            sb.setFromPoints(axis, points);\n        }\n        const alignedSatBounds = this.alignedSatBounds;\n        alignedSatBounds[0].setFromPointsField(points, \"x\");\n        alignedSatBounds[1].setFromPointsField(points, \"y\");\n        alignedSatBounds[2].setFromPointsField(points, \"z\");\n        this.invMatrix.copy(this.matrix).invert();\n        this.needsUpdate = false;\n    };\n}();\n$35114e71c81906a5$export$4ccecd8ac6ee0e58.prototype.intersectsBox = function() {\n    const aabbBounds = new (0, $9wcBV.SeparatingAxisBounds)();\n    return function intersectsBox(box) {\n        // TODO: should this be doing SAT against the AABB?\n        if (this.needsUpdate) this.update();\n        const min = box.min;\n        const max = box.max;\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const alignedSatBounds = this.alignedSatBounds;\n        aabbBounds.min = min.x;\n        aabbBounds.max = max.x;\n        if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.y;\n        aabbBounds.max = max.y;\n        if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.z;\n        aabbBounds.max = max.z;\n        if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            aabbBounds.setFromBox(axis, box);\n            if (sb.isSeparated(aabbBounds)) return false;\n        }\n        return true;\n    };\n}();\n$35114e71c81906a5$export$4ccecd8ac6ee0e58.prototype.intersectsTriangle = function() {\n    const saTri = new (0, $g90Dw.ExtendedTriangle)();\n    const pointsArr = new Array(3);\n    const cachedSatBounds = new (0, $9wcBV.SeparatingAxisBounds)();\n    const cachedSatBounds2 = new (0, $9wcBV.SeparatingAxisBounds)();\n    const cachedAxis = new (0, $ilwiq.Vector3)();\n    return function intersectsTriangle(triangle) {\n        if (this.needsUpdate) this.update();\n        if (!triangle.isExtendedTriangle) {\n            saTri.copy(triangle);\n            saTri.update();\n            triangle = saTri;\n        } else if (triangle.needsUpdate) triangle.update();\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        pointsArr[0] = triangle.a;\n        pointsArr[1] = triangle.b;\n        pointsArr[2] = triangle.c;\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds[i];\n            const sa = satAxes[i];\n            cachedSatBounds.setFromPoints(sa, pointsArr);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        const triSatBounds = triangle.satBounds;\n        const triSatAxes = triangle.satAxes;\n        const points = this.points;\n        for(let i = 0; i < 3; i++){\n            const sb = triSatBounds[i];\n            const sa = triSatAxes[i];\n            cachedSatBounds.setFromPoints(sa, points);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        // check crossed axes\n        for(let i = 0; i < 3; i++){\n            const sa1 = satAxes[i];\n            for(let i2 = 0; i2 < 4; i2++){\n                const sa2 = triSatAxes[i2];\n                cachedAxis.crossVectors(sa1, sa2);\n                cachedSatBounds.setFromPoints(cachedAxis, pointsArr);\n                cachedSatBounds2.setFromPoints(cachedAxis, points);\n                if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n            }\n        }\n        return true;\n    };\n}();\n$35114e71c81906a5$export$4ccecd8ac6ee0e58.prototype.closestPointToPoint = function() {\n    return function closestPointToPoint(point, target1) {\n        if (this.needsUpdate) this.update();\n        target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);\n        return target1;\n    };\n}();\n$35114e71c81906a5$export$4ccecd8ac6ee0e58.prototype.distanceToPoint = function() {\n    const target = new (0, $ilwiq.Vector3)();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\n$35114e71c81906a5$export$4ccecd8ac6ee0e58.prototype.distanceToBox = function() {\n    const xyzFields = [\n        \"x\",\n        \"y\",\n        \"z\"\n    ];\n    const segments1 = new Array(12).fill().map(()=>new (0, $ilwiq.Line3)());\n    const segments2 = new Array(12).fill().map(()=>new (0, $ilwiq.Line3)());\n    const point1 = new (0, $ilwiq.Vector3)();\n    const point2 = new (0, $ilwiq.Vector3)();\n    // early out if we find a value below threshold\n    return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {\n        if (this.needsUpdate) this.update();\n        if (this.intersectsBox(box)) {\n            if (target1 || target2) {\n                box.getCenter(point2);\n                this.closestPointToPoint(point2, point1);\n                box.closestPointToPoint(point1, point2);\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n            return 0;\n        }\n        const threshold2 = threshold * threshold;\n        const min = box.min;\n        const max = box.max;\n        const points = this.points;\n        // iterate over every edge and compare distances\n        let closestDistanceSq = Infinity;\n        // check over all these points\n        for(let i = 0; i < 8; i++){\n            const p = points[i];\n            point2.copy(p).clamp(min, max);\n            const dist = p.distanceToSquared(point2);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(p);\n                if (target2) target2.copy(point2);\n                if (dist < threshold2) return Math.sqrt(dist);\n            }\n        }\n        // generate and check all line segment distances\n        let count = 0;\n        for(let i = 0; i < 3; i++){\n            for(let i1 = 0; i1 <= 1; i1++)for(let i2 = 0; i2 <= 1; i2++){\n                const nextIndex = (i + 1) % 3;\n                const nextIndex2 = (i + 2) % 3;\n                // get obb line segments\n                const index = i1 << nextIndex | i2 << nextIndex2;\n                const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n                const p1 = points[index];\n                const p2 = points[index2];\n                const line1 = segments1[count];\n                line1.set(p1, p2);\n                // get aabb line segments\n                const f1 = xyzFields[i];\n                const f2 = xyzFields[nextIndex];\n                const f3 = xyzFields[nextIndex2];\n                const line2 = segments2[count];\n                const start = line2.start;\n                const end = line2.end;\n                start[f1] = min[f1];\n                start[f2] = i1 ? min[f2] : max[f2];\n                start[f3] = i2 ? min[f3] : max[f2];\n                end[f1] = max[f1];\n                end[f2] = i1 ? min[f2] : max[f2];\n                end[f3] = i2 ? min[f3] : max[f2];\n                count++;\n            }\n        }\n        // check all the other boxes point\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                point2.x = x ? max.x : min.x;\n                point2.y = y ? max.y : min.y;\n                point2.z = z ? max.z : min.z;\n                this.closestPointToPoint(point2, point1);\n                const dist = point2.distanceToSquared(point1);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point1);\n                    if (target2) target2.copy(point2);\n                    if (dist < threshold2) return Math.sqrt(dist);\n                }\n            }\n        }\n        for(let i = 0; i < 12; i++){\n            const l1 = segments1[i];\n            for(let i2 = 0; i2 < 12; i2++){\n                const l2 = segments2[i2];\n                (0, $iGy84.closestPointsSegmentToSegment)(l1, l2, point1, point2);\n                const dist = point1.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point1);\n                    if (target2) target2.copy(point2);\n                    if (dist < threshold2) return Math.sqrt(dist);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n\n});\n\nparcelRegister(\"6DMlg\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExtendedTrianglePool\", () => $4d5be2537ebfa66a$export$2622f4315304edad);\n\nvar $g90Dw = parcelRequire(\"g90Dw\");\n\nvar $299oE = parcelRequire(\"299oE\");\nclass $4d5be2537ebfa66a$var$ExtendedTrianglePoolBase extends (0, $299oE.PrimitivePool) {\n    constructor(){\n        super(()=>new (0, $g90Dw.ExtendedTriangle)());\n    }\n}\nconst $4d5be2537ebfa66a$export$2622f4315304edad = /* @__PURE__ */ new $4d5be2537ebfa66a$var$ExtendedTrianglePoolBase();\n\n});\nparcelRegister(\"299oE\", function(module, exports) {\n\n$parcel$export(module.exports, \"PrimitivePool\", () => $1903b603ca48f64a$export$bf300c504651112a);\nclass $1903b603ca48f64a$export$bf300c504651112a {\n    constructor(getNewPrimitive){\n        this._getNewPrimitive = getNewPrimitive;\n        this._primitives = [];\n    }\n    getPrimitive() {\n        const primitives = this._primitives;\n        if (primitives.length === 0) return this._getNewPrimitive();\n        else return primitives.pop();\n    }\n    releasePrimitive(primitive) {\n        this._primitives.push(primitive);\n    }\n}\n\n});\n\n\nparcelRegister(\"aPqeh\", function(module, exports) {\n\n$parcel$export(module.exports, \"shapecast\", () => $7e230369c1953cd7$export$963c78622ed2c172);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $299oE = parcelRequire(\"299oE\");\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $3x2lg = parcelRequire(\"3x2lg\");\nlet $7e230369c1953cd7$var$_box1, $7e230369c1953cd7$var$_box2;\nconst $7e230369c1953cd7$var$boxStack = [];\nconst $7e230369c1953cd7$var$boxPool = /* @__PURE__ */ new (0, $299oE.PrimitivePool)(()=>new (0, $ilwiq.Box3)());\nfunction $7e230369c1953cd7$export$963c78622ed2c172(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {\n    // setup\n    $7e230369c1953cd7$var$_box1 = $7e230369c1953cd7$var$boxPool.getPrimitive();\n    $7e230369c1953cd7$var$_box2 = $7e230369c1953cd7$var$boxPool.getPrimitive();\n    $7e230369c1953cd7$var$boxStack.push($7e230369c1953cd7$var$_box1, $7e230369c1953cd7$var$_box2);\n    (0, $3x2lg.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $7e230369c1953cd7$var$shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n    // cleanup\n    (0, $3x2lg.BufferStack).clearBuffer();\n    $7e230369c1953cd7$var$boxPool.releasePrimitive($7e230369c1953cd7$var$_box1);\n    $7e230369c1953cd7$var$boxPool.releasePrimitive($7e230369c1953cd7$var$_box2);\n    $7e230369c1953cd7$var$boxStack.pop();\n    $7e230369c1953cd7$var$boxStack.pop();\n    const length = $7e230369c1953cd7$var$boxStack.length;\n    if (length > 0) {\n        $7e230369c1953cd7$var$_box2 = $7e230369c1953cd7$var$boxStack[length - 1];\n        $7e230369c1953cd7$var$_box1 = $7e230369c1953cd7$var$boxStack[length - 2];\n    }\n    return result;\n}\nfunction $7e230369c1953cd7$var$shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, $7e230369c1953cd7$var$_box1);\n        return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, $7e230369c1953cd7$var$_box1);\n    } else {\n        const left = (0, $8kAF9.LEFT_NODE)(nodeIndex32);\n        const right = (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array);\n        let c1 = left;\n        let c2 = right;\n        let score1, score2;\n        let box1, box2;\n        if (nodeScoreFunc) {\n            box1 = $7e230369c1953cd7$var$_box1;\n            box2 = $7e230369c1953cd7$var$_box2;\n            // bounding data is not offset\n            (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(c1), float32Array, box1);\n            (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(c2), float32Array, box2);\n            score1 = nodeScoreFunc(box1);\n            score2 = nodeScoreFunc(box2);\n            if (score2 < score1) {\n                c1 = right;\n                c2 = left;\n                const temp = score1;\n                score1 = score2;\n                score2 = temp;\n                box1 = box2;\n            // box2 is always set before use below\n            }\n        }\n        // Check box 1 intersection\n        if (!box1) {\n            box1 = $7e230369c1953cd7$var$_box1;\n            (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(c1), float32Array, box1);\n        }\n        const isC1Leaf = (0, $8kAF9.IS_LEAF)(c1 * 2, uint16Array);\n        const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n        let c1StopTraversal;\n        if (c1Intersection === (0, $Mleu6.CONTAINED)) {\n            const offset = getLeftOffset(c1);\n            const end = getRightEndOffset(c1);\n            const count = end - offset;\n            c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n        } else c1StopTraversal = c1Intersection && $7e230369c1953cd7$var$shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        if (c1StopTraversal) return true;\n        // Check box 2 intersection\n        // cached box2 will have been overwritten by previous traversal\n        box2 = $7e230369c1953cd7$var$_box2;\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(c2), float32Array, box2);\n        const isC2Leaf = (0, $8kAF9.IS_LEAF)(c2 * 2, uint16Array);\n        const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n        let c2StopTraversal;\n        if (c2Intersection === (0, $Mleu6.CONTAINED)) {\n            const offset = getLeftOffset(c2);\n            const end = getRightEndOffset(c2);\n            const count = end - offset;\n            c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);\n        } else c2StopTraversal = c2Intersection && $7e230369c1953cd7$var$shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        if (c2StopTraversal) return true;\n        return false;\n        // Define these inside the function so it has access to the local variables needed\n        // when converting to the buffer equivalents\n        function getLeftOffset(nodeIndex32) {\n            const { uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array)){\n                nodeIndex32 = (0, $8kAF9.LEFT_NODE)(nodeIndex32);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            return (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n        }\n        function getRightEndOffset(nodeIndex32) {\n            const { uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array)){\n                // adjust offset to point to the right node\n                nodeIndex32 = (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            // return the end offset of the triangle range\n            return (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array) + (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n        }\n    }\n}\n\n});\nparcelRegister(\"3x2lg\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferStack\", () => $292645419f252e78$export$7451c73ce907854f);\nclass $292645419f252e78$var$_BufferStack {\n    constructor(){\n        this.float32Array = null;\n        this.uint16Array = null;\n        this.uint32Array = null;\n        const stack = [];\n        let prevBuffer = null;\n        this.setBuffer = (buffer)=>{\n            if (prevBuffer) stack.push(prevBuffer);\n            prevBuffer = buffer;\n            this.float32Array = new Float32Array(buffer);\n            this.uint16Array = new Uint16Array(buffer);\n            this.uint32Array = new Uint32Array(buffer);\n        };\n        this.clearBuffer = ()=>{\n            prevBuffer = null;\n            this.float32Array = null;\n            this.uint16Array = null;\n            this.uint32Array = null;\n            if (stack.length !== 0) this.setBuffer(stack.pop());\n        };\n    }\n}\nconst $292645419f252e78$export$7451c73ce907854f = new $292645419f252e78$var$_BufferStack();\n\n});\n\n\nparcelRegister(\"38TIa\", function(module, exports) {\n\n$parcel$export(module.exports, \"closestPointToPoint\", () => $249d55915c05e0bb$export$96ec44700e587d99);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $249d55915c05e0bb$var$temp = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $249d55915c05e0bb$var$temp1 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nfunction $249d55915c05e0bb$export$96ec44700e587d99(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    let closestDistanceTriIndex = null;\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            $249d55915c05e0bb$var$temp.copy(point).clamp(box.min, box.max);\n            return $249d55915c05e0bb$var$temp.distanceToSquared(point);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: (tri, triIndex)=>{\n            tri.closestPointToPoint(point, $249d55915c05e0bb$var$temp);\n            const distSq = point.distanceToSquared($249d55915c05e0bb$var$temp);\n            if (distSq < closestDistanceSq) {\n                $249d55915c05e0bb$var$temp1.copy($249d55915c05e0bb$var$temp);\n                closestDistanceSq = distSq;\n                closestDistanceTriIndex = triIndex;\n            }\n            if (distSq < minThresholdSq) return true;\n            else return false;\n        }\n    });\n    if (closestDistanceSq === Infinity) return null;\n    const closestDistance = Math.sqrt(closestDistanceSq);\n    if (!target.point) target.point = $249d55915c05e0bb$var$temp1.clone();\n    else target.point.copy($249d55915c05e0bb$var$temp1);\n    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n    return target;\n}\n\n});\n\nparcelRegister(\"8Nb8u\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectTris\", () => $666b89b5d88b26ac$export$6f0a8fc5d2775a51);\n$parcel$export(module.exports, \"intersectClosestTri\", () => $666b89b5d88b26ac$export$4331f2604b0bca4);\n$parcel$export(module.exports, \"iterateOverTriangles\", () => $666b89b5d88b26ac$export$be1391b7aa79c0f6);\n\nvar $aZnKr = parcelRequire(\"aZnKr\");\n\nvar $2GwQ0 = parcelRequire(\"2GwQ0\");\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function $666b89b5d88b26ac$export$6f0a8fc5d2775a51(bvh, side, ray, offset, count, intersections) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++)(0, $aZnKr.intersectTri)(geometry, side, ray, i, intersections);\n}\nfunction $666b89b5d88b26ac$export$4331f2604b0bca4(bvh, side, ray, offset, count) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0, $aZnKr.intersectTri)(geometry, side, ray, i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction $666b89b5d88b26ac$export$be1391b7aa79c0f6(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry: geometry } = bvh;\n    const { index: index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = i;\n        (0, $2GwQ0.setTriangle)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) return true;\n    }\n    return false;\n}\n\n});\nparcelRegister(\"aZnKr\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectTri\", () => $800205c7888e1262$export$1a557053019a130b);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst $800205c7888e1262$var$_vA = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $800205c7888e1262$var$_vB = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $800205c7888e1262$var$_vC = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $800205c7888e1262$var$_uvA = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $800205c7888e1262$var$_uvB = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $800205c7888e1262$var$_uvC = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $800205c7888e1262$var$_normalA = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $800205c7888e1262$var$_normalB = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $800205c7888e1262$var$_normalC = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $800205c7888e1262$var$_intersectionPoint = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nfunction $800205c7888e1262$var$checkIntersection(ray, pA, pB, pC, point, side) {\n    let intersect;\n    if (side === (0, $ilwiq.BackSide)) intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    else intersect = ray.intersectTriangle(pA, pB, pC, side !== (0, $ilwiq.DoubleSide), point);\n    if (intersect === null) return null;\n    const distance = ray.origin.distanceTo(point);\n    return {\n        distance: distance,\n        point: point.clone()\n    };\n}\nfunction $800205c7888e1262$var$checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side) {\n    $800205c7888e1262$var$_vA.fromBufferAttribute(position, a);\n    $800205c7888e1262$var$_vB.fromBufferAttribute(position, b);\n    $800205c7888e1262$var$_vC.fromBufferAttribute(position, c);\n    const intersection = $800205c7888e1262$var$checkIntersection(ray, $800205c7888e1262$var$_vA, $800205c7888e1262$var$_vB, $800205c7888e1262$var$_vC, $800205c7888e1262$var$_intersectionPoint, side);\n    if (intersection) {\n        if (uv) {\n            $800205c7888e1262$var$_uvA.fromBufferAttribute(uv, a);\n            $800205c7888e1262$var$_uvB.fromBufferAttribute(uv, b);\n            $800205c7888e1262$var$_uvC.fromBufferAttribute(uv, c);\n            intersection.uv = (0, $ilwiq.Triangle).getInterpolation($800205c7888e1262$var$_intersectionPoint, $800205c7888e1262$var$_vA, $800205c7888e1262$var$_vB, $800205c7888e1262$var$_vC, $800205c7888e1262$var$_uvA, $800205c7888e1262$var$_uvB, $800205c7888e1262$var$_uvC, new (0, $ilwiq.Vector2)());\n        }\n        if (uv1) {\n            $800205c7888e1262$var$_uvA.fromBufferAttribute(uv1, a);\n            $800205c7888e1262$var$_uvB.fromBufferAttribute(uv1, b);\n            $800205c7888e1262$var$_uvC.fromBufferAttribute(uv1, c);\n            intersection.uv1 = (0, $ilwiq.Triangle).getInterpolation($800205c7888e1262$var$_intersectionPoint, $800205c7888e1262$var$_vA, $800205c7888e1262$var$_vB, $800205c7888e1262$var$_vC, $800205c7888e1262$var$_uvA, $800205c7888e1262$var$_uvB, $800205c7888e1262$var$_uvC, new (0, $ilwiq.Vector2)());\n        }\n        if (normal) {\n            $800205c7888e1262$var$_normalA.fromBufferAttribute(normal, a);\n            $800205c7888e1262$var$_normalB.fromBufferAttribute(normal, b);\n            $800205c7888e1262$var$_normalC.fromBufferAttribute(normal, c);\n            intersection.normal = (0, $ilwiq.Triangle).getInterpolation($800205c7888e1262$var$_intersectionPoint, $800205c7888e1262$var$_vA, $800205c7888e1262$var$_vB, $800205c7888e1262$var$_vC, $800205c7888e1262$var$_normalA, $800205c7888e1262$var$_normalB, $800205c7888e1262$var$_normalC, new (0, $ilwiq.Vector3)());\n            if (intersection.normal.dot(ray.direction) > 0) intersection.normal.multiplyScalar(-1);\n        }\n        const face = {\n            a: a,\n            b: b,\n            c: c,\n            normal: new (0, $ilwiq.Vector3)(),\n            materialIndex: 0\n        };\n        (0, $ilwiq.Triangle).getNormal($800205c7888e1262$var$_vA, $800205c7888e1262$var$_vB, $800205c7888e1262$var$_vC, face.normal);\n        intersection.face = face;\n        intersection.faceIndex = a;\n    }\n    return intersection;\n}\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction $800205c7888e1262$export$1a557053019a130b(geo, side, ray, tri, intersections) {\n    const triOffset = tri * 3;\n    let a = triOffset + 0;\n    let b = triOffset + 1;\n    let c = triOffset + 2;\n    const index = geo.index;\n    if (geo.index) {\n        a = index.getX(a);\n        b = index.getX(b);\n        c = index.getX(c);\n    }\n    const { position: position, normal: normal, uv: uv, uv1: uv1 } = geo.attributes;\n    const intersection = $800205c7888e1262$var$checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side);\n    if (intersection) {\n        intersection.faceIndex = tri;\n        if (intersections) intersections.push(intersection);\n        return intersection;\n    }\n    return null;\n}\n\n});\n\nparcelRegister(\"2GwQ0\", function(module, exports) {\n\n$parcel$export(module.exports, \"setTriangle\", () => $1f48f9e5928534a0$export$32f7fa781964ae30);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $1f48f9e5928534a0$export$32f7fa781964ae30(tri, i, index, pos) {\n    const ta = tri.a;\n    const tb = tri.b;\n    const tc = tri.c;\n    let i0 = i;\n    let i1 = i + 1;\n    let i2 = i + 2;\n    if (index) {\n        i0 = index.getX(i0);\n        i1 = index.getX(i1);\n        i2 = index.getX(i2);\n    }\n    ta.x = pos.getX(i0);\n    ta.y = pos.getY(i0);\n    ta.z = pos.getZ(i0);\n    tb.x = pos.getX(i1);\n    tb.y = pos.getY(i1);\n    tb.z = pos.getZ(i1);\n    tc.x = pos.getX(i2);\n    tc.y = pos.getY(i2);\n    tc.z = pos.getZ(i2);\n}\nconst $1f48f9e5928534a0$var$tempV1 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $1f48f9e5928534a0$var$tempV2 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $1f48f9e5928534a0$var$tempV3 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $1f48f9e5928534a0$var$tempUV1 = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $1f48f9e5928534a0$var$tempUV2 = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nconst $1f48f9e5928534a0$var$tempUV3 = /* @__PURE__ */ new (0, $ilwiq.Vector2)();\nfunction $1f48f9e5928534a0$export$d3cf03f2575167ef(point, geometry, triangleIndex, target) {\n    const indices = geometry.getIndex().array;\n    const positions = geometry.getAttribute(\"position\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const a = indices[triangleIndex * 3];\n    const b = indices[triangleIndex * 3 + 1];\n    const c = indices[triangleIndex * 3 + 2];\n    $1f48f9e5928534a0$var$tempV1.fromBufferAttribute(positions, a);\n    $1f48f9e5928534a0$var$tempV2.fromBufferAttribute(positions, b);\n    $1f48f9e5928534a0$var$tempV3.fromBufferAttribute(positions, c);\n    // find the associated material index\n    let materialIndex = 0;\n    const groups = geometry.groups;\n    const firstVertexIndex = triangleIndex * 3;\n    for(let i = 0, l = groups.length; i < l; i++){\n        const group = groups[i];\n        const { start: start, count: count } = group;\n        if (firstVertexIndex >= start && firstVertexIndex < start + count) {\n            materialIndex = group.materialIndex;\n            break;\n        }\n    }\n    // extract uvs\n    let uv = null;\n    if (uvs) {\n        $1f48f9e5928534a0$var$tempUV1.fromBufferAttribute(uvs, a);\n        $1f48f9e5928534a0$var$tempUV2.fromBufferAttribute(uvs, b);\n        $1f48f9e5928534a0$var$tempUV3.fromBufferAttribute(uvs, c);\n        if (target && target.uv) uv = target.uv;\n        else uv = new (0, $ilwiq.Vector2)();\n        (0, $ilwiq.Triangle).getInterpolation(point, $1f48f9e5928534a0$var$tempV1, $1f48f9e5928534a0$var$tempV2, $1f48f9e5928534a0$var$tempV3, $1f48f9e5928534a0$var$tempUV1, $1f48f9e5928534a0$var$tempUV2, $1f48f9e5928534a0$var$tempUV3, uv);\n    }\n    // adjust the provided target or create a new one\n    if (target) {\n        if (!target.face) target.face = {};\n        target.face.a = a;\n        target.face.b = b;\n        target.face.c = c;\n        target.face.materialIndex = materialIndex;\n        if (!target.face.normal) target.face.normal = new (0, $ilwiq.Vector3)();\n        (0, $ilwiq.Triangle).getNormal($1f48f9e5928534a0$var$tempV1, $1f48f9e5928534a0$var$tempV2, $1f48f9e5928534a0$var$tempV3, target.face.normal);\n        if (uv) target.uv = uv;\n        return target;\n    } else return {\n        face: {\n            a: a,\n            b: b,\n            c: c,\n            materialIndex: materialIndex,\n            normal: (0, $ilwiq.Triangle).getNormal($1f48f9e5928534a0$var$tempV1, $1f48f9e5928534a0$var$tempV2, $1f48f9e5928534a0$var$tempV3, new (0, $ilwiq.Vector3)())\n        },\n        uv: uv\n    };\n}\n\n});\n\n\nparcelRegister(\"6pOPX\", function(module, exports) {\n\n$parcel$export(module.exports, \"refit\", () => $4abc830a0d5e1fa4$export$8eb1eda96b2e6d7a);\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function $4abc830a0d5e1fa4$export$8eb1eda96b2e6d7a(bvh, nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) nodeIndices = new Set(nodeIndices);\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === (0, $Mleu6.IS_LEAFNODE_FLAG);\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = 3 * offset, l = 3 * (offset + count); i < l; i++){\n                let index = indexArr[i];\n                const x = posAttr.getX(index);\n                const y = posAttr.getY(index);\n                const z = posAttr.getZ(index);\n                if (x < minx) minx = x;\n                if (x > maxx) maxx = x;\n                if (y < miny) miny = y;\n                if (y > maxy) maxy = y;\n                if (z < minz) minz = z;\n                if (z > maxz) maxz = z;\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else return false;\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            {\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) leftChange = _traverse(left, byteOffset, forceChildren);\n            let rightChange = false;\n            if (traverseRight) rightChange = _traverse(right, byteOffset, forceChildren);\n            const didChange = leftChange || rightChange;\n            if (didChange) for(let i = 0; i < 3; i++){\n                const lefti = left + i;\n                const righti = right + i;\n                const minLeftValue = float32Array[lefti];\n                const maxLeftValue = float32Array[lefti + 3];\n                const minRightValue = float32Array[righti];\n                const maxRightValue = float32Array[righti + 3];\n                float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n            return didChange;\n        }\n    }\n}\n\n});\n\nparcelRegister(\"01T8e\", function(module, exports) {\n\n$parcel$export(module.exports, \"raycast\", () => $005adc21d339eb76$export$630e89aab3ddc1d6);\n\nvar $7LluF = parcelRequire(\"7LluF\");\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $3x2lg = parcelRequire(\"3x2lg\");\n\nvar $8Nb8u = parcelRequire(\"8Nb8u\");\n\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ function $005adc21d339eb76$export$630e89aab3ddc1d6(bvh, root, side, ray, intersects) {\n    (0, $3x2lg.BufferStack).setBuffer(bvh._roots[root]);\n    $005adc21d339eb76$var$_raycast(0, bvh, side, ray, intersects);\n    (0, $3x2lg.BufferStack).clearBuffer();\n}\nfunction $005adc21d339eb76$var$_raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n        (0, $8Nb8u.intersectTris)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0, $8kAF9.LEFT_NODE)(nodeIndex32);\n        if ((0, $7LluF.intersectRay)(leftIndex, float32Array, ray)) $005adc21d339eb76$var$_raycast(leftIndex, bvh, side, ray, intersects);\n        const rightIndex = (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array);\n        if ((0, $7LluF.intersectRay)(rightIndex, float32Array, ray)) $005adc21d339eb76$var$_raycast(rightIndex, bvh, side, ray, intersects);\n    }\n}\n\n});\nparcelRegister(\"7LluF\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectRay\", () => $5a6d985c161b90d2$export$d5a069a08bb68982);\n/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */ function $5a6d985c161b90d2$export$d5a069a08bb68982(nodeIndex32, array, ray) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / ray.direction.x, invdiry = 1 / ray.direction.y, invdirz = 1 / ray.direction.z;\n    const ox = ray.origin.x;\n    const oy = ray.origin.y;\n    const oz = ray.origin.z;\n    let minx = array[nodeIndex32];\n    let maxx = array[nodeIndex32 + 3];\n    let miny = array[nodeIndex32 + 1];\n    let maxy = array[nodeIndex32 + 3 + 1];\n    let minz = array[nodeIndex32 + 2];\n    let maxz = array[nodeIndex32 + 3 + 2];\n    if (invdirx >= 0) {\n        tmin = (minx - ox) * invdirx;\n        tmax = (maxx - ox) * invdirx;\n    } else {\n        tmin = (maxx - ox) * invdirx;\n        tmax = (minx - ox) * invdirx;\n    }\n    if (invdiry >= 0) {\n        tymin = (miny - oy) * invdiry;\n        tymax = (maxy - oy) * invdiry;\n    } else {\n        tymin = (maxy - oy) * invdiry;\n        tymax = (miny - oy) * invdiry;\n    }\n    if (tmin > tymax || tymin > tmax) return false;\n    if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n    if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n    if (invdirz >= 0) {\n        tzmin = (minz - oz) * invdirz;\n        tzmax = (maxz - oz) * invdirz;\n    } else {\n        tzmin = (maxz - oz) * invdirz;\n        tzmax = (minz - oz) * invdirz;\n    }\n    if (tmin > tzmax || tzmin > tmax) return false;\n    // if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin; // Uncomment this line if add the distance check\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n    //return point closest to the ray (positive side)\n    if (tmax < 0) return false;\n    return true;\n}\n\n});\n\n\nparcelRegister(\"9Aami\", function(module, exports) {\n\n$parcel$export(module.exports, \"raycastFirst\", () => $6f9f82d94a8b7120$export$1fa457bc72ef1a2a);\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $3x2lg = parcelRequire(\"3x2lg\");\n\nvar $7LluF = parcelRequire(\"7LluF\");\n\nvar $8Nb8u = parcelRequire(\"8Nb8u\");\n\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const $6f9f82d94a8b7120$var$_xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction $6f9f82d94a8b7120$export$1fa457bc72ef1a2a(bvh, root, side, ray) {\n    (0, $3x2lg.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $6f9f82d94a8b7120$var$_raycastFirst(0, bvh, side, ray);\n    (0, $3x2lg.BufferStack).clearBuffer();\n    return result;\n}\nfunction $6f9f82d94a8b7120$var$_raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n        return (0, $8Nb8u.intersectClosestTri)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0, $8kAF9.SPLIT_AXIS)(nodeIndex32, uint32Array);\n        const xyzAxis = $6f9f82d94a8b7120$var$_xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0, $8kAF9.LEFT_NODE)(nodeIndex32);\n            c2 = (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array);\n            c2 = (0, $8kAF9.LEFT_NODE)(nodeIndex32);\n        }\n        const c1Intersection = (0, $7LluF.intersectRay)(c1, float32Array, ray);\n        const c1Result = c1Intersection ? $6f9f82d94a8b7120$var$_raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) return c1Result;\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0, $7LluF.intersectRay)(c2, float32Array, ray);\n        const c2Result = c2Intersection ? $6f9f82d94a8b7120$var$_raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        else return c1Result || c2Result || null;\n    }\n}\n\n});\n\nparcelRegister(\"iWlby\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectsGeometry\", () => $dc9e13bfaf89f133$export$b2f96b0abaf94e0a);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $4ytBV = parcelRequire(\"4ytBV\");\n\nvar $g90Dw = parcelRequire(\"g90Dw\");\n\nvar $2GwQ0 = parcelRequire(\"2GwQ0\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $3x2lg = parcelRequire(\"3x2lg\");\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const $dc9e13bfaf89f133$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nconst $dc9e13bfaf89f133$var$triangle = /* @__PURE__ */ new (0, $g90Dw.ExtendedTriangle)();\nconst $dc9e13bfaf89f133$var$triangle2 = /* @__PURE__ */ new (0, $g90Dw.ExtendedTriangle)();\nconst $dc9e13bfaf89f133$var$invertedMat = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $dc9e13bfaf89f133$var$obb = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nconst $dc9e13bfaf89f133$var$obb2 = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nfunction $dc9e13bfaf89f133$export$b2f96b0abaf94e0a(bvh, root, otherGeometry, geometryToBvh) {\n    (0, $3x2lg.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $dc9e13bfaf89f133$var$_intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    (0, $3x2lg.BufferStack).clearBuffer();\n    return result;\n}\nfunction $dc9e13bfaf89f133$var$_intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n        $dc9e13bfaf89f133$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = $dc9e13bfaf89f133$var$obb;\n    }\n    const isLeaf = (0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        $dc9e13bfaf89f133$var$invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, $dc9e13bfaf89f133$var$obb2);\n            $dc9e13bfaf89f133$var$obb2.matrix.copy($dc9e13bfaf89f133$var$invertedMat);\n            $dc9e13bfaf89f133$var$obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>$dc9e13bfaf89f133$var$obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0, $2GwQ0.setTriangle)($dc9e13bfaf89f133$var$triangle2, i, thisIndex, thisPos);\n                        $dc9e13bfaf89f133$var$triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle($dc9e13bfaf89f133$var$triangle2)) return true;\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else // if we're just dealing with raw geometry\n        for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n            // this triangle needs to be transformed into the current BVH coordinate frame\n            (0, $2GwQ0.setTriangle)($dc9e13bfaf89f133$var$triangle, i, thisIndex, thisPos);\n            $dc9e13bfaf89f133$var$triangle.a.applyMatrix4($dc9e13bfaf89f133$var$invertedMat);\n            $dc9e13bfaf89f133$var$triangle.b.applyMatrix4($dc9e13bfaf89f133$var$invertedMat);\n            $dc9e13bfaf89f133$var$triangle.c.applyMatrix4($dc9e13bfaf89f133$var$invertedMat);\n            $dc9e13bfaf89f133$var$triangle.needsUpdate = true;\n            for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                (0, $2GwQ0.setTriangle)($dc9e13bfaf89f133$var$triangle2, i2, index, pos);\n                $dc9e13bfaf89f133$var$triangle2.needsUpdate = true;\n                if ($dc9e13bfaf89f133$var$triangle.intersectsTriangle($dc9e13bfaf89f133$var$triangle2)) return true;\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(left), float32Array, $dc9e13bfaf89f133$var$boundingBox);\n        const leftIntersection = cachedObb.intersectsBox($dc9e13bfaf89f133$var$boundingBox) && $dc9e13bfaf89f133$var$_intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(right), float32Array, $dc9e13bfaf89f133$var$boundingBox);\n        const rightIntersection = cachedObb.intersectsBox($dc9e13bfaf89f133$var$boundingBox) && $dc9e13bfaf89f133$var$_intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"hKG28\", function(module, exports) {\n\n$parcel$export(module.exports, \"closestPointToGeometry\", () => $cec75681cdf57814$export$5912902c175a555e);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $4ytBV = parcelRequire(\"4ytBV\");\n\nvar $2GwQ0 = parcelRequire(\"2GwQ0\");\n\nvar $aBE3W = parcelRequire(\"aBE3W\");\n\nvar $6DMlg = parcelRequire(\"6DMlg\");\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const $cec75681cdf57814$var$tempMatrix = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $cec75681cdf57814$var$obb = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nconst $cec75681cdf57814$var$obb2 = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nconst $cec75681cdf57814$var$temp1 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $cec75681cdf57814$var$temp2 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $cec75681cdf57814$var$temp3 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $cec75681cdf57814$var$temp4 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nfunction $cec75681cdf57814$export$5912902c175a555e(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n    $cec75681cdf57814$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    $cec75681cdf57814$var$obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = (0, $6DMlg.ExtendedTrianglePool).getPrimitive();\n    const triangle2 = (0, $6DMlg.ExtendedTrianglePool).getPrimitive();\n    let tempTarget1 = $cec75681cdf57814$var$temp1;\n    let tempTargetDest1 = $cec75681cdf57814$var$temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = $cec75681cdf57814$var$temp3;\n        tempTargetDest2 = $cec75681cdf57814$var$temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    $cec75681cdf57814$var$tempMatrix.copy(geometryToBvh).invert();\n    $cec75681cdf57814$var$obb2.matrix.copy($cec75681cdf57814$var$tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return $cec75681cdf57814$var$obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    $cec75681cdf57814$var$obb2.min.copy(box.min);\n                    $cec75681cdf57814$var$obb2.max.copy(box.max);\n                    $cec75681cdf57814$var$obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return $cec75681cdf57814$var$obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            (0, $2GwQ0.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                (0, $2GwQ0.setTriangle)(triangle, 3 * i, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) return true;\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0, $aBE3W.getTriCount)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0, $2GwQ0.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        (0, $2GwQ0.setTriangle)(triangle, 3 * i, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) return true;\n                    }\n                }\n            }\n        }\n    });\n    (0, $6DMlg.ExtendedTrianglePool).releasePrimitive(triangle);\n    (0, $6DMlg.ExtendedTrianglePool).releasePrimitive(triangle2);\n    if (closestDistance === Infinity) return null;\n    if (!target1.point) target1.point = tempTargetDest1.clone();\n    else target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4($cec75681cdf57814$var$tempMatrix);\n        tempTargetDest1.applyMatrix4($cec75681cdf57814$var$tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n});\n\nparcelRegister(\"jRigT\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectTris_indirect\", () => $e75123def4e47834$export$7e7412b9f4f11a5c);\n$parcel$export(module.exports, \"intersectClosestTri_indirect\", () => $e75123def4e47834$export$dddff414156655a1);\n$parcel$export(module.exports, \"iterateOverTriangles_indirect\", () => $e75123def4e47834$export$dae1f8efdced590b);\n\nvar $aZnKr = parcelRequire(\"aZnKr\");\n\nvar $2GwQ0 = parcelRequire(\"2GwQ0\");\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function $e75123def4e47834$export$7e7412b9f4f11a5c(bvh, side, ray, offset, count, intersections) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let vi = _indirectBuffer ? _indirectBuffer[i] : i;\n        (0, $aZnKr.intersectTri)(geometry, side, ray, vi, intersections);\n    }\n}\nfunction $e75123def4e47834$export$dddff414156655a1(bvh, side, ray, offset, count) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0, $aZnKr.intersectTri)(geometry, side, ray, _indirectBuffer ? _indirectBuffer[i] : i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction $e75123def4e47834$export$dae1f8efdced590b(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry: geometry } = bvh;\n    const { index: index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = bvh.resolveTriangleIndex(i);\n        (0, $2GwQ0.setTriangle)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) return true;\n    }\n    return false;\n}\n\n});\n\nparcelRegister(\"fRYTF\", function(module, exports) {\n\n$parcel$export(module.exports, \"refit_indirect\", () => $b8db0b19b1b63b30$export$40f4af49b81ca898);\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function $b8db0b19b1b63b30$export$40f4af49b81ca898(bvh, nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) nodeIndices = new Set(nodeIndices);\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === (0, $Mleu6.IS_LEAFNODE_FLAG);\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = offset, l = offset + count; i < l; i++){\n                const t = 3 * bvh.resolveTriangleIndex(i);\n                for(let j = 0; j < 3; j++){\n                    let index = t + j;\n                    index = indexArr ? indexArr[index] : index;\n                    const x = posAttr.getX(index);\n                    const y = posAttr.getY(index);\n                    const z = posAttr.getZ(index);\n                    if (x < minx) minx = x;\n                    if (x > maxx) maxx = x;\n                    if (y < miny) miny = y;\n                    if (y > maxy) maxy = y;\n                    if (z < minz) minz = z;\n                    if (z > maxz) maxz = z;\n                }\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else return false;\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            {\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) leftChange = _traverse(left, byteOffset, forceChildren);\n            let rightChange = false;\n            if (traverseRight) rightChange = _traverse(right, byteOffset, forceChildren);\n            const didChange = leftChange || rightChange;\n            if (didChange) for(let i = 0; i < 3; i++){\n                const lefti = left + i;\n                const righti = right + i;\n                const minLeftValue = float32Array[lefti];\n                const maxLeftValue = float32Array[lefti + 3];\n                const minRightValue = float32Array[righti];\n                const maxRightValue = float32Array[righti + 3];\n                float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n            return didChange;\n        }\n    }\n}\n\n});\n\nparcelRegister(\"6O8bC\", function(module, exports) {\n\n$parcel$export(module.exports, \"raycast_indirect\", () => $4f4dc3384d5102e9$export$1999205ebe856279);\n\nvar $7LluF = parcelRequire(\"7LluF\");\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $3x2lg = parcelRequire(\"3x2lg\");\n\n\nvar $jRigT = parcelRequire(\"jRigT\");\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ function $4f4dc3384d5102e9$export$1999205ebe856279(bvh, root, side, ray, intersects) {\n    (0, $3x2lg.BufferStack).setBuffer(bvh._roots[root]);\n    $4f4dc3384d5102e9$var$_raycast(0, bvh, side, ray, intersects);\n    (0, $3x2lg.BufferStack).clearBuffer();\n}\nfunction $4f4dc3384d5102e9$var$_raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n        (0, $jRigT.intersectTris_indirect)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0, $8kAF9.LEFT_NODE)(nodeIndex32);\n        if ((0, $7LluF.intersectRay)(leftIndex, float32Array, ray)) $4f4dc3384d5102e9$var$_raycast(leftIndex, bvh, side, ray, intersects);\n        const rightIndex = (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array);\n        if ((0, $7LluF.intersectRay)(rightIndex, float32Array, ray)) $4f4dc3384d5102e9$var$_raycast(rightIndex, bvh, side, ray, intersects);\n    }\n}\n\n});\n\nparcelRegister(\"cmjuj\", function(module, exports) {\n\n$parcel$export(module.exports, \"raycastFirst_indirect\", () => $02526e1080e4eec2$export$44e48d4cf2fe0609);\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $3x2lg = parcelRequire(\"3x2lg\");\n\nvar $7LluF = parcelRequire(\"7LluF\");\n\n\nvar $jRigT = parcelRequire(\"jRigT\");\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const $02526e1080e4eec2$var$_xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction $02526e1080e4eec2$export$44e48d4cf2fe0609(bvh, root, side, ray) {\n    (0, $3x2lg.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $02526e1080e4eec2$var$_raycastFirst(0, bvh, side, ray);\n    (0, $3x2lg.BufferStack).clearBuffer();\n    return result;\n}\nfunction $02526e1080e4eec2$var$_raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n        return (0, $jRigT.intersectClosestTri_indirect)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0, $8kAF9.SPLIT_AXIS)(nodeIndex32, uint32Array);\n        const xyzAxis = $02526e1080e4eec2$var$_xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0, $8kAF9.LEFT_NODE)(nodeIndex32);\n            c2 = (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array);\n            c2 = (0, $8kAF9.LEFT_NODE)(nodeIndex32);\n        }\n        const c1Intersection = (0, $7LluF.intersectRay)(c1, float32Array, ray);\n        const c1Result = c1Intersection ? $02526e1080e4eec2$var$_raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) return c1Result;\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0, $7LluF.intersectRay)(c2, float32Array, ray);\n        const c2Result = c2Intersection ? $02526e1080e4eec2$var$_raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        else return c1Result || c2Result || null;\n    }\n}\n\n});\n\nparcelRegister(\"7rVal\", function(module, exports) {\n\n$parcel$export(module.exports, \"intersectsGeometry_indirect\", () => $56c765f9345f8e4f$export$80dca0df80ee0084);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $4ytBV = parcelRequire(\"4ytBV\");\n\nvar $g90Dw = parcelRequire(\"g90Dw\");\n\nvar $2GwQ0 = parcelRequire(\"2GwQ0\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $3x2lg = parcelRequire(\"3x2lg\");\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const $56c765f9345f8e4f$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nconst $56c765f9345f8e4f$var$triangle = /* @__PURE__ */ new (0, $g90Dw.ExtendedTriangle)();\nconst $56c765f9345f8e4f$var$triangle2 = /* @__PURE__ */ new (0, $g90Dw.ExtendedTriangle)();\nconst $56c765f9345f8e4f$var$invertedMat = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $56c765f9345f8e4f$var$obb = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nconst $56c765f9345f8e4f$var$obb2 = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nfunction $56c765f9345f8e4f$export$80dca0df80ee0084(bvh, root, otherGeometry, geometryToBvh) {\n    (0, $3x2lg.BufferStack).setBuffer(bvh._roots[root]);\n    const result = $56c765f9345f8e4f$var$_intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    (0, $3x2lg.BufferStack).clearBuffer();\n    return result;\n}\nfunction $56c765f9345f8e4f$var$_intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $3x2lg.BufferStack);\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n        $56c765f9345f8e4f$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = $56c765f9345f8e4f$var$obb;\n    }\n    const isLeaf = (0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        $56c765f9345f8e4f$var$invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, $56c765f9345f8e4f$var$obb2);\n            $56c765f9345f8e4f$var$obb2.matrix.copy($56c765f9345f8e4f$var$invertedMat);\n            $56c765f9345f8e4f$var$obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>$56c765f9345f8e4f$var$obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset, l = count + offset; i < l; i++){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0, $2GwQ0.setTriangle)($56c765f9345f8e4f$var$triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);\n                        $56c765f9345f8e4f$var$triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle($56c765f9345f8e4f$var$triangle2)) return true;\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else // if we're just dealing with raw geometry\n        for(let i = offset, l = count + offset; i < l; i++){\n            // this triangle needs to be transformed into the current BVH coordinate frame\n            const ti = bvh.resolveTriangleIndex(i);\n            (0, $2GwQ0.setTriangle)($56c765f9345f8e4f$var$triangle, 3 * ti, thisIndex, thisPos);\n            $56c765f9345f8e4f$var$triangle.a.applyMatrix4($56c765f9345f8e4f$var$invertedMat);\n            $56c765f9345f8e4f$var$triangle.b.applyMatrix4($56c765f9345f8e4f$var$invertedMat);\n            $56c765f9345f8e4f$var$triangle.c.applyMatrix4($56c765f9345f8e4f$var$invertedMat);\n            $56c765f9345f8e4f$var$triangle.needsUpdate = true;\n            for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                (0, $2GwQ0.setTriangle)($56c765f9345f8e4f$var$triangle2, i2, index, pos);\n                $56c765f9345f8e4f$var$triangle2.needsUpdate = true;\n                if ($56c765f9345f8e4f$var$triangle.intersectsTriangle($56c765f9345f8e4f$var$triangle2)) return true;\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(left), float32Array, $56c765f9345f8e4f$var$boundingBox);\n        const leftIntersection = cachedObb.intersectsBox($56c765f9345f8e4f$var$boundingBox) && $56c765f9345f8e4f$var$_intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(right), float32Array, $56c765f9345f8e4f$var$boundingBox);\n        const rightIntersection = cachedObb.intersectsBox($56c765f9345f8e4f$var$boundingBox) && $56c765f9345f8e4f$var$_intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"ipmev\", function(module, exports) {\n\n$parcel$export(module.exports, \"closestPointToGeometry_indirect\", () => $d66bcec6ec98051a$export$334b669407b5ec06);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $4ytBV = parcelRequire(\"4ytBV\");\n\nvar $2GwQ0 = parcelRequire(\"2GwQ0\");\n\nvar $aBE3W = parcelRequire(\"aBE3W\");\n\nvar $6DMlg = parcelRequire(\"6DMlg\");\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const $d66bcec6ec98051a$var$tempMatrix = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $d66bcec6ec98051a$var$obb = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nconst $d66bcec6ec98051a$var$obb2 = /* @__PURE__ */ new (0, $4ytBV.OrientedBox)();\nconst $d66bcec6ec98051a$var$temp1 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $d66bcec6ec98051a$var$temp2 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $d66bcec6ec98051a$var$temp3 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nconst $d66bcec6ec98051a$var$temp4 = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\nfunction $d66bcec6ec98051a$export$334b669407b5ec06(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n    $d66bcec6ec98051a$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    $d66bcec6ec98051a$var$obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = (0, $6DMlg.ExtendedTrianglePool).getPrimitive();\n    const triangle2 = (0, $6DMlg.ExtendedTrianglePool).getPrimitive();\n    let tempTarget1 = $d66bcec6ec98051a$var$temp1;\n    let tempTargetDest1 = $d66bcec6ec98051a$var$temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = $d66bcec6ec98051a$var$temp3;\n        tempTargetDest2 = $d66bcec6ec98051a$var$temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    $d66bcec6ec98051a$var$tempMatrix.copy(geometryToBvh).invert();\n    $d66bcec6ec98051a$var$obb2.matrix.copy($d66bcec6ec98051a$var$tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return $d66bcec6ec98051a$var$obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    $d66bcec6ec98051a$var$obb2.min.copy(box.min);\n                    $d66bcec6ec98051a$var$obb2.max.copy(box.max);\n                    $d66bcec6ec98051a$var$obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return $d66bcec6ec98051a$var$obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            const ti2 = otherBvh.resolveTriangleIndex(i2);\n                            (0, $2GwQ0.setTriangle)(triangle2, 3 * ti2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                const ti = bvh.resolveTriangleIndex(i);\n                                (0, $2GwQ0.setTriangle)(triangle, 3 * ti, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) return true;\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0, $aBE3W.getTriCount)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0, $2GwQ0.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        const ti = bvh.resolveTriangleIndex(i);\n                        (0, $2GwQ0.setTriangle)(triangle, 3 * ti, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) return true;\n                    }\n                }\n            }\n        }\n    });\n    (0, $6DMlg.ExtendedTrianglePool).releasePrimitive(triangle);\n    (0, $6DMlg.ExtendedTrianglePool).releasePrimitive(triangle2);\n    if (closestDistance === Infinity) return null;\n    if (!target1.point) target1.point = tempTargetDest1.clone();\n    else target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4($d66bcec6ec98051a$var$tempMatrix);\n        tempTargetDest1.applyMatrix4($d66bcec6ec98051a$var$tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n});\n\nparcelRegister(\"2zRsl\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSharedArrayBufferSupported\", () => $1e0850ef1728edf3$export$9c28fa8114adc339);\n$parcel$export(module.exports, \"convertToBufferType\", () => $1e0850ef1728edf3$export$fadff02e9aa23f60);\nfunction $1e0850ef1728edf3$export$9c28fa8114adc339() {\n    return typeof SharedArrayBuffer !== \"undefined\";\n}\nfunction $1e0850ef1728edf3$export$fadff02e9aa23f60(array, BufferConstructor) {\n    if (array === null) return array;\n    else if (array.buffer) {\n        const buffer = array.buffer;\n        if (buffer.constructor === BufferConstructor) return array;\n        const ArrayConstructor = array.constructor;\n        const result = new ArrayConstructor(new BufferConstructor(buffer.byteLength));\n        result.set(array);\n        return result;\n    } else {\n        if (array.constructor === BufferConstructor) return array;\n        const result = new BufferConstructor(array.byteLength);\n        new Uint8Array(result).set(new Uint8Array(array));\n        return result;\n    }\n}\n\n});\n\nparcelRegister(\"eLAt7\", function(module, exports) {\n\n$parcel$export(module.exports, \"bvhcast\", () => $ac01be60b9223c52$export$a2253c6980b92559);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $3x2lg = parcelRequire(\"3x2lg\");\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $299oE = parcelRequire(\"299oE\");\nconst $ac01be60b9223c52$var$_bufferStack1 = new (0, $3x2lg.BufferStack).constructor();\nconst $ac01be60b9223c52$var$_bufferStack2 = new (0, $3x2lg.BufferStack).constructor();\nconst $ac01be60b9223c52$var$_boxPool = new (0, $299oE.PrimitivePool)(()=>new (0, $ilwiq.Box3)());\nconst $ac01be60b9223c52$var$_leftBox1 = new (0, $ilwiq.Box3)();\nconst $ac01be60b9223c52$var$_rightBox1 = new (0, $ilwiq.Box3)();\nconst $ac01be60b9223c52$var$_leftBox2 = new (0, $ilwiq.Box3)();\nconst $ac01be60b9223c52$var$_rightBox2 = new (0, $ilwiq.Box3)();\nlet $ac01be60b9223c52$var$_active = false;\nfunction $ac01be60b9223c52$export$a2253c6980b92559(bvh, otherBvh, matrixToLocal, intersectsRanges) {\n    if ($ac01be60b9223c52$var$_active) throw new Error(\"MeshBVH: Recursive calls to bvhcast not supported.\");\n    $ac01be60b9223c52$var$_active = true;\n    const roots = bvh._roots;\n    const otherRoots = otherBvh._roots;\n    let result;\n    let offset1 = 0;\n    let offset2 = 0;\n    const invMat = new (0, $ilwiq.Matrix4)().copy(matrixToLocal).invert();\n    // iterate over the first set of roots\n    for(let i = 0, il = roots.length; i < il; i++){\n        $ac01be60b9223c52$var$_bufferStack1.setBuffer(roots[i]);\n        offset2 = 0;\n        // prep the initial root box\n        const localBox = $ac01be60b9223c52$var$_boxPool.getPrimitive();\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(0), $ac01be60b9223c52$var$_bufferStack1.float32Array, localBox);\n        localBox.applyMatrix4(invMat);\n        // iterate over the second set of roots\n        for(let j = 0, jl = otherRoots.length; j < jl; j++){\n            $ac01be60b9223c52$var$_bufferStack2.setBuffer(otherRoots[i]);\n            result = $ac01be60b9223c52$var$_traverse(0, 0, matrixToLocal, invMat, intersectsRanges, offset1, offset2, 0, 0, localBox);\n            $ac01be60b9223c52$var$_bufferStack2.clearBuffer();\n            offset2 += otherRoots[j].length;\n            if (result) break;\n        }\n        // release stack info\n        $ac01be60b9223c52$var$_boxPool.releasePrimitive(localBox);\n        $ac01be60b9223c52$var$_bufferStack1.clearBuffer();\n        offset1 += roots[i].length;\n        if (result) break;\n    }\n    $ac01be60b9223c52$var$_active = false;\n    return result;\n}\nfunction $ac01be60b9223c52$var$_traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, // offsets for ids\nnode1IndexByteOffset = 0, node2IndexByteOffset = 0, // tree depth\ndepth1 = 0, depth2 = 0, currBox = null, reversed = false) {\n    // get the buffer stacks associated with the current indices\n    let bufferStack1, bufferStack2;\n    if (reversed) {\n        bufferStack1 = $ac01be60b9223c52$var$_bufferStack2;\n        bufferStack2 = $ac01be60b9223c52$var$_bufferStack1;\n    } else {\n        bufferStack1 = $ac01be60b9223c52$var$_bufferStack1;\n        bufferStack2 = $ac01be60b9223c52$var$_bufferStack2;\n    }\n    // get the local instances of the typed buffers\n    const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;\n    const node1Index16 = node1Index32 * 2;\n    const node2Index16 = node2Index32 * 2;\n    const isLeaf1 = (0, $8kAF9.IS_LEAF)(node1Index16, uint16Array1);\n    const isLeaf2 = (0, $8kAF9.IS_LEAF)(node2Index16, uint16Array2);\n    let result = false;\n    if (isLeaf2 && isLeaf1) {\n        // if both bounds are leaf nodes then fire the callback if the boxes intersect\n        if (reversed) result = intersectsRangesFunc((0, $8kAF9.OFFSET)(node2Index32, uint32Array2), (0, $8kAF9.COUNT)(node2Index32 * 2, uint16Array2), (0, $8kAF9.OFFSET)(node1Index32, uint32Array1), (0, $8kAF9.COUNT)(node1Index32 * 2, uint16Array1), depth2, node2IndexByteOffset + node2Index32, depth1, node1IndexByteOffset + node1Index32);\n        else result = intersectsRangesFunc((0, $8kAF9.OFFSET)(node1Index32, uint32Array1), (0, $8kAF9.COUNT)(node1Index32 * 2, uint16Array1), (0, $8kAF9.OFFSET)(node2Index32, uint32Array2), (0, $8kAF9.COUNT)(node2Index32 * 2, uint16Array2), depth1, node1IndexByteOffset + node1Index32, depth2, node2IndexByteOffset + node2Index32);\n    } else if (isLeaf2) {\n        // SWAP\n        // If we've traversed to the leaf node on the other bvh then we need to swap over\n        // to traverse down the first one\n        // get the new box to use\n        const newBox = $ac01be60b9223c52$var$_boxPool.getPrimitive();\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(node2Index32), float32Array2, newBox);\n        newBox.applyMatrix4(matrix2to1);\n        // get the child bounds to check before traversal\n        const cl1 = (0, $8kAF9.LEFT_NODE)(node1Index32);\n        const cr1 = (0, $8kAF9.RIGHT_NODE)(node1Index32, uint32Array1);\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(cl1), float32Array1, $ac01be60b9223c52$var$_leftBox1);\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(cr1), float32Array1, $ac01be60b9223c52$var$_rightBox1);\n        // precompute the intersections otherwise the global boxes will be modified during traversal\n        const intersectCl1 = newBox.intersectsBox($ac01be60b9223c52$var$_leftBox1);\n        const intersectCr1 = newBox.intersectsBox($ac01be60b9223c52$var$_rightBox1);\n        result = intersectCl1 && $ac01be60b9223c52$var$_traverse(node2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && $ac01be60b9223c52$var$_traverse(node2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n        $ac01be60b9223c52$var$_boxPool.releasePrimitive(newBox);\n    } else {\n        // if neither are leaves then we should swap if one of the children does not\n        // intersect with the current bounds\n        // get the child bounds to check\n        const cl2 = (0, $8kAF9.LEFT_NODE)(node2Index32);\n        const cr2 = (0, $8kAF9.RIGHT_NODE)(node2Index32, uint32Array2);\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(cl2), float32Array2, $ac01be60b9223c52$var$_leftBox2);\n        (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(cr2), float32Array2, $ac01be60b9223c52$var$_rightBox2);\n        const leftIntersects = currBox.intersectsBox($ac01be60b9223c52$var$_leftBox2);\n        const rightIntersects = currBox.intersectsBox($ac01be60b9223c52$var$_rightBox2);\n        if (leftIntersects && rightIntersects) // continue to traverse both children if they both intersect\n        result = $ac01be60b9223c52$var$_traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed) || $ac01be60b9223c52$var$_traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n        else if (leftIntersects) {\n            if (isLeaf1) // if the current box is a leaf then just continue\n            result = $ac01be60b9223c52$var$_traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n            else {\n                // SWAP\n                // if only one box intersects then we have to swap to the other bvh to continue\n                const newBox = $ac01be60b9223c52$var$_boxPool.getPrimitive();\n                newBox.copy($ac01be60b9223c52$var$_leftBox2).applyMatrix4(matrix2to1);\n                const cl1 = (0, $8kAF9.LEFT_NODE)(node1Index32);\n                const cr1 = (0, $8kAF9.RIGHT_NODE)(node1Index32, uint32Array1);\n                (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(cl1), float32Array1, $ac01be60b9223c52$var$_leftBox1);\n                (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(cr1), float32Array1, $ac01be60b9223c52$var$_rightBox1);\n                // precompute the intersections otherwise the global boxes will be modified during traversal\n                const intersectCl1 = newBox.intersectsBox($ac01be60b9223c52$var$_leftBox1);\n                const intersectCr1 = newBox.intersectsBox($ac01be60b9223c52$var$_rightBox1);\n                result = intersectCl1 && $ac01be60b9223c52$var$_traverse(cl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && $ac01be60b9223c52$var$_traverse(cl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n                $ac01be60b9223c52$var$_boxPool.releasePrimitive(newBox);\n            }\n        } else if (rightIntersects) {\n            if (isLeaf1) // if the current box is a leaf then just continue\n            result = $ac01be60b9223c52$var$_traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n            else {\n                // SWAP\n                // if only one box intersects then we have to swap to the other bvh to continue\n                const newBox = $ac01be60b9223c52$var$_boxPool.getPrimitive();\n                newBox.copy($ac01be60b9223c52$var$_rightBox2).applyMatrix4(matrix2to1);\n                const cl1 = (0, $8kAF9.LEFT_NODE)(node1Index32);\n                const cr1 = (0, $8kAF9.RIGHT_NODE)(node1Index32, uint32Array1);\n                (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(cl1), float32Array1, $ac01be60b9223c52$var$_leftBox1);\n                (0, $aw71y.arrayToBox)((0, $8kAF9.BOUNDING_DATA_INDEX)(cr1), float32Array1, $ac01be60b9223c52$var$_rightBox1);\n                // precompute the intersections otherwise the global boxes will be modified during traversal\n                const intersectCl1 = newBox.intersectsBox($ac01be60b9223c52$var$_leftBox1);\n                const intersectCr1 = newBox.intersectsBox($ac01be60b9223c52$var$_rightBox1);\n                result = intersectCl1 && $ac01be60b9223c52$var$_traverse(cr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && $ac01be60b9223c52$var$_traverse(cr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n                $ac01be60b9223c52$var$_boxPool.releasePrimitive(newBox);\n            }\n        }\n    }\n    return result;\n}\n\n});\n\n\n\n//# sourceMappingURL=asyncGenerate.77ce35af.js.map\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst { _indirectBuffer } = this;\n\t\tthis.resolveTriangleIndex = options.indirect ? i => _indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst normalized = posAttr.normalized;\n\tlet triangleBounds;\n\tif ( target === null ) {\n\n\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\n\t\toffset = 0;\n\t\tcount = triCount;\n\n\t} else {\n\n\t\ttriangleBounds = target;\n\t\toffset = offset || 0;\n\t\tcount = count || triCount;\n\n\t}\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst stride4Offset = byteOffset / 4;\n\tconst stride2Offset = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tconst buffer = node.buffer;\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = node.left;\n\t\tconst right = node.right;\n\t\tconst splitAxis = node.splitAxis;\n\n\t\tlet nextUnusedPointer;\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t}\n\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\treturn nextUnusedPointer;\n\n\t}\n\n}\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\t// if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin; // Uncomment this line if add the distance check\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\tif ( tmax < 0 ) return false;\n\n\treturn true;\n\n}\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$b18ea3b4dfb4ebb9$export$9d614b3bc2c4eacf","$ilwiq","$Mleu6","$4ARWa","$4ytBV","$aw71y","$6DMlg","$aPqeh","$38TIa","$8Nb8u","$6pOPX","$01T8e","$9Aami","$iWlby","$hKG28","$jRigT","$fRYTF","$6O8bC","$cmjuj","$7rVal","$ipmev","$2zRsl","$2GwQ0","$eLAt7","$b18ea3b4dfb4ebb9$var$obb","OrientedBox","$b18ea3b4dfb4ebb9$var$tempBox","Box3","$b18ea3b4dfb4ebb9$export$93ca5d3f8675ae4c","strategy","CENTER","maxDepth","maxLeafTris","useSharedArrayBuffer","setBoundingBox","onProgress","indirect","verbose","serialize","bvh","options","cloneBuffers","geometry","rootData","_roots","indirectBuffer","_indirectBuffer","indexAttribute","getIndex","roots","map","root","slice","index","array","deserialize","data","setIndex","Boolean","SKIP_GENERATION","newIndex","BufferAttribute","needsUpdate","constructor","isBufferGeometry","isInterleavedBufferAttribute","assign","isSharedArrayBufferSupported","buildPackedTree","boundingBox","getBoundingBox","resolveTriangleIndex","i","refit","nodeIndices","refitFunc","refit_indirect","traverse","callback","rootIndex","buffer","uint32Array","Uint32Array","uint16Array","Uint16Array","_traverse","node32Index","depth","node16Index","isLeaf","IS_LEAFNODE_FLAG","offset","count","Float32Array","left","BYTES_PER_NODE","right","splitAxis","raycast","ray","materialOrSide","FrontSide","intersects","isMaterial","isArrayMaterial","Array","isArray","groups","side","raycastFunc","raycast_indirect","l","length","materialSide","materialIndex","startCount","j","jl","face","raycastFirst","closestResult","raycastFirstFunc","raycastFirst_indirect","result","distance","intersectsGeometry","otherGeometry","geomToMesh","intersectsGeometryFunc","intersectsGeometry_indirect","shapecast","callbacks","triangle","ExtendedTrianglePool","getPrimitive","iterateFunc","iterateOverTriangles_indirect","iterateOverTriangles","boundsTraverseOrder","intersectsBounds","intersectsRange","intersectsTriangle","originalIntersectsRange","contained","nodeIndex","byteOffset","byteLength","releasePrimitive","bvhcast","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","triangle1","indexAttr1","positionAttr1","attributes","position","assignTriangle1","i1","ti","setTriangle","triangle2","indexAttr2","positionAttr2","assignTriangle2","i2","ti2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","l2","a","applyMatrix4","b","c","l1","originalIntersectsRanges","intersectsBox","box","boxToMesh","min","max","tri","intersectsSphere","sphere","closestPointToGeometry","geometryToBvh","target1","target2","minThreshold","maxThreshold","Infinity","closestPointToGeometryFunc","closestPointToGeometry_indirect","closestPointToPoint","point","target","makeEmpty","forEach","arrayToBox","union","$0914f42a72aa7e13$export$91c2158bc24c63d4","$0914f42a72aa7e13$export$d3bfe4097a2a8542","$0914f42a72aa7e13$export$2b2cc3fb4f03d723","$0914f42a72aa7e13$export$34b5498ca69d033","$0914f42a72aa7e13$export$a26e00882057cd76","$0914f42a72aa7e13$export$82ad94f0a038b67a","$0914f42a72aa7e13$export$22e1995328fd3cd9","$0914f42a72aa7e13$export$f4b101accf1b23d1","$0914f42a72aa7e13$export$a08e7d18fbc53be5","$0914f42a72aa7e13$export$661fddb62bfe0e42","$0914f42a72aa7e13$export$859129fb5c8f4dc1","$0914f42a72aa7e13$export$abef70518a11a6ba","Math","Symbol","$35845d08f06466da$export$e63bca57f220b8e3","$aBE3W","$1EkjE","$kgX4U","$43QJu","$1mLHb","$7OpkL","$dxzVn","$35845d08f06466da$export$6008de7a0114426c","triCount","useUint32","byteCount","SharedArrayBuffer","ArrayBuffer","hasGroupGaps","console","warn","ensureIndex","BufferConstructor","triangleBounds","computeTriangleBounds","geometryRanges","getFullGeometryRange","getRootIndexRanges","range","$35845d08f06466da$export$9896244d8c99a4d0","indexArray","partionFunc","partition_indirect","partition","totalTriangles","getTriCount","cacheCentroidBoundingData","reachedMaxDepth","MeshBVHNode","getBounds","boundingData","splitNode","node","centroidBoundingData","triggerProgress","split","getOptimalSplit","axis","splitOffset","lcount","rcount","trianglesProcessed","nodeCount","countNodes","populateBuffer","$7b8c6fb2f021bdd3$export$bb010cc24ecaa644","$7b8c6fb2f021bdd3$export$c56c51fae37b2d63","$7b8c6fb2f021bdd3$export$62808f0201824da2","$7b8c6fb2f021bdd3$export$90fd303420808ebb","$7b8c6fb2f021bdd3$export$8c9d42783264c26e","$7b8c6fb2f021bdd3$export$fd7a16c461f5043c","$7b8c6fb2f021bdd3$export$d3cf4eabab21775d","geo","vertexCount","drawRange","start","end","floor","ranges","rangeBoundaries","Set","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","add","sortedBoundaries","from","values","sort","push","finalGroup","total","$13394934ac4ef772$export$becd1e645219fa23","$13394934ac4ef772$export$b3cc4d5d5179e78c","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","posAttr","normalized","posArr","bufferOffset","stride","getters","tri3","tri6","ai","bi","ci","el","halfExtents","el2","abs","FLOAT32_EPSILON","$ec2320f915f98c17$export$9e40712018083c80","$ec2320f915f98c17$var$binsSort","candidate","$ec2320f915f98c17$var$sahBins","fill","bounds","rightCacheBounds","leftCacheBounds","$ec2320f915f98c17$var$leftBounds","nodeBoundingData","pos","getLongestEdgeIndex","AVERAGE","$ec2320f915f98c17$var$getAverage","avg","SAH","rootSurfaceArea","computeSurfaceArea","bestCost","TRIANGLE_INTERSECT_COST","cStart","cEnd","axisLeft","binWidth","axisLength","axisRight","$ec2320f915f98c17$var$BIN_COUNT","truncatedBins","bin","d","expandByTriangleBounds","splitCount","splice","center","leftCount","rightCount","leftBounds","rightBounds","leftProb","rightProb","cost","TRAVERSAL_COST","binIndex","relativeCenter","triCenter","lastBin","copyBounds","nextBin","unionBounds","binCount","$7a82575c26570b10$export$40b9a5e446bf11e0","nodeIndex32","x","y","z","$7a82575c26570b10$export$dcdc414399b99746","splitDimIdx","splitDist","dist","$7a82575c26570b10$export$14b050a767b4a3a7","source","$7a82575c26570b10$export$a8a7063dce01a911","aVal","bVal","d3","$7a82575c26570b10$export$c989e53c4b24c2f5","startIndex","tCenter","tHalf","tMin","tMax","$7a82575c26570b10$export$dbf4320364dc239e","d0","d1","d2","$2f5058de141a77f6$export$6f473cc5f89b0a1c","$0fecd7d9c2036607$export$b29f828819edca8d","axisOffset","t0","tb","$5b00dab01798f87b$export$7cee363d477551d0","t","$9dba3941aecf6621$var$float32Array","$9dba3941aecf6621$var$uint32Array","$9dba3941aecf6621$var$uint16Array","$9dba3941aecf6621$var$uint8Array","$9dba3941aecf6621$export$1daf15cbaf649dad","$9dba3941aecf6621$export$faac1b763a0eceb5","$8kAF9","Uint8Array","$9dba3941aecf6621$var$_populateBuffer","stride4Offset","stride2Offset","IS_LEAF","nextUnusedPointer","$610ca16d2524dbb1$export$bc7cbaf27fbe938e","n16","$610ca16d2524dbb1$export$3231e969238304f3","n32","$610ca16d2524dbb1$export$d61684373eacdf61","$610ca16d2524dbb1$export$7a68bc00425859d","$610ca16d2524dbb1$export$4f44f52d9f75fa31","$610ca16d2524dbb1$export$b43717b3ca95505","$610ca16d2524dbb1$export$b5b7e27a1440579d","$35114e71c81906a5$export$4ccecd8ac6ee0e58","$9wcBV","$g90Dw","$iGy84","matrix","isOrientedBox","Vector3","Matrix4","invMatrix","points","satAxes","satBounds","SeparatingAxisBounds","alignedSatBounds","copy","other","prototype","update","minVec","sb","pi","subVectors","setFromPoints","setFromPointsField","invert","aabbBounds","isSeparated","setFromBox","saTri","ExtendedTriangle","pointsArr","cachedSatBounds","cachedSatBounds2","cachedAxis","isExtendedTriangle","sa","triSatBounds","triSatAxes","sa1","sa2","crossVectors","clamp","distanceToPoint","distanceTo","distanceToBox","xyzFields","segments1","Line3","segments2","point1","point2","threshold","getCenter","threshold2","closestDistanceSq","p","distanceToSquared","sqrt","nextIndex","nextIndex2","p1","p2","line1","f1","f2","f3","line2","closestPointsSegmentToSegment","$4d5be2537ebfa66a$export$2622f4315304edad","$299oE","$4d5be2537ebfa66a$var$ExtendedTrianglePoolBase","PrimitivePool","$1903b603ca48f64a$export$bf300c504651112a","getNewPrimitive","_getNewPrimitive","_primitives","primitives","pop","primitive","$7e230369c1953cd7$var$_box1","$7e230369c1953cd7$var$_box2","$7e230369c1953cd7$export$963c78622ed2c172","$3x2lg","$7e230369c1953cd7$var$boxStack","$7e230369c1953cd7$var$boxPool","BufferStack","setBuffer","$7e230369c1953cd7$var$shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","float32Array","nodeIndex16","OFFSET","COUNT","BOUNDING_DATA_INDEX","score1","score2","box1","box2","c1StopTraversal","c2StopTraversal","LEFT_NODE","RIGHT_NODE","c1","c2","temp","c1Intersection","CONTAINED","getLeftOffset","getRightEndOffset","c2Intersection","clearBuffer","$292645419f252e78$export$7451c73ce907854f","stack","prevBuffer","$249d55915c05e0bb$export$96ec44700e587d99","$249d55915c05e0bb$var$temp","$249d55915c05e0bb$var$temp1","minThresholdSq","maxThresholdSq","closestDistanceTriIndex","score","triIndex","distSq","closestDistance","clone","faceIndex","$666b89b5d88b26ac$export$6f0a8fc5d2775a51","$666b89b5d88b26ac$export$4331f2604b0bca4","$666b89b5d88b26ac$export$be1391b7aa79c0f6","$aZnKr","intersections","intersectTri","res","intersection","intersectsTriangleFunc","$800205c7888e1262$export$1a557053019a130b","$800205c7888e1262$var$_vA","$800205c7888e1262$var$_vB","$800205c7888e1262$var$_vC","$800205c7888e1262$var$_uvA","Vector2","$800205c7888e1262$var$_uvB","$800205c7888e1262$var$_uvC","$800205c7888e1262$var$_normalA","$800205c7888e1262$var$_normalB","$800205c7888e1262$var$_normalC","$800205c7888e1262$var$_intersectionPoint","triOffset","getX","normal","uv","uv1","$800205c7888e1262$var$checkBufferGeometryIntersection","fromBufferAttribute","intersect","BackSide","intersectTriangle","DoubleSide","origin","Triangle","getInterpolation","dot","direction","multiplyScalar","getNormal","$1f48f9e5928534a0$export$32f7fa781964ae30","ta","tc","i0","getY","getZ","$4abc830a0d5e1fa4$export$8eb1eda96b2e6d7a","indexArr","force","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","$005adc21d339eb76$export$630e89aab3ddc1d6","$7LluF","$005adc21d339eb76$var$_raycast","intersectTris","leftIndex","intersectRay","rightIndex","$5a6d985c161b90d2$export$d5a069a08bb68982","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","ox","oy","oz","isNaN","$6f9f82d94a8b7120$export$1fa457bc72ef1a2a","$6f9f82d94a8b7120$var$_xyzFields","$6f9f82d94a8b7120$var$_raycastFirst","intersectClosestTri","SPLIT_AXIS","xyzAxis","leftToRight","rayDir","c1Result","c2Result","$dc9e13bfaf89f133$export$b2f96b0abaf94e0a","$dc9e13bfaf89f133$var$boundingBox","$dc9e13bfaf89f133$var$triangle","$dc9e13bfaf89f133$var$triangle2","$dc9e13bfaf89f133$var$invertedMat","$dc9e13bfaf89f133$var$obb","$dc9e13bfaf89f133$var$obb2","$dc9e13bfaf89f133$var$_intersectsGeometry","cachedObb","computeBoundingBox","thisGeometry","thisIndex","thisPos","boundsTree","$cec75681cdf57814$export$5912902c175a555e","$cec75681cdf57814$var$tempMatrix","$cec75681cdf57814$var$obb","$cec75681cdf57814$var$obb2","$cec75681cdf57814$var$temp1","$cec75681cdf57814$var$temp2","$cec75681cdf57814$var$temp3","$cec75681cdf57814$var$temp4","otherPos","otherIndex","tempTarget2","tempTargetDest2","closestDistanceOtherTriIndex","otherOffset","otherCount","distanceToTriangle","tempTargetDest1","sub","$e75123def4e47834$export$7e7412b9f4f11a5c","$e75123def4e47834$export$dddff414156655a1","$e75123def4e47834$export$dae1f8efdced590b","vi","$b8db0b19b1b63b30$export$40f4af49b81ca898","$4f4dc3384d5102e9$export$1999205ebe856279","$4f4dc3384d5102e9$var$_raycast","intersectTris_indirect","$02526e1080e4eec2$export$44e48d4cf2fe0609","$02526e1080e4eec2$var$_xyzFields","$02526e1080e4eec2$var$_raycastFirst","intersectClosestTri_indirect","$56c765f9345f8e4f$export$80dca0df80ee0084","$56c765f9345f8e4f$var$boundingBox","$56c765f9345f8e4f$var$triangle","$56c765f9345f8e4f$var$triangle2","$56c765f9345f8e4f$var$invertedMat","$56c765f9345f8e4f$var$obb","$56c765f9345f8e4f$var$obb2","$56c765f9345f8e4f$var$_intersectsGeometry","$d66bcec6ec98051a$export$334b669407b5ec06","$d66bcec6ec98051a$var$tempMatrix","$d66bcec6ec98051a$var$obb","$d66bcec6ec98051a$var$obb2","$d66bcec6ec98051a$var$temp1","$d66bcec6ec98051a$var$temp2","$d66bcec6ec98051a$var$temp3","$d66bcec6ec98051a$var$temp4","$1e0850ef1728edf3$export$9c28fa8114adc339","$1e0850ef1728edf3$export$fadff02e9aa23f60","$ac01be60b9223c52$export$a2253c6980b92559","$ac01be60b9223c52$var$_bufferStack1","$ac01be60b9223c52$var$_bufferStack2","$ac01be60b9223c52$var$_boxPool","$ac01be60b9223c52$var$_leftBox1","$ac01be60b9223c52$var$_rightBox1","$ac01be60b9223c52$var$_leftBox2","$ac01be60b9223c52$var$_rightBox2","$ac01be60b9223c52$var$_active","otherRoots","invMat","il","localBox","$ac01be60b9223c52$var$_traverse","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","node1IndexByteOffset","node2IndexByteOffset","currBox","reversed","bufferStack1","bufferStack2","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node1Index16","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects"],"version":3,"file":"asyncGenerate.77ce35af.js.map"}