{"mappings":"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","sources":["<anon>","node_modules/three/examples/jsm/geometries/RoundedBoxGeometry.js","node_modules/stats.js/build/stats.min.js","src/objects/MeshBVHHelper.js","example/characterMovement.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"apoN1\", function(module, exports) {\n\n$parcel$export(module.exports, \"RoundedBoxGeometry\", () => $793f77e8093852e4$export$418f4e74cfe71a96);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $793f77e8093852e4$var$_tempNormal = new (0, $ilwiq.Vector3)();\nfunction $793f77e8093852e4$var$getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n    const totArcLength = 2 * Math.PI * radius / 4;\n    // length of the planes between the arcs on each axis\n    const centerLength = Math.max(sideLength - 2 * radius, 0);\n    const halfArc = Math.PI / 4;\n    // Get the vector projected onto the Y plane\n    $793f77e8093852e4$var$_tempNormal.copy(normal);\n    $793f77e8093852e4$var$_tempNormal[projectionAxis] = 0;\n    $793f77e8093852e4$var$_tempNormal.normalize();\n    // total amount of UV space alloted to a single arc\n    const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength);\n    // the distance along one arc the point is at\n    const arcAngleRatio = 1.0 - $793f77e8093852e4$var$_tempNormal.angleTo(faceDirVector) / halfArc;\n    if (Math.sign($793f77e8093852e4$var$_tempNormal[uvAxis]) === 1) return arcAngleRatio * arcUvRatio;\n    else {\n        // total amount of UV space alloted to the plane between the arcs\n        const lenUv = centerLength / (totArcLength + centerLength);\n        return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\n    }\n}\nclass $793f77e8093852e4$export$418f4e74cfe71a96 extends (0, $ilwiq.BoxGeometry) {\n    constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1){\n        // ensure segments is odd so we have a plane connecting the rounded corners\n        segments = segments * 2 + 1;\n        // ensure radius isn't bigger than shortest side\n        radius = Math.min(width / 2, height / 2, depth / 2, radius);\n        super(1, 1, 1, segments, segments, segments);\n        // if we just have one segment we're the same as a regular box\n        if (segments === 1) return;\n        const geometry2 = this.toNonIndexed();\n        this.index = null;\n        this.attributes.position = geometry2.attributes.position;\n        this.attributes.normal = geometry2.attributes.normal;\n        this.attributes.uv = geometry2.attributes.uv;\n        //\n        const position = new (0, $ilwiq.Vector3)();\n        const normal = new (0, $ilwiq.Vector3)();\n        const box = new (0, $ilwiq.Vector3)(width, height, depth).divideScalar(2).subScalar(radius);\n        const positions = this.attributes.position.array;\n        const normals = this.attributes.normal.array;\n        const uvs = this.attributes.uv.array;\n        const faceTris = positions.length / 6;\n        const faceDirVector = new (0, $ilwiq.Vector3)();\n        const halfSegmentSize = 0.5 / segments;\n        for(let i = 0, j = 0; i < positions.length; i += 3, j += 2){\n            position.fromArray(positions, i);\n            normal.copy(position);\n            normal.x -= Math.sign(normal.x) * halfSegmentSize;\n            normal.y -= Math.sign(normal.y) * halfSegmentSize;\n            normal.z -= Math.sign(normal.z) * halfSegmentSize;\n            normal.normalize();\n            positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n            positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n            positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n            normals[i + 0] = normal.x;\n            normals[i + 1] = normal.y;\n            normals[i + 2] = normal.z;\n            const side = Math.floor(i / faceTris);\n            switch(side){\n                case 0:\n                    // generate UVs along Z then Y\n                    faceDirVector.set(1, 0, 0);\n                    uvs[j + 0] = $793f77e8093852e4$var$getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n                    uvs[j + 1] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n                    break;\n                case 1:\n                    // generate UVs along Z then Y\n                    faceDirVector.set(-1, 0, 0);\n                    uvs[j + 0] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n                    uvs[j + 1] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n                    break;\n                case 2:\n                    // generate UVs along X then Z\n                    faceDirVector.set(0, 1, 0);\n                    uvs[j + 0] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n                    uvs[j + 1] = $793f77e8093852e4$var$getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n                    break;\n                case 3:\n                    // generate UVs along X then Z\n                    faceDirVector.set(0, -1, 0);\n                    uvs[j + 0] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n                    uvs[j + 1] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n                    break;\n                case 4:\n                    // generate UVs along X then Y\n                    faceDirVector.set(0, 0, 1);\n                    uvs[j + 0] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n                    uvs[j + 1] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n                    break;\n                case 5:\n                    // generate UVs along X then Y\n                    faceDirVector.set(0, 0, -1);\n                    uvs[j + 0] = $793f77e8093852e4$var$getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n                    uvs[j + 1] = 1.0 - $793f77e8093852e4$var$getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n                    break;\n            }\n        }\n    }\n}\n\n});\n\nparcelRegister(\"c8CJQ\", function(module, exports) {\n// stats.js - http://github.com/mrdoob/stats.js\n(function(f, e) {\n    module.exports = e();\n})(module.exports, function() {\n    var f = function() {\n        function e(a) {\n            c.appendChild(a.dom);\n            return a;\n        }\n        function u(a) {\n            for(var d = 0; d < c.children.length; d++)c.children[d].style.display = d === a ? \"block\" : \"none\";\n            l = a;\n        }\n        var l = 0, c = document.createElement(\"div\");\n        c.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n        c.addEventListener(\"click\", function(a) {\n            a.preventDefault();\n            u(++l % c.children.length);\n        }, !1);\n        var k = (performance || Date).now(), g = k, a = 0, r = e(new f.Panel(\"FPS\", \"#0ff\", \"#002\")), h = e(new f.Panel(\"MS\", \"#0f0\", \"#020\"));\n        if (self.performance && self.performance.memory) var t = e(new f.Panel(\"MB\", \"#f08\", \"#201\"));\n        u(0);\n        return {\n            REVISION: 16,\n            dom: c,\n            addPanel: e,\n            showPanel: u,\n            begin: function() {\n                k = (performance || Date).now();\n            },\n            end: function() {\n                a++;\n                var c = (performance || Date).now();\n                h.update(c - k, 200);\n                if (c > g + 1E3 && (r.update(1E3 * a / (c - g), 100), g = c, a = 0, t)) {\n                    var d = performance.memory;\n                    t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);\n                }\n                return c;\n            },\n            update: function() {\n                k = this.end();\n            },\n            domElement: c,\n            setMode: u\n        };\n    };\n    f.Panel = function(e, f, l) {\n        var c = Infinity, k = 0, g = Math.round, a = g(window.devicePixelRatio || 1), r = 80 * a, h = 48 * a, t = 3 * a, v = 2 * a, d = 3 * a, m = 15 * a, n = 74 * a, p = 30 * a, q = document.createElement(\"canvas\");\n        q.width = r;\n        q.height = h;\n        q.style.cssText = \"width:80px;height:48px\";\n        var b = q.getContext(\"2d\");\n        b.font = \"bold \" + 9 * a + \"px Helvetica,Arial,sans-serif\";\n        b.textBaseline = \"top\";\n        b.fillStyle = l;\n        b.fillRect(0, 0, r, h);\n        b.fillStyle = f;\n        b.fillText(e, t, v);\n        b.fillRect(d, m, n, p);\n        b.fillStyle = l;\n        b.globalAlpha = .9;\n        b.fillRect(d, m, n, p);\n        return {\n            dom: q,\n            update: function(h, w) {\n                c = Math.min(c, h);\n                k = Math.max(k, h);\n                b.fillStyle = l;\n                b.globalAlpha = 1;\n                b.fillRect(0, 0, r, m);\n                b.fillStyle = f;\n                b.fillText(g(h) + \" \" + e + \" (\" + g(c) + \"-\" + g(k) + \")\", t, v);\n                b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);\n                b.fillRect(d + n - a, m, a, p);\n                b.fillStyle = l;\n                b.globalAlpha = .9;\n                b.fillRect(d + n - a, m, a, g((1 - h / w) * p));\n            }\n        };\n    };\n    return f;\n});\n\n});\n\nparcelRegister(\"5ca9G\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHHelper\", () => $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $3c85f35a8c29fa9b$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nclass $3c85f35a8c29fa9b$var$MeshBVHRootHelper extends (0, $ilwiq.Object3D) {\n    get isMesh() {\n        return !this.displayEdges;\n    }\n    get isLineSegments() {\n        return this.displayEdges;\n    }\n    get isLine() {\n        return this.displayEdges;\n    }\n    constructor(bvh, material, depth = 10, group = 0){\n        super();\n        this.material = material;\n        this.geometry = new (0, $ilwiq.BufferGeometry)();\n        this.name = \"MeshBVHRootHelper\";\n        this.depth = depth;\n        this.displayParents = false;\n        this.bvh = bvh;\n        this.displayEdges = true;\n        this._group = group;\n    }\n    raycast() {}\n    update() {\n        const geometry = this.geometry;\n        const boundsTree = this.bvh;\n        const group = this._group;\n        geometry.dispose();\n        this.visible = false;\n        if (boundsTree) {\n            // count the number of bounds required\n            const targetDepth = this.depth - 1;\n            const displayParents = this.displayParents;\n            let boundsCount = 0;\n            boundsTree.traverse((depth, isLeaf)=>{\n                if (depth >= targetDepth || isLeaf) {\n                    boundsCount++;\n                    return true;\n                } else if (displayParents) boundsCount++;\n            }, group);\n            // fill in the position buffer with the bounds corners\n            let posIndex = 0;\n            const positionArray = new Float32Array(24 * boundsCount);\n            boundsTree.traverse((depth, isLeaf, boundingData)=>{\n                const terminate = depth >= targetDepth || isLeaf;\n                if (terminate || displayParents) {\n                    (0, $aw71y.arrayToBox)(0, boundingData, $3c85f35a8c29fa9b$var$boundingBox);\n                    const { min: min, max: max } = $3c85f35a8c29fa9b$var$boundingBox;\n                    for(let x = -1; x <= 1; x += 2){\n                        const xVal = x < 0 ? min.x : max.x;\n                        for(let y = -1; y <= 1; y += 2){\n                            const yVal = y < 0 ? min.y : max.y;\n                            for(let z = -1; z <= 1; z += 2){\n                                const zVal = z < 0 ? min.z : max.z;\n                                positionArray[posIndex + 0] = xVal;\n                                positionArray[posIndex + 1] = yVal;\n                                positionArray[posIndex + 2] = zVal;\n                                posIndex += 3;\n                            }\n                        }\n                    }\n                    return terminate;\n                }\n            }, group);\n            let indexArray;\n            let indices;\n            if (this.displayEdges) // fill in the index buffer to point to the corner points\n            indices = new Uint8Array([\n                // x axis\n                0,\n                4,\n                1,\n                5,\n                2,\n                6,\n                3,\n                7,\n                // y axis\n                0,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                7,\n                // z axis\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7\n            ]);\n            else indices = new Uint8Array([\n                // X-, X+\n                0,\n                1,\n                2,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                6,\n                7,\n                5,\n                // Y-, Y+\n                1,\n                4,\n                5,\n                0,\n                4,\n                1,\n                2,\n                3,\n                6,\n                3,\n                7,\n                6,\n                // Z-, Z+\n                0,\n                2,\n                4,\n                2,\n                6,\n                4,\n                1,\n                5,\n                3,\n                3,\n                5,\n                7\n            ]);\n            if (positionArray.length > 65535) indexArray = new Uint32Array(indices.length * boundsCount);\n            else indexArray = new Uint16Array(indices.length * boundsCount);\n            const indexLength = indices.length;\n            for(let i = 0; i < boundsCount; i++){\n                const posOffset = i * 8;\n                const indexOffset = i * indexLength;\n                for(let j = 0; j < indexLength; j++)indexArray[indexOffset + j] = posOffset + indices[j];\n            }\n            // update the geometry\n            geometry.setIndex(new (0, $ilwiq.BufferAttribute)(indexArray, 1, false));\n            geometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(positionArray, 3, false));\n            this.visible = true;\n        }\n    }\n}\nclass $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 extends (0, $ilwiq.Group) {\n    get color() {\n        return this.edgeMaterial.color;\n    }\n    get opacity() {\n        return this.edgeMaterial.opacity;\n    }\n    set opacity(v) {\n        this.edgeMaterial.opacity = v;\n        this.meshMaterial.opacity = v;\n    }\n    constructor(mesh = null, bvh = null, depth = 10){\n        // handle bvh, depth signature\n        if (mesh instanceof (0, $ff8ed.MeshBVH)) {\n            depth = bvh || 10;\n            bvh = mesh;\n            mesh = null;\n        }\n        // handle mesh, depth signature\n        if (typeof bvh === \"number\") {\n            depth = bvh;\n            bvh = null;\n        }\n        super();\n        this.name = \"MeshBVHHelper\";\n        this.depth = depth;\n        this.mesh = mesh;\n        this.bvh = bvh;\n        this.displayParents = false;\n        this.displayEdges = true;\n        this._roots = [];\n        const edgeMaterial = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        const meshMaterial = new (0, $ilwiq.MeshBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        meshMaterial.color = edgeMaterial.color;\n        this.edgeMaterial = edgeMaterial;\n        this.meshMaterial = meshMaterial;\n        this.update();\n    }\n    update() {\n        const bvh = this.bvh || this.mesh.geometry.boundsTree;\n        const totalRoots = bvh ? bvh._roots.length : 0;\n        while(this._roots.length > totalRoots){\n            const root = this._roots.pop();\n            root.geometry.dispose();\n            this.remove(root);\n        }\n        for(let i = 0; i < totalRoots; i++){\n            const { depth: depth, edgeMaterial: edgeMaterial, meshMaterial: meshMaterial, displayParents: displayParents, displayEdges: displayEdges } = this;\n            if (i >= this._roots.length) {\n                const root = new $3c85f35a8c29fa9b$var$MeshBVHRootHelper(bvh, edgeMaterial, depth, i);\n                this.add(root);\n                this._roots.push(root);\n            }\n            const root = this._roots[i];\n            root.bvh = bvh;\n            root.depth = depth;\n            root.displayParents = displayParents;\n            root.displayEdges = displayEdges;\n            root.material = displayEdges ? edgeMaterial : meshMaterial;\n            root.update();\n        }\n    }\n    updateMatrixWorld(...args) {\n        const mesh = this.mesh;\n        const parent = this.parent;\n        if (mesh !== null) {\n            mesh.updateWorldMatrix(true, false);\n            if (parent) this.matrix.copy(parent.matrixWorld).invert().multiply(mesh.matrixWorld);\n            else this.matrix.copy(mesh.matrixWorld);\n            this.matrix.decompose(this.position, this.quaternion, this.scale);\n        }\n        super.updateMatrixWorld(...args);\n    }\n    copy(source) {\n        this.depth = source.depth;\n        this.mesh = source.mesh;\n        this.bvh = source.bvh;\n        this.opacity = source.opacity;\n        this.color.copy(source.color);\n    }\n    clone() {\n        return new $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5(this.mesh, this.bvh, this.depth);\n    }\n    dispose() {\n        this.edgeMaterial.dispose();\n        this.meshMaterial.dispose();\n        const children = this.children;\n        for(let i = 0, l = children.length; i < l; i++)children[i].geometry.dispose();\n    }\n}\nclass $3c85f35a8c29fa9b$export$5ead38ed5c75a1c8 extends $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 {\n    constructor(...args){\n        super(...args);\n        console.warn(\"MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.\");\n    }\n}\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $apoN1 = parcelRequire(\"apoN1\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $7ePFa = parcelRequire(\"7ePFa\");\n\nvar $c8CJQ = parcelRequire(\"c8CJQ\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nvar $5ca9G = parcelRequire(\"5ca9G\");\nvar $jAT47 = parcelRequire(\"jAT47\");\nconst $ea5bf61d4ef1142f$var$params = {\n    firstPerson: false,\n    displayCollider: false,\n    displayBVH: false,\n    visualizeDepth: 10,\n    gravity: -30,\n    playerSpeed: 10,\n    physicsSteps: 5,\n    reset: $ea5bf61d4ef1142f$var$reset\n};\nlet $ea5bf61d4ef1142f$var$renderer, $ea5bf61d4ef1142f$var$camera, $ea5bf61d4ef1142f$var$scene, $ea5bf61d4ef1142f$var$clock, $ea5bf61d4ef1142f$var$gui, $ea5bf61d4ef1142f$var$stats;\nlet $ea5bf61d4ef1142f$var$environment, $ea5bf61d4ef1142f$var$collider, $ea5bf61d4ef1142f$var$visualizer, $ea5bf61d4ef1142f$var$player, $ea5bf61d4ef1142f$var$controls;\nlet $ea5bf61d4ef1142f$var$playerIsOnGround = false;\nlet $ea5bf61d4ef1142f$var$fwdPressed = false, $ea5bf61d4ef1142f$var$bkdPressed = false, $ea5bf61d4ef1142f$var$lftPressed = false, $ea5bf61d4ef1142f$var$rgtPressed = false;\nlet $ea5bf61d4ef1142f$var$playerVelocity = new $ilwiq.Vector3();\nlet $ea5bf61d4ef1142f$var$upVector = new $ilwiq.Vector3(0, 1, 0);\nlet $ea5bf61d4ef1142f$var$tempVector = new $ilwiq.Vector3();\nlet $ea5bf61d4ef1142f$var$tempVector2 = new $ilwiq.Vector3();\nlet $ea5bf61d4ef1142f$var$tempBox = new $ilwiq.Box3();\nlet $ea5bf61d4ef1142f$var$tempMat = new $ilwiq.Matrix4();\nlet $ea5bf61d4ef1142f$var$tempSegment = new $ilwiq.Line3();\n$ea5bf61d4ef1142f$var$init();\n$ea5bf61d4ef1142f$var$render();\nfunction $ea5bf61d4ef1142f$var$init() {\n    const bgColor = 1251612;\n    // renderer setup\n    $ea5bf61d4ef1142f$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $ea5bf61d4ef1142f$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $ea5bf61d4ef1142f$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $ea5bf61d4ef1142f$var$renderer.setClearColor(bgColor, 1);\n    $ea5bf61d4ef1142f$var$renderer.shadowMap.enabled = true;\n    $ea5bf61d4ef1142f$var$renderer.shadowMap.type = $ilwiq.PCFSoftShadowMap;\n    $ea5bf61d4ef1142f$var$renderer.outputEncoding = $ilwiq.sRGBEncoding;\n    document.body.appendChild($ea5bf61d4ef1142f$var$renderer.domElement);\n    // scene setup\n    $ea5bf61d4ef1142f$var$scene = new $ilwiq.Scene();\n    $ea5bf61d4ef1142f$var$scene.fog = new $ilwiq.Fog(bgColor, 20, 70);\n    // lights\n    const light = new $ilwiq.DirectionalLight(0xffffff, 1);\n    light.position.set(1, 1.5, 1).multiplyScalar(50);\n    light.shadow.mapSize.setScalar(2048);\n    light.shadow.bias = -0.0001;\n    light.shadow.normalBias = 0.05;\n    light.castShadow = true;\n    const shadowCam = light.shadow.camera;\n    shadowCam.bottom = shadowCam.left = -30;\n    shadowCam.top = 30;\n    shadowCam.right = 45;\n    $ea5bf61d4ef1142f$var$scene.add(light);\n    $ea5bf61d4ef1142f$var$scene.add(new $ilwiq.HemisphereLight(0xffffff, 0x223344, 0.4));\n    // camera setup\n    $ea5bf61d4ef1142f$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);\n    $ea5bf61d4ef1142f$var$camera.position.set(10, 10, -10);\n    $ea5bf61d4ef1142f$var$camera.far = 100;\n    $ea5bf61d4ef1142f$var$camera.updateProjectionMatrix();\n    window.camera = $ea5bf61d4ef1142f$var$camera;\n    $ea5bf61d4ef1142f$var$clock = new $ilwiq.Clock();\n    $ea5bf61d4ef1142f$var$controls = new (0, $5Rd1x.OrbitControls)($ea5bf61d4ef1142f$var$camera, $ea5bf61d4ef1142f$var$renderer.domElement);\n    // stats setup\n    $ea5bf61d4ef1142f$var$stats = new (0, (/*@__PURE__*/$parcel$interopDefault($c8CJQ)))();\n    document.body.appendChild($ea5bf61d4ef1142f$var$stats.dom);\n    $ea5bf61d4ef1142f$var$loadColliderEnvironment();\n    // character\n    $ea5bf61d4ef1142f$var$player = new $ilwiq.Mesh(new (0, $apoN1.RoundedBoxGeometry)(1.0, 2.0, 1.0, 10, 0.5), new $ilwiq.MeshStandardMaterial());\n    $ea5bf61d4ef1142f$var$player.geometry.translate(0, -0.5, 0);\n    $ea5bf61d4ef1142f$var$player.capsuleInfo = {\n        radius: 0.5,\n        segment: new $ilwiq.Line3(new $ilwiq.Vector3(), new $ilwiq.Vector3(0, -1, 0.0))\n    };\n    $ea5bf61d4ef1142f$var$player.castShadow = true;\n    $ea5bf61d4ef1142f$var$player.receiveShadow = true;\n    $ea5bf61d4ef1142f$var$player.material.shadowSide = 2;\n    $ea5bf61d4ef1142f$var$scene.add($ea5bf61d4ef1142f$var$player);\n    $ea5bf61d4ef1142f$var$reset();\n    // dat.gui\n    $ea5bf61d4ef1142f$var$gui = new (0, $jiuw3.GUI)();\n    $ea5bf61d4ef1142f$var$gui.add($ea5bf61d4ef1142f$var$params, \"firstPerson\").onChange((v)=>{\n        if (!v) $ea5bf61d4ef1142f$var$camera.position.sub($ea5bf61d4ef1142f$var$controls.target).normalize().multiplyScalar(10).add($ea5bf61d4ef1142f$var$controls.target);\n    });\n    const visFolder = $ea5bf61d4ef1142f$var$gui.addFolder(\"Visualization\");\n    visFolder.add($ea5bf61d4ef1142f$var$params, \"displayCollider\");\n    visFolder.add($ea5bf61d4ef1142f$var$params, \"displayBVH\");\n    visFolder.add($ea5bf61d4ef1142f$var$params, \"visualizeDepth\", 1, 20, 1).onChange((v)=>{\n        $ea5bf61d4ef1142f$var$visualizer.depth = v;\n        $ea5bf61d4ef1142f$var$visualizer.update();\n    });\n    visFolder.open();\n    const physicsFolder = $ea5bf61d4ef1142f$var$gui.addFolder(\"Player\");\n    physicsFolder.add($ea5bf61d4ef1142f$var$params, \"physicsSteps\", 0, 30, 1);\n    physicsFolder.add($ea5bf61d4ef1142f$var$params, \"gravity\", -100, 100, 0.01).onChange((v)=>{\n        $ea5bf61d4ef1142f$var$params.gravity = parseFloat(v);\n    });\n    physicsFolder.add($ea5bf61d4ef1142f$var$params, \"playerSpeed\", 1, 20);\n    physicsFolder.open();\n    $ea5bf61d4ef1142f$var$gui.add($ea5bf61d4ef1142f$var$params, \"reset\");\n    $ea5bf61d4ef1142f$var$gui.open();\n    window.addEventListener(\"resize\", function() {\n        $ea5bf61d4ef1142f$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $ea5bf61d4ef1142f$var$camera.updateProjectionMatrix();\n        $ea5bf61d4ef1142f$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    }, false);\n    window.addEventListener(\"keydown\", function(e) {\n        switch(e.code){\n            case \"KeyW\":\n                $ea5bf61d4ef1142f$var$fwdPressed = true;\n                break;\n            case \"KeyS\":\n                $ea5bf61d4ef1142f$var$bkdPressed = true;\n                break;\n            case \"KeyD\":\n                $ea5bf61d4ef1142f$var$rgtPressed = true;\n                break;\n            case \"KeyA\":\n                $ea5bf61d4ef1142f$var$lftPressed = true;\n                break;\n            case \"Space\":\n                if ($ea5bf61d4ef1142f$var$playerIsOnGround) {\n                    $ea5bf61d4ef1142f$var$playerVelocity.y = 10.0;\n                    $ea5bf61d4ef1142f$var$playerIsOnGround = false;\n                }\n                break;\n        }\n    });\n    window.addEventListener(\"keyup\", function(e) {\n        switch(e.code){\n            case \"KeyW\":\n                $ea5bf61d4ef1142f$var$fwdPressed = false;\n                break;\n            case \"KeyS\":\n                $ea5bf61d4ef1142f$var$bkdPressed = false;\n                break;\n            case \"KeyD\":\n                $ea5bf61d4ef1142f$var$rgtPressed = false;\n                break;\n            case \"KeyA\":\n                $ea5bf61d4ef1142f$var$lftPressed = false;\n                break;\n        }\n    });\n}\nfunction $ea5bf61d4ef1142f$var$loadColliderEnvironment() {\n    new (0, $7lx9d.GLTFLoader)().load(\"../models/dungeon_low_poly_game_level_challenge/scene.gltf\", (res)=>{\n        const gltfScene = res.scene;\n        gltfScene.scale.setScalar(.01);\n        const box = new $ilwiq.Box3();\n        box.setFromObject(gltfScene);\n        box.getCenter(gltfScene.position).negate();\n        gltfScene.updateMatrixWorld(true);\n        // visual geometry setup\n        const toMerge = {};\n        gltfScene.traverse((c)=>{\n            if (/Boss/.test(c.name) || /Enemie/.test(c.name) || /Shield/.test(c.name) || /Sword/.test(c.name) || /Character/.test(c.name) || /Gate/.test(c.name) || // spears\n            /Cube/.test(c.name) || // pink brick\n            c.material && c.material.color.r === 1.0) return;\n            if (c.isMesh) {\n                const hex = c.material.color.getHex();\n                toMerge[hex] = toMerge[hex] || [];\n                toMerge[hex].push(c);\n            }\n        });\n        $ea5bf61d4ef1142f$var$environment = new $ilwiq.Group();\n        for(const hex in toMerge){\n            const arr = toMerge[hex];\n            const visualGeometries = [];\n            arr.forEach((mesh)=>{\n                if (mesh.material.emissive.r !== 0) $ea5bf61d4ef1142f$var$environment.attach(mesh);\n                else {\n                    const geom = mesh.geometry.clone();\n                    geom.applyMatrix4(mesh.matrixWorld);\n                    visualGeometries.push(geom);\n                }\n            });\n            if (visualGeometries.length) {\n                const newGeom = $7ePFa.mergeBufferGeometries(visualGeometries);\n                const newMesh = new $ilwiq.Mesh(newGeom, new $ilwiq.MeshStandardMaterial({\n                    color: parseInt(hex),\n                    shadowSide: 2\n                }));\n                newMesh.castShadow = true;\n                newMesh.receiveShadow = true;\n                newMesh.material.shadowSide = 2;\n                $ea5bf61d4ef1142f$var$environment.add(newMesh);\n            }\n        }\n        const staticGenerator = new (0, $jAT47.StaticGeometryGenerator)($ea5bf61d4ef1142f$var$environment);\n        staticGenerator.attributes = [\n            \"position\"\n        ];\n        const mergedGeometry = staticGenerator.generate();\n        mergedGeometry.boundsTree = new (0, $ff8ed.MeshBVH)(mergedGeometry);\n        $ea5bf61d4ef1142f$var$collider = new $ilwiq.Mesh(mergedGeometry);\n        $ea5bf61d4ef1142f$var$collider.material.wireframe = true;\n        $ea5bf61d4ef1142f$var$collider.material.opacity = 0.5;\n        $ea5bf61d4ef1142f$var$collider.material.transparent = true;\n        $ea5bf61d4ef1142f$var$visualizer = new (0, $5ca9G.MeshBVHHelper)($ea5bf61d4ef1142f$var$collider, $ea5bf61d4ef1142f$var$params.visualizeDepth);\n        $ea5bf61d4ef1142f$var$scene.add($ea5bf61d4ef1142f$var$visualizer);\n        $ea5bf61d4ef1142f$var$scene.add($ea5bf61d4ef1142f$var$collider);\n        $ea5bf61d4ef1142f$var$scene.add($ea5bf61d4ef1142f$var$environment);\n    });\n}\nfunction $ea5bf61d4ef1142f$var$reset() {\n    $ea5bf61d4ef1142f$var$playerVelocity.set(0, 0, 0);\n    $ea5bf61d4ef1142f$var$player.position.set(15.75, -3, 30);\n    $ea5bf61d4ef1142f$var$camera.position.sub($ea5bf61d4ef1142f$var$controls.target);\n    $ea5bf61d4ef1142f$var$controls.target.copy($ea5bf61d4ef1142f$var$player.position);\n    $ea5bf61d4ef1142f$var$camera.position.add($ea5bf61d4ef1142f$var$player.position);\n    $ea5bf61d4ef1142f$var$controls.update();\n}\nfunction $ea5bf61d4ef1142f$var$updatePlayer(delta) {\n    if ($ea5bf61d4ef1142f$var$playerIsOnGround) $ea5bf61d4ef1142f$var$playerVelocity.y = delta * $ea5bf61d4ef1142f$var$params.gravity;\n    else $ea5bf61d4ef1142f$var$playerVelocity.y += delta * $ea5bf61d4ef1142f$var$params.gravity;\n    $ea5bf61d4ef1142f$var$player.position.addScaledVector($ea5bf61d4ef1142f$var$playerVelocity, delta);\n    // move the player\n    const angle = $ea5bf61d4ef1142f$var$controls.getAzimuthalAngle();\n    if ($ea5bf61d4ef1142f$var$fwdPressed) {\n        $ea5bf61d4ef1142f$var$tempVector.set(0, 0, -1).applyAxisAngle($ea5bf61d4ef1142f$var$upVector, angle);\n        $ea5bf61d4ef1142f$var$player.position.addScaledVector($ea5bf61d4ef1142f$var$tempVector, $ea5bf61d4ef1142f$var$params.playerSpeed * delta);\n    }\n    if ($ea5bf61d4ef1142f$var$bkdPressed) {\n        $ea5bf61d4ef1142f$var$tempVector.set(0, 0, 1).applyAxisAngle($ea5bf61d4ef1142f$var$upVector, angle);\n        $ea5bf61d4ef1142f$var$player.position.addScaledVector($ea5bf61d4ef1142f$var$tempVector, $ea5bf61d4ef1142f$var$params.playerSpeed * delta);\n    }\n    if ($ea5bf61d4ef1142f$var$lftPressed) {\n        $ea5bf61d4ef1142f$var$tempVector.set(-1, 0, 0).applyAxisAngle($ea5bf61d4ef1142f$var$upVector, angle);\n        $ea5bf61d4ef1142f$var$player.position.addScaledVector($ea5bf61d4ef1142f$var$tempVector, $ea5bf61d4ef1142f$var$params.playerSpeed * delta);\n    }\n    if ($ea5bf61d4ef1142f$var$rgtPressed) {\n        $ea5bf61d4ef1142f$var$tempVector.set(1, 0, 0).applyAxisAngle($ea5bf61d4ef1142f$var$upVector, angle);\n        $ea5bf61d4ef1142f$var$player.position.addScaledVector($ea5bf61d4ef1142f$var$tempVector, $ea5bf61d4ef1142f$var$params.playerSpeed * delta);\n    }\n    $ea5bf61d4ef1142f$var$player.updateMatrixWorld();\n    // adjust player position based on collisions\n    const capsuleInfo = $ea5bf61d4ef1142f$var$player.capsuleInfo;\n    $ea5bf61d4ef1142f$var$tempBox.makeEmpty();\n    $ea5bf61d4ef1142f$var$tempMat.copy($ea5bf61d4ef1142f$var$collider.matrixWorld).invert();\n    $ea5bf61d4ef1142f$var$tempSegment.copy(capsuleInfo.segment);\n    // get the position of the capsule in the local space of the collider\n    $ea5bf61d4ef1142f$var$tempSegment.start.applyMatrix4($ea5bf61d4ef1142f$var$player.matrixWorld).applyMatrix4($ea5bf61d4ef1142f$var$tempMat);\n    $ea5bf61d4ef1142f$var$tempSegment.end.applyMatrix4($ea5bf61d4ef1142f$var$player.matrixWorld).applyMatrix4($ea5bf61d4ef1142f$var$tempMat);\n    // get the axis aligned bounding box of the capsule\n    $ea5bf61d4ef1142f$var$tempBox.expandByPoint($ea5bf61d4ef1142f$var$tempSegment.start);\n    $ea5bf61d4ef1142f$var$tempBox.expandByPoint($ea5bf61d4ef1142f$var$tempSegment.end);\n    $ea5bf61d4ef1142f$var$tempBox.min.addScalar(-capsuleInfo.radius);\n    $ea5bf61d4ef1142f$var$tempBox.max.addScalar(capsuleInfo.radius);\n    $ea5bf61d4ef1142f$var$collider.geometry.boundsTree.shapecast({\n        intersectsBounds: (box)=>box.intersectsBox($ea5bf61d4ef1142f$var$tempBox),\n        intersectsTriangle: (tri)=>{\n            // check if the triangle is intersecting the capsule and adjust the\n            // capsule position if it is.\n            const triPoint = $ea5bf61d4ef1142f$var$tempVector;\n            const capsulePoint = $ea5bf61d4ef1142f$var$tempVector2;\n            const distance = tri.closestPointToSegment($ea5bf61d4ef1142f$var$tempSegment, triPoint, capsulePoint);\n            if (distance < capsuleInfo.radius) {\n                const depth = capsuleInfo.radius - distance;\n                const direction = capsulePoint.sub(triPoint).normalize();\n                $ea5bf61d4ef1142f$var$tempSegment.start.addScaledVector(direction, depth);\n                $ea5bf61d4ef1142f$var$tempSegment.end.addScaledVector(direction, depth);\n            }\n        }\n    });\n    // get the adjusted position of the capsule collider in world space after checking\n    // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be\n    // the origin of the player model.\n    const newPosition = $ea5bf61d4ef1142f$var$tempVector;\n    newPosition.copy($ea5bf61d4ef1142f$var$tempSegment.start).applyMatrix4($ea5bf61d4ef1142f$var$collider.matrixWorld);\n    // check how much the collider was moved\n    const deltaVector = $ea5bf61d4ef1142f$var$tempVector2;\n    deltaVector.subVectors(newPosition, $ea5bf61d4ef1142f$var$player.position);\n    // if the player was primarily adjusted vertically we assume it's on something we should consider ground\n    $ea5bf61d4ef1142f$var$playerIsOnGround = deltaVector.y > Math.abs(delta * $ea5bf61d4ef1142f$var$playerVelocity.y * 0.25);\n    const offset = Math.max(0.0, deltaVector.length() - 1e-5);\n    deltaVector.normalize().multiplyScalar(offset);\n    // adjust the player model\n    $ea5bf61d4ef1142f$var$player.position.add(deltaVector);\n    if (!$ea5bf61d4ef1142f$var$playerIsOnGround) {\n        deltaVector.normalize();\n        $ea5bf61d4ef1142f$var$playerVelocity.addScaledVector(deltaVector, -deltaVector.dot($ea5bf61d4ef1142f$var$playerVelocity));\n    } else $ea5bf61d4ef1142f$var$playerVelocity.set(0, 0, 0);\n    // adjust the camera\n    $ea5bf61d4ef1142f$var$camera.position.sub($ea5bf61d4ef1142f$var$controls.target);\n    $ea5bf61d4ef1142f$var$controls.target.copy($ea5bf61d4ef1142f$var$player.position);\n    $ea5bf61d4ef1142f$var$camera.position.add($ea5bf61d4ef1142f$var$player.position);\n    // if the player has fallen too far below the level reset their position to the start\n    if ($ea5bf61d4ef1142f$var$player.position.y < -25) $ea5bf61d4ef1142f$var$reset();\n}\nfunction $ea5bf61d4ef1142f$var$render() {\n    $ea5bf61d4ef1142f$var$stats.update();\n    requestAnimationFrame($ea5bf61d4ef1142f$var$render);\n    const delta = Math.min($ea5bf61d4ef1142f$var$clock.getDelta(), 0.1);\n    if ($ea5bf61d4ef1142f$var$params.firstPerson) {\n        $ea5bf61d4ef1142f$var$controls.maxPolarAngle = Math.PI;\n        $ea5bf61d4ef1142f$var$controls.minDistance = 1e-4;\n        $ea5bf61d4ef1142f$var$controls.maxDistance = 1e-4;\n    } else {\n        $ea5bf61d4ef1142f$var$controls.maxPolarAngle = Math.PI / 2;\n        $ea5bf61d4ef1142f$var$controls.minDistance = 1;\n        $ea5bf61d4ef1142f$var$controls.maxDistance = 20;\n    }\n    if ($ea5bf61d4ef1142f$var$collider) {\n        $ea5bf61d4ef1142f$var$collider.visible = $ea5bf61d4ef1142f$var$params.displayCollider;\n        $ea5bf61d4ef1142f$var$visualizer.visible = $ea5bf61d4ef1142f$var$params.displayBVH;\n        const physicsSteps = $ea5bf61d4ef1142f$var$params.physicsSteps;\n        for(let i = 0; i < physicsSteps; i++)$ea5bf61d4ef1142f$var$updatePlayer(delta / physicsSteps);\n    }\n    // TODO: limit the camera movement based on the collider\n    // raycast in direction of camera and move it if it's further than the closest point\n    $ea5bf61d4ef1142f$var$controls.update();\n    $ea5bf61d4ef1142f$var$renderer.render($ea5bf61d4ef1142f$var$scene, $ea5bf61d4ef1142f$var$camera);\n}\n\n\n//# sourceMappingURL=characterMovement.65b34017.js.map\n","import {\n\tBoxGeometry,\n\tVector3\n} from 'three';\n\nconst _tempNormal = new Vector3();\n\nfunction getUv( faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength ) {\n\n\tconst totArcLength = 2 * Math.PI * radius / 4;\n\n\t// length of the planes between the arcs on each axis\n\tconst centerLength = Math.max( sideLength - 2 * radius, 0 );\n\tconst halfArc = Math.PI / 4;\n\n\t// Get the vector projected onto the Y plane\n\t_tempNormal.copy( normal );\n\t_tempNormal[ projectionAxis ] = 0;\n\t_tempNormal.normalize();\n\n\t// total amount of UV space alloted to a single arc\n\tconst arcUvRatio = 0.5 * totArcLength / ( totArcLength + centerLength );\n\n\t// the distance along one arc the point is at\n\tconst arcAngleRatio = 1.0 - ( _tempNormal.angleTo( faceDirVector ) / halfArc );\n\n\tif ( Math.sign( _tempNormal[ uvAxis ] ) === 1 ) {\n\n\t\treturn arcAngleRatio * arcUvRatio;\n\n\t} else {\n\n\t\t// total amount of UV space alloted to the plane between the arcs\n\t\tconst lenUv = centerLength / ( totArcLength + centerLength );\n\t\treturn lenUv + arcUvRatio + arcUvRatio * ( 1.0 - arcAngleRatio );\n\n\t}\n\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, segments = 2, radius = 0.1 ) {\n\n\t\t// ensure segments is odd so we have a plane connecting the rounded corners\n\t\tsegments = segments * 2 + 1;\n\n\t\t// ensure radius isn't bigger than shortest side\n\t\tradius = Math.min( width / 2, height / 2, depth / 2, radius );\n\n\t\tsuper( 1, 1, 1, segments, segments, segments );\n\n\t\t// if we just have one segment we're the same as a regular box\n\t\tif ( segments === 1 ) return;\n\n\t\tconst geometry2 = this.toNonIndexed();\n\n\t\tthis.index = null;\n\t\tthis.attributes.position = geometry2.attributes.position;\n\t\tthis.attributes.normal = geometry2.attributes.normal;\n\t\tthis.attributes.uv = geometry2.attributes.uv;\n\n\t\t//\n\n\t\tconst position = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst box = new Vector3( width, height, depth ).divideScalar( 2 ).subScalar( radius );\n\n\t\tconst positions = this.attributes.position.array;\n\t\tconst normals = this.attributes.normal.array;\n\t\tconst uvs = this.attributes.uv.array;\n\n\t\tconst faceTris = positions.length / 6;\n\t\tconst faceDirVector = new Vector3();\n\t\tconst halfSegmentSize = 0.5 / segments;\n\n\t\tfor ( let i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tposition.fromArray( positions, i );\n\t\t\tnormal.copy( position );\n\t\t\tnormal.x -= Math.sign( normal.x ) * halfSegmentSize;\n\t\t\tnormal.y -= Math.sign( normal.y ) * halfSegmentSize;\n\t\t\tnormal.z -= Math.sign( normal.z ) * halfSegmentSize;\n\t\t\tnormal.normalize();\n\n\t\t\tpositions[ i + 0 ] = box.x * Math.sign( position.x ) + normal.x * radius;\n\t\t\tpositions[ i + 1 ] = box.y * Math.sign( position.y ) + normal.y * radius;\n\t\t\tpositions[ i + 2 ] = box.z * Math.sign( position.z ) + normal.z * radius;\n\n\t\t\tnormals[ i + 0 ] = normal.x;\n\t\t\tnormals[ i + 1 ] = normal.y;\n\t\t\tnormals[ i + 2 ] = normal.z;\n\n\t\t\tconst side = Math.floor( i / faceTris );\n\n\t\t\tswitch ( side ) {\n\n\t\t\t\tcase 0: // right\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // left\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( - 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // top\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // bottom\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, - 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4: // front\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, 1 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5: // back\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, - 1 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { RoundedBoxGeometry };\n","// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.bvh || this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n","import * as THREE from 'three';\nimport { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport Stats from 'stats.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { MeshBVH, MeshBVHHelper, StaticGeometryGenerator } from '..';\n\nconst params = {\n\n\tfirstPerson: false,\n\n\tdisplayCollider: false,\n\tdisplayBVH: false,\n\tvisualizeDepth: 10,\n\tgravity: - 30,\n\tplayerSpeed: 10,\n\tphysicsSteps: 5,\n\n\treset: reset,\n\n};\n\nlet renderer, camera, scene, clock, gui, stats;\nlet environment, collider, visualizer, player, controls;\nlet playerIsOnGround = false;\nlet fwdPressed = false, bkdPressed = false, lftPressed = false, rgtPressed = false;\nlet playerVelocity = new THREE.Vector3();\nlet upVector = new THREE.Vector3( 0, 1, 0 );\nlet tempVector = new THREE.Vector3();\nlet tempVector2 = new THREE.Vector3();\nlet tempBox = new THREE.Box3();\nlet tempMat = new THREE.Matrix4();\nlet tempSegment = new THREE.Line3();\n\ninit();\nrender();\n\nfunction init() {\n\n\tconst bgColor = 0x263238 / 2;\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.shadowMap.enabled = true;\n\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\tscene.fog = new THREE.Fog( bgColor, 20, 70 );\n\n\t// lights\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.position.set( 1, 1.5, 1 ).multiplyScalar( 50 );\n\tlight.shadow.mapSize.setScalar( 2048 );\n\tlight.shadow.bias = - 1e-4;\n\tlight.shadow.normalBias = 0.05;\n\tlight.castShadow = true;\n\n\tconst shadowCam = light.shadow.camera;\n\tshadowCam.bottom = shadowCam.left = - 30;\n\tshadowCam.top = 30;\n\tshadowCam.right = 45;\n\n\tscene.add( light );\n\tscene.add( new THREE.HemisphereLight( 0xffffff, 0x223344, 0.4 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 10, 10, - 10 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\twindow.camera = camera;\n\n\tclock = new THREE.Clock();\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\tloadColliderEnvironment();\n\n\t// character\n\tplayer = new THREE.Mesh(\n\t\tnew RoundedBoxGeometry( 1.0, 2.0, 1.0, 10, 0.5 ),\n\t\tnew THREE.MeshStandardMaterial()\n\t);\n\tplayer.geometry.translate( 0, - 0.5, 0 );\n\tplayer.capsuleInfo = {\n\t\tradius: 0.5,\n\t\tsegment: new THREE.Line3( new THREE.Vector3(), new THREE.Vector3( 0, - 1.0, 0.0 ) )\n\t};\n\tplayer.castShadow = true;\n\tplayer.receiveShadow = true;\n\tplayer.material.shadowSide = 2;\n\tscene.add( player );\n\treset();\n\n\t// dat.gui\n\tgui = new GUI();\n\tgui.add( params, 'firstPerson' ).onChange( v => {\n\n\t\tif ( ! v ) {\n\n\t\t\tcamera\n\t\t\t\t.position\n\t\t\t\t.sub( controls.target )\n\t\t\t\t.normalize()\n\t\t\t\t.multiplyScalar( 10 )\n\t\t\t\t.add( controls.target );\n\n\t\t}\n\n\t} );\n\n\tconst visFolder = gui.addFolder( 'Visualization' );\n\tvisFolder.add( params, 'displayCollider' );\n\tvisFolder.add( params, 'displayBVH' );\n\tvisFolder.add( params, 'visualizeDepth', 1, 20, 1 ).onChange( v => {\n\n\t\tvisualizer.depth = v;\n\t\tvisualizer.update();\n\n\t} );\n\tvisFolder.open();\n\n\tconst physicsFolder = gui.addFolder( 'Player' );\n\tphysicsFolder.add( params, 'physicsSteps', 0, 30, 1 );\n\tphysicsFolder.add( params, 'gravity', - 100, 100, 0.01 ).onChange( v => {\n\n\t\tparams.gravity = parseFloat( v );\n\n\t} );\n\tphysicsFolder.add( params, 'playerSpeed', 1, 20 );\n\tphysicsFolder.open();\n\n\tgui.add( params, 'reset' );\n\tgui.open();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n\twindow.addEventListener( 'keydown', function ( e ) {\n\n\t\tswitch ( e.code ) {\n\n\t\t\tcase 'KeyW': fwdPressed = true; break;\n\t\t\tcase 'KeyS': bkdPressed = true; break;\n\t\t\tcase 'KeyD': rgtPressed = true; break;\n\t\t\tcase 'KeyA': lftPressed = true; break;\n\t\t\tcase 'Space':\n\t\t\t\tif ( playerIsOnGround ) {\n\n\t\t\t\t\tplayerVelocity.y = 10.0;\n\t\t\t\t\tplayerIsOnGround = false;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} );\n\n\twindow.addEventListener( 'keyup', function ( e ) {\n\n\t\tswitch ( e.code ) {\n\n\t\t\tcase 'KeyW': fwdPressed = false; break;\n\t\t\tcase 'KeyS': bkdPressed = false; break;\n\t\t\tcase 'KeyD': rgtPressed = false; break;\n\t\t\tcase 'KeyA': lftPressed = false; break;\n\n\t\t}\n\n\t} );\n\n}\n\nfunction loadColliderEnvironment() {\n\n\tnew GLTFLoader()\n\t\t.load( '../models/dungeon_low_poly_game_level_challenge/scene.gltf', res => {\n\n\t\t\tconst gltfScene = res.scene;\n\t\t\tgltfScene.scale.setScalar( .01 );\n\n\t\t\tconst box = new THREE.Box3();\n\t\t\tbox.setFromObject( gltfScene );\n\t\t\tbox.getCenter( gltfScene.position ).negate();\n\t\t\tgltfScene.updateMatrixWorld( true );\n\n\t\t\t// visual geometry setup\n\t\t\tconst toMerge = {};\n\t\t\tgltfScene.traverse( c => {\n\n\t\t\t\tif (\n\t\t\t\t\t/Boss/.test( c.name ) ||\n\t\t\t\t/Enemie/.test( c.name ) ||\n\t\t\t\t/Shield/.test( c.name ) ||\n\t\t\t\t/Sword/.test( c.name ) ||\n\t\t\t\t/Character/.test( c.name ) ||\n\t\t\t\t/Gate/.test( c.name ) ||\n\n\t\t\t\t// spears\n\t\t\t\t/Cube/.test( c.name ) ||\n\n\t\t\t\t// pink brick\n\t\t\t\tc.material && c.material.color.r === 1.0\n\t\t\t\t) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst hex = c.material.color.getHex();\n\t\t\t\t\ttoMerge[ hex ] = toMerge[ hex ] || [];\n\t\t\t\t\ttoMerge[ hex ].push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tenvironment = new THREE.Group();\n\t\t\tfor ( const hex in toMerge ) {\n\n\t\t\t\tconst arr = toMerge[ hex ];\n\t\t\t\tconst visualGeometries = [];\n\t\t\t\tarr.forEach( mesh => {\n\n\t\t\t\t\tif ( mesh.material.emissive.r !== 0 ) {\n\n\t\t\t\t\t\tenvironment.attach( mesh );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst geom = mesh.geometry.clone();\n\t\t\t\t\t\tgeom.applyMatrix4( mesh.matrixWorld );\n\t\t\t\t\t\tvisualGeometries.push( geom );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( visualGeometries.length ) {\n\n\t\t\t\t\tconst newGeom = BufferGeometryUtils.mergeBufferGeometries( visualGeometries );\n\t\t\t\t\tconst newMesh = new THREE.Mesh( newGeom, new THREE.MeshStandardMaterial( { color: parseInt( hex ), shadowSide: 2 } ) );\n\t\t\t\t\tnewMesh.castShadow = true;\n\t\t\t\t\tnewMesh.receiveShadow = true;\n\t\t\t\t\tnewMesh.material.shadowSide = 2;\n\n\t\t\t\t\tenvironment.add( newMesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst staticGenerator = new StaticGeometryGenerator( environment );\n\t\t\tstaticGenerator.attributes = [ 'position' ];\n\n\t\t\tconst mergedGeometry = staticGenerator.generate();\n\t\t\tmergedGeometry.boundsTree = new MeshBVH( mergedGeometry );\n\n\t\t\tcollider = new THREE.Mesh( mergedGeometry );\n\t\t\tcollider.material.wireframe = true;\n\t\t\tcollider.material.opacity = 0.5;\n\t\t\tcollider.material.transparent = true;\n\n\t\t\tvisualizer = new MeshBVHHelper( collider, params.visualizeDepth );\n\t\t\tscene.add( visualizer );\n\t\t\tscene.add( collider );\n\t\t\tscene.add( environment );\n\n\t\t} );\n\n}\n\nfunction reset() {\n\n\tplayerVelocity.set( 0, 0, 0 );\n\tplayer.position.set( 15.75, - 3, 30 );\n\tcamera.position.sub( controls.target );\n\tcontrols.target.copy( player.position );\n\tcamera.position.add( player.position );\n\tcontrols.update();\n\n}\n\nfunction updatePlayer( delta ) {\n\n\tif ( playerIsOnGround ) {\n\n\t\tplayerVelocity.y = delta * params.gravity;\n\n\t} else {\n\n\t\tplayerVelocity.y += delta * params.gravity;\n\n\t}\n\n\tplayer.position.addScaledVector( playerVelocity, delta );\n\n\t// move the player\n\tconst angle = controls.getAzimuthalAngle();\n\tif ( fwdPressed ) {\n\n\t\ttempVector.set( 0, 0, - 1 ).applyAxisAngle( upVector, angle );\n\t\tplayer.position.addScaledVector( tempVector, params.playerSpeed * delta );\n\n\t}\n\n\tif ( bkdPressed ) {\n\n\t\ttempVector.set( 0, 0, 1 ).applyAxisAngle( upVector, angle );\n\t\tplayer.position.addScaledVector( tempVector, params.playerSpeed * delta );\n\n\t}\n\n\tif ( lftPressed ) {\n\n\t\ttempVector.set( - 1, 0, 0 ).applyAxisAngle( upVector, angle );\n\t\tplayer.position.addScaledVector( tempVector, params.playerSpeed * delta );\n\n\t}\n\n\tif ( rgtPressed ) {\n\n\t\ttempVector.set( 1, 0, 0 ).applyAxisAngle( upVector, angle );\n\t\tplayer.position.addScaledVector( tempVector, params.playerSpeed * delta );\n\n\t}\n\n\tplayer.updateMatrixWorld();\n\n\t// adjust player position based on collisions\n\tconst capsuleInfo = player.capsuleInfo;\n\ttempBox.makeEmpty();\n\ttempMat.copy( collider.matrixWorld ).invert();\n\ttempSegment.copy( capsuleInfo.segment );\n\n\t// get the position of the capsule in the local space of the collider\n\ttempSegment.start.applyMatrix4( player.matrixWorld ).applyMatrix4( tempMat );\n\ttempSegment.end.applyMatrix4( player.matrixWorld ).applyMatrix4( tempMat );\n\n\t// get the axis aligned bounding box of the capsule\n\ttempBox.expandByPoint( tempSegment.start );\n\ttempBox.expandByPoint( tempSegment.end );\n\n\ttempBox.min.addScalar( - capsuleInfo.radius );\n\ttempBox.max.addScalar( capsuleInfo.radius );\n\n\tcollider.geometry.boundsTree.shapecast( {\n\n\t\tintersectsBounds: box => box.intersectsBox( tempBox ),\n\n\t\tintersectsTriangle: tri => {\n\n\t\t\t// check if the triangle is intersecting the capsule and adjust the\n\t\t\t// capsule position if it is.\n\t\t\tconst triPoint = tempVector;\n\t\t\tconst capsulePoint = tempVector2;\n\n\t\t\tconst distance = tri.closestPointToSegment( tempSegment, triPoint, capsulePoint );\n\t\t\tif ( distance < capsuleInfo.radius ) {\n\n\t\t\t\tconst depth = capsuleInfo.radius - distance;\n\t\t\t\tconst direction = capsulePoint.sub( triPoint ).normalize();\n\n\t\t\t\ttempSegment.start.addScaledVector( direction, depth );\n\t\t\t\ttempSegment.end.addScaledVector( direction, depth );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// get the adjusted position of the capsule collider in world space after checking\n\t// triangle collisions and moving it. capsuleInfo.segment.start is assumed to be\n\t// the origin of the player model.\n\tconst newPosition = tempVector;\n\tnewPosition.copy( tempSegment.start ).applyMatrix4( collider.matrixWorld );\n\n\t// check how much the collider was moved\n\tconst deltaVector = tempVector2;\n\tdeltaVector.subVectors( newPosition, player.position );\n\n\t// if the player was primarily adjusted vertically we assume it's on something we should consider ground\n\tplayerIsOnGround = deltaVector.y > Math.abs( delta * playerVelocity.y * 0.25 );\n\n\tconst offset = Math.max( 0.0, deltaVector.length() - 1e-5 );\n\tdeltaVector.normalize().multiplyScalar( offset );\n\n\t// adjust the player model\n\tplayer.position.add( deltaVector );\n\n\tif ( ! playerIsOnGround ) {\n\n\t\tdeltaVector.normalize();\n\t\tplayerVelocity.addScaledVector( deltaVector, - deltaVector.dot( playerVelocity ) );\n\n\t} else {\n\n\t\tplayerVelocity.set( 0, 0, 0 );\n\n\t}\n\n\t// adjust the camera\n\tcamera.position.sub( controls.target );\n\tcontrols.target.copy( player.position );\n\tcamera.position.add( player.position );\n\n\t// if the player has fallen too far below the level reset their position to the start\n\tif ( player.position.y < - 25 ) {\n\n\t\treset();\n\n\t}\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tconst delta = Math.min( clock.getDelta(), 0.1 );\n\tif ( params.firstPerson ) {\n\n\t\tcontrols.maxPolarAngle = Math.PI;\n\t\tcontrols.minDistance = 1e-4;\n\t\tcontrols.maxDistance = 1e-4;\n\n\t} else {\n\n\t\tcontrols.maxPolarAngle = Math.PI / 2;\n\t\tcontrols.minDistance = 1;\n\t\tcontrols.maxDistance = 20;\n\n\t}\n\n\tif ( collider ) {\n\n\t\tcollider.visible = params.displayCollider;\n\t\tvisualizer.visible = params.displayBVH;\n\n\t\tconst physicsSteps = params.physicsSteps;\n\n\t\tfor ( let i = 0; i < physicsSteps; i ++ ) {\n\n\t\t\tupdatePlayer( delta / physicsSteps );\n\n\t\t}\n\n\t}\n\n\t// TODO: limit the camera movement based on the collider\n\t// raycast in direction of camera and move it if it's further than the closest point\n\n\tcontrols.update();\n\n\trenderer.render( scene, camera );\n\n}\n"],"names":["$ea5bf61d4ef1142f$var$renderer","$ea5bf61d4ef1142f$var$camera","$ea5bf61d4ef1142f$var$scene","$ea5bf61d4ef1142f$var$clock","$ea5bf61d4ef1142f$var$gui","$ea5bf61d4ef1142f$var$stats","$ea5bf61d4ef1142f$var$environment","$ea5bf61d4ef1142f$var$collider","$ea5bf61d4ef1142f$var$visualizer","$ea5bf61d4ef1142f$var$player","$ea5bf61d4ef1142f$var$controls","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$793f77e8093852e4$export$418f4e74cfe71a96","$ilwiq","$793f77e8093852e4$var$_tempNormal","Vector3","$793f77e8093852e4$var$getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","copy","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","lenUv","BoxGeometry","constructor","width","height","depth","segments","min","geometry2","toNonIndexed","index","attributes","position","uv","box","divideScalar","subScalar","positions","array","normals","uvs","faceTris","length","halfSegmentSize","i","j","fromArray","x","y","z","floor","f","a","c","appendChild","dom","u","d","children","style","display","l","document","createElement","cssText","addEventListener","preventDefault","k","performance","Date","now","g","r","Panel","h","self","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","Infinity","round","window","devicePixelRatio","m","p","q","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","w","drawImage","$3c85f35a8c29fa9b$export$e57d74bcb7e3bec5","$aw71y","$ff8ed","$3c85f35a8c29fa9b$var$boundingBox","Box3","$3c85f35a8c29fa9b$var$MeshBVHRootHelper","Object3D","isMesh","displayEdges","isLineSegments","isLine","bvh","material","group","geometry","BufferGeometry","name","displayParents","_group","raycast","boundsTree","dispose","visible","indexArray","indices","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","arrayToBox","xVal","yVal","zVal","Uint8Array","Uint32Array","Uint16Array","indexLength","posOffset","indexOffset","setIndex","BufferAttribute","setAttribute","Group","color","edgeMaterial","opacity","meshMaterial","mesh","MeshBVH","_roots","LineBasicMaterial","transparent","depthWrite","MeshBasicMaterial","totalRoots","root","pop","remove","add","push","updateMatrixWorld","args","parent","updateWorldMatrix","matrix","matrixWorld","invert","multiply","decompose","quaternion","scale","source","clone","$apoN1","$7lx9d","$5Rd1x","$7ePFa","$c8CJQ","$jiuw3","$5ca9G","$jAT47","$ea5bf61d4ef1142f$var$params","firstPerson","displayCollider","displayBVH","visualizeDepth","gravity","playerSpeed","physicsSteps","reset","$ea5bf61d4ef1142f$var$reset","$ea5bf61d4ef1142f$var$playerIsOnGround","$ea5bf61d4ef1142f$var$fwdPressed","$ea5bf61d4ef1142f$var$bkdPressed","$ea5bf61d4ef1142f$var$lftPressed","$ea5bf61d4ef1142f$var$rgtPressed","$ea5bf61d4ef1142f$var$playerVelocity","$ea5bf61d4ef1142f$var$upVector","$ea5bf61d4ef1142f$var$tempVector","$ea5bf61d4ef1142f$var$tempVector2","$ea5bf61d4ef1142f$var$tempBox","$ea5bf61d4ef1142f$var$tempMat","Matrix4","$ea5bf61d4ef1142f$var$tempSegment","Line3","sub","target","$ea5bf61d4ef1142f$var$init","WebGLRenderer","antialias","setPixelRatio","setSize","innerWidth","innerHeight","setClearColor","shadowMap","enabled","type","PCFSoftShadowMap","outputEncoding","sRGBEncoding","body","Scene","fog","Fog","light","DirectionalLight","multiplyScalar","shadow","mapSize","setScalar","bias","normalBias","castShadow","shadowCam","camera","bottom","left","top","right","HemisphereLight","PerspectiveCamera","far","updateProjectionMatrix","Clock","OrbitControls","__esModule","default","GLTFLoader","load","res","gltfScene","scene","setFromObject","getCenter","negate","toMerge","hex","test","getHex","arr","visualGeometries","forEach","emissive","attach","geom","applyMatrix4","newGeom","mergeBufferGeometries","newMesh","Mesh","MeshStandardMaterial","parseInt","shadowSide","receiveShadow","staticGenerator","StaticGeometryGenerator","mergedGeometry","generate","wireframe","MeshBVHHelper","RoundedBoxGeometry","translate","capsuleInfo","segment","GUI","onChange","visFolder","addFolder","open","physicsFolder","parseFloat","aspect","$ea5bf61d4ef1142f$var$render","requestAnimationFrame","delta","getDelta","maxPolarAngle","minDistance","maxDistance","$ea5bf61d4ef1142f$var$updatePlayer","addScaledVector","angle","getAzimuthalAngle","applyAxisAngle","makeEmpty","start","expandByPoint","addScalar","shapecast","intersectsBounds","intersectsBox","intersectsTriangle","tri","distance","closestPointToSegment","direction","capsulePoint","newPosition","deltaVector","subVectors","abs","offset","dot","render"],"version":3,"file":"characterMovement.65b34017.js.map"}