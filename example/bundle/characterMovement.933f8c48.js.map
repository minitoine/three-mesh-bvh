{"mappings":"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","sources":["<anon>","src/utils/StaticGeometryGenerator.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"jAT47\", function(module, exports) {\n\n$parcel$export(module.exports, \"StaticGeometryGenerator\", () => $e43c17f117a819fb$export$3516980c1ea07296);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $e43c17f117a819fb$var$_positionVector = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $e43c17f117a819fb$var$_normalVector = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $e43c17f117a819fb$var$_tangentVector = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $e43c17f117a819fb$var$_tangentVector4 = /*@__PURE__*/ new (0, $ilwiq.Vector4)();\nconst $e43c17f117a819fb$var$_morphVector = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $e43c17f117a819fb$var$_temp = /*@__PURE__*/ new (0, $ilwiq.Vector3)();\nconst $e43c17f117a819fb$var$_skinIndex = /*@__PURE__*/ new (0, $ilwiq.Vector4)();\nconst $e43c17f117a819fb$var$_skinWeight = /*@__PURE__*/ new (0, $ilwiq.Vector4)();\nconst $e43c17f117a819fb$var$_matrix = /*@__PURE__*/ new (0, $ilwiq.Matrix4)();\nconst $e43c17f117a819fb$var$_boneMatrix = /*@__PURE__*/ new (0, $ilwiq.Matrix4)();\n// Confirms that the two provided attributes are compatible\nfunction $e43c17f117a819fb$var$validateAttributes(attr1, attr2) {\n    if (!attr1 && !attr2) return;\n    const sameCount = attr1.count === attr2.count;\n    const sameNormalized = attr1.normalized === attr2.normalized;\n    const sameType = attr1.array.constructor === attr2.array.constructor;\n    const sameItemSize = attr1.itemSize === attr2.itemSize;\n    if (!sameCount || !sameNormalized || !sameType || !sameItemSize) throw new Error();\n}\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction $e43c17f117a819fb$var$createAttributeClone(attr, countOverride = null) {\n    const cons = attr.array.constructor;\n    const normalized = attr.normalized;\n    const itemSize = attr.itemSize;\n    const count = countOverride === null ? attr.count : countOverride;\n    return new (0, $ilwiq.BufferAttribute)(new cons(itemSize * count), itemSize, normalized);\n}\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction $e43c17f117a819fb$var$copyAttributeContents(attr, target, targetOffset = 0) {\n    if (attr.isInterleavedBufferAttribute) {\n        const itemSize = attr.itemSize;\n        for(let i = 0, l = attr.count; i < l; i++){\n            const io = i + targetOffset;\n            target.setX(io, attr.getX(i));\n            if (itemSize >= 2) target.setY(io, attr.getY(i));\n            if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n            if (itemSize >= 4) target.setW(io, attr.getW(i));\n        }\n    } else {\n        const array = target.array;\n        const cons = array.constructor;\n        const byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n        const temp = new cons(array.buffer, byteOffset, attr.array.length);\n        temp.set(attr.array);\n    }\n}\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction $e43c17f117a819fb$var$addScaledMatrix(target, matrix, scale) {\n    const targetArray = target.elements;\n    const matrixArray = matrix.elements;\n    for(let i = 0, l = matrixArray.length; i < l; i++)targetArray[i] += matrixArray[i] * scale;\n}\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction $e43c17f117a819fb$var$boneNormalTransform(mesh, index, target) {\n    const skeleton = mesh.skeleton;\n    const geometry = mesh.geometry;\n    const bones = skeleton.bones;\n    const boneInverses = skeleton.boneInverses;\n    $e43c17f117a819fb$var$_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n    $e43c17f117a819fb$var$_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n    $e43c17f117a819fb$var$_matrix.elements.fill(0);\n    for(let i = 0; i < 4; i++){\n        const weight = $e43c17f117a819fb$var$_skinWeight.getComponent(i);\n        if (weight !== 0) {\n            const boneIndex = $e43c17f117a819fb$var$_skinIndex.getComponent(i);\n            $e43c17f117a819fb$var$_boneMatrix.multiplyMatrices(bones[boneIndex].matrixWorld, boneInverses[boneIndex]);\n            $e43c17f117a819fb$var$addScaledMatrix($e43c17f117a819fb$var$_matrix, $e43c17f117a819fb$var$_boneMatrix, weight);\n        }\n    }\n    $e43c17f117a819fb$var$_matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n    target.transformDirection($e43c17f117a819fb$var$_matrix);\n    return target;\n}\n// Applies the morph target data to the target vector\nfunction $e43c17f117a819fb$var$applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n    $e43c17f117a819fb$var$_morphVector.set(0, 0, 0);\n    for(let j = 0, jl = morphData.length; j < jl; j++){\n        const influence = morphInfluences[j];\n        const morphAttribute = morphData[j];\n        if (influence === 0) continue;\n        $e43c17f117a819fb$var$_temp.fromBufferAttribute(morphAttribute, i);\n        if (morphTargetsRelative) $e43c17f117a819fb$var$_morphVector.addScaledVector($e43c17f117a819fb$var$_temp, influence);\n        else $e43c17f117a819fb$var$_morphVector.addScaledVector($e43c17f117a819fb$var$_temp.sub(target), influence);\n    }\n    target.add($e43c17f117a819fb$var$_morphVector);\n}\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction $e43c17f117a819fb$var$mergeBufferGeometries(geometries, options = {\n    useGroups: false,\n    updateIndex: false,\n    skipAttributes: []\n}, targetGeometry = new (0, $ilwiq.BufferGeometry)()) {\n    const isIndexed = geometries[0].index !== null;\n    const { useGroups: useGroups = false, updateIndex: updateIndex = false, skipAttributes: skipAttributes = [] } = options;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const attributes = {};\n    let offset = 0;\n    targetGeometry.clearGroups();\n    for(let i = 0; i < geometries.length; ++i){\n        const geometry = geometries[i];\n        let attributesCount = 0;\n        // ensure that all geometries are indexed, or none\n        if (isIndexed !== (geometry.index !== null)) throw new Error(\"StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n        // gather attributes, exit early if they're different\n        for(const name in geometry.attributes){\n            if (!attributesUsed.has(name)) throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n            if (attributes[name] === undefined) attributes[name] = [];\n            attributes[name].push(geometry.attributes[name]);\n            attributesCount++;\n        }\n        // ensure geometries have the same number of attributes\n        if (attributesCount !== attributesUsed.size) throw new Error(\"StaticGeometryGenerator: Make sure all geometries have the same number of attributes.\");\n        if (useGroups) {\n            let count;\n            if (isIndexed) count = geometry.index.count;\n            else if (geometry.attributes.position !== undefined) count = geometry.attributes.position.count;\n            else throw new Error(\"StaticGeometryGenerator: The geometry must have either an index or a position attribute\");\n            targetGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    }\n    // merge indices\n    if (isIndexed) {\n        let forceUpdateIndex = false;\n        if (!targetGeometry.index) {\n            let indexCount = 0;\n            for(let i = 0; i < geometries.length; ++i)indexCount += geometries[i].index.count;\n            targetGeometry.setIndex(new (0, $ilwiq.BufferAttribute)(new Uint32Array(indexCount), 1, false));\n            forceUpdateIndex = true;\n        }\n        if (updateIndex || forceUpdateIndex) {\n            const targetIndex = targetGeometry.index;\n            let targetOffset = 0;\n            let indexOffset = 0;\n            for(let i = 0; i < geometries.length; ++i){\n                const geometry = geometries[i];\n                const index = geometry.index;\n                if (skipAttributes[i] !== true) for(let j = 0; j < index.count; ++j){\n                    targetIndex.setX(targetOffset, index.getX(j) + indexOffset);\n                    targetOffset++;\n                }\n                indexOffset += geometry.attributes.position.count;\n            }\n        }\n    }\n    // merge attributes\n    for(const name in attributes){\n        const attrList = attributes[name];\n        if (!(name in targetGeometry.attributes)) {\n            let count = 0;\n            for(const key in attrList)count += attrList[key].count;\n            targetGeometry.setAttribute(name, $e43c17f117a819fb$var$createAttributeClone(attributes[name][0], count));\n        }\n        const targetAttribute = targetGeometry.attributes[name];\n        let offset = 0;\n        for(let i = 0, l = attrList.length; i < l; i++){\n            const attr = attrList[i];\n            if (skipAttributes[i] !== true) $e43c17f117a819fb$var$copyAttributeContents(attr, targetAttribute, offset);\n            offset += attr.count;\n        }\n    }\n    return targetGeometry;\n}\nfunction $e43c17f117a819fb$var$checkTypedArrayEquality(a, b) {\n    if (a === null || b === null) return a === b;\n    if (a.length !== b.length) return false;\n    for(let i = 0, l = a.length; i < l; i++){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\nfunction $e43c17f117a819fb$var$invertGeometry(geometry) {\n    const { index: index, attributes: attributes } = geometry;\n    if (index) for(let i = 0, l = index.count; i < l; i += 3){\n        const v0 = index.getX(i);\n        const v2 = index.getX(i + 2);\n        index.setX(i, v2);\n        index.setX(i + 2, v0);\n    }\n    else for(const key in attributes){\n        const attr = attributes[key];\n        const itemSize = attr.itemSize;\n        for(let i = 0, l = attr.count; i < l; i += 3)for(let j = 0; j < itemSize; j++){\n            const v0 = attr.getComponent(i, j);\n            const v2 = attr.getComponent(i + 2, j);\n            attr.setComponent(i, j, v2);\n            attr.setComponent(i + 2, j, v0);\n        }\n    }\n    return geometry;\n}\n// Checks whether the geometry changed between this and last evaluation\nclass $e43c17f117a819fb$var$GeometryDiff {\n    constructor(mesh){\n        this.matrixWorld = new (0, $ilwiq.Matrix4)();\n        this.geometryHash = null;\n        this.boneMatrices = null;\n        this.primitiveCount = -1;\n        this.mesh = mesh;\n        this.update();\n    }\n    update() {\n        const mesh = this.mesh;\n        const geometry = mesh.geometry;\n        const skeleton = mesh.skeleton;\n        const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n        this.matrixWorld.copy(mesh.matrixWorld);\n        this.geometryHash = geometry.attributes.position.version;\n        this.primitiveCount = primitiveCount;\n        if (skeleton) {\n            // ensure the bone matrix array is updated to the appropriate length\n            if (!skeleton.boneTexture) skeleton.computeBoneTexture();\n            skeleton.update();\n            // copy data if possible otherwise clone it\n            const boneMatrices = skeleton.boneMatrices;\n            if (!this.boneMatrices || this.boneMatrices.length !== boneMatrices.length) this.boneMatrices = boneMatrices.slice();\n            else this.boneMatrices.set(boneMatrices);\n        } else this.boneMatrices = null;\n    }\n    didChange() {\n        const mesh = this.mesh;\n        const geometry = mesh.geometry;\n        const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n        const identical = this.matrixWorld.equals(mesh.matrixWorld) && this.geometryHash === geometry.attributes.position.version && $e43c17f117a819fb$var$checkTypedArrayEquality(mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices) && this.primitiveCount === primitiveCount;\n        return !identical;\n    }\n}\nclass $e43c17f117a819fb$export$3516980c1ea07296 {\n    constructor(meshes){\n        if (!Array.isArray(meshes)) meshes = [\n            meshes\n        ];\n        const finalMeshes = [];\n        meshes.forEach((object)=>{\n            object.traverseVisible((c)=>{\n                if (c.isMesh) finalMeshes.push(c);\n            });\n        });\n        this.meshes = finalMeshes;\n        this.useGroups = true;\n        this.applyWorldTransforms = true;\n        this.attributes = [\n            \"position\",\n            \"normal\",\n            \"color\",\n            \"tangent\",\n            \"uv\",\n            \"uv2\"\n        ];\n        this._intermediateGeometry = new Array(finalMeshes.length).fill().map(()=>new (0, $ilwiq.BufferGeometry)());\n        this._diffMap = new WeakMap();\n    }\n    getMaterials() {\n        const materials = [];\n        this.meshes.forEach((mesh)=>{\n            if (Array.isArray(mesh.material)) materials.push(...mesh.material);\n            else materials.push(mesh.material);\n        });\n        return materials;\n    }\n    generate(targetGeometry = new (0, $ilwiq.BufferGeometry)()) {\n        // track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n        let skipAttributes = [];\n        const { meshes: meshes, useGroups: useGroups, _intermediateGeometry: _intermediateGeometry, _diffMap: _diffMap } = this;\n        for(let i = 0, l = meshes.length; i < l; i++){\n            const mesh = meshes[i];\n            const geom = _intermediateGeometry[i];\n            const diff = _diffMap.get(mesh);\n            if (!diff || diff.didChange(mesh)) {\n                this._convertToStaticGeometry(mesh, geom);\n                skipAttributes.push(false);\n                if (!diff) _diffMap.set(mesh, new $e43c17f117a819fb$var$GeometryDiff(mesh));\n                else diff.update();\n            } else skipAttributes.push(true);\n        }\n        if (_intermediateGeometry.length === 0) {\n            // if there are no geometries then just create a fake empty geometry to provide\n            targetGeometry.setIndex(null);\n            // remove all geometry\n            const attrs = targetGeometry.attributes;\n            for(const key in attrs)targetGeometry.deleteAttribute(key);\n            // create dummy attributes\n            for(const key in this.attributes)targetGeometry.setAttribute(this.attributes[key], new (0, $ilwiq.BufferAttribute)(new Float32Array(0), 4, false));\n        } else $e43c17f117a819fb$var$mergeBufferGeometries(_intermediateGeometry, {\n            useGroups: useGroups,\n            skipAttributes: skipAttributes\n        }, targetGeometry);\n        for(const key in targetGeometry.attributes)targetGeometry.attributes[key].needsUpdate = true;\n        return targetGeometry;\n    }\n    _convertToStaticGeometry(mesh, targetGeometry = new (0, $ilwiq.BufferGeometry)()) {\n        const geometry = mesh.geometry;\n        const applyWorldTransforms = this.applyWorldTransforms;\n        const includeNormal = this.attributes.includes(\"normal\");\n        const includeTangent = this.attributes.includes(\"tangent\");\n        const attributes = geometry.attributes;\n        const targetAttributes = targetGeometry.attributes;\n        // initialize the attributes if they don't exist\n        if (!targetGeometry.index && geometry.index) targetGeometry.index = geometry.index.clone();\n        if (!targetAttributes.position) targetGeometry.setAttribute(\"position\", $e43c17f117a819fb$var$createAttributeClone(attributes.position));\n        if (includeNormal && !targetAttributes.normal && attributes.normal) targetGeometry.setAttribute(\"normal\", $e43c17f117a819fb$var$createAttributeClone(attributes.normal));\n        if (includeTangent && !targetAttributes.tangent && attributes.tangent) targetGeometry.setAttribute(\"tangent\", $e43c17f117a819fb$var$createAttributeClone(attributes.tangent));\n        // ensure the attributes are consistent\n        $e43c17f117a819fb$var$validateAttributes(geometry.index, targetGeometry.index);\n        $e43c17f117a819fb$var$validateAttributes(attributes.position, targetAttributes.position);\n        if (includeNormal) $e43c17f117a819fb$var$validateAttributes(attributes.normal, targetAttributes.normal);\n        if (includeTangent) $e43c17f117a819fb$var$validateAttributes(attributes.tangent, targetAttributes.tangent);\n        // generate transformed vertex attribute data\n        const position = attributes.position;\n        const normal = includeNormal ? attributes.normal : null;\n        const tangent = includeTangent ? attributes.tangent : null;\n        const morphPosition = geometry.morphAttributes.position;\n        const morphNormal = geometry.morphAttributes.normal;\n        const morphTangent = geometry.morphAttributes.tangent;\n        const morphTargetsRelative = geometry.morphTargetsRelative;\n        const morphInfluences = mesh.morphTargetInfluences;\n        const normalMatrix = new (0, $ilwiq.Matrix3)();\n        normalMatrix.getNormalMatrix(mesh.matrixWorld);\n        // copy the index\n        if (geometry.index) targetGeometry.index.array.set(geometry.index.array);\n        // copy and apply other attributes\n        for(let i = 0, l = attributes.position.count; i < l; i++){\n            $e43c17f117a819fb$var$_positionVector.fromBufferAttribute(position, i);\n            if (normal) $e43c17f117a819fb$var$_normalVector.fromBufferAttribute(normal, i);\n            if (tangent) {\n                $e43c17f117a819fb$var$_tangentVector4.fromBufferAttribute(tangent, i);\n                $e43c17f117a819fb$var$_tangentVector.fromBufferAttribute(tangent, i);\n            }\n            // apply morph target transform\n            if (morphInfluences) {\n                if (morphPosition) $e43c17f117a819fb$var$applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, $e43c17f117a819fb$var$_positionVector);\n                if (morphNormal) $e43c17f117a819fb$var$applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, $e43c17f117a819fb$var$_normalVector);\n                if (morphTangent) $e43c17f117a819fb$var$applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, $e43c17f117a819fb$var$_tangentVector);\n            }\n            // apply bone transform\n            if (mesh.isSkinnedMesh) {\n                mesh.applyBoneTransform(i, $e43c17f117a819fb$var$_positionVector);\n                if (normal) $e43c17f117a819fb$var$boneNormalTransform(mesh, i, $e43c17f117a819fb$var$_normalVector);\n                if (tangent) $e43c17f117a819fb$var$boneNormalTransform(mesh, i, $e43c17f117a819fb$var$_tangentVector);\n            }\n            // update the vectors of the attributes\n            if (applyWorldTransforms) $e43c17f117a819fb$var$_positionVector.applyMatrix4(mesh.matrixWorld);\n            targetAttributes.position.setXYZ(i, $e43c17f117a819fb$var$_positionVector.x, $e43c17f117a819fb$var$_positionVector.y, $e43c17f117a819fb$var$_positionVector.z);\n            if (normal) {\n                if (applyWorldTransforms) $e43c17f117a819fb$var$_normalVector.applyNormalMatrix(normalMatrix);\n                targetAttributes.normal.setXYZ(i, $e43c17f117a819fb$var$_normalVector.x, $e43c17f117a819fb$var$_normalVector.y, $e43c17f117a819fb$var$_normalVector.z);\n            }\n            if (tangent) {\n                if (applyWorldTransforms) $e43c17f117a819fb$var$_tangentVector.transformDirection(mesh.matrixWorld);\n                targetAttributes.tangent.setXYZW(i, $e43c17f117a819fb$var$_tangentVector.x, $e43c17f117a819fb$var$_tangentVector.y, $e43c17f117a819fb$var$_tangentVector.z, $e43c17f117a819fb$var$_tangentVector4.w);\n            }\n        }\n        // copy other attributes over\n        for(const i in this.attributes){\n            const key = this.attributes[i];\n            if (key === \"position\" || key === \"tangent\" || key === \"normal\" || !(key in attributes)) continue;\n            if (!targetAttributes[key]) targetGeometry.setAttribute(key, $e43c17f117a819fb$var$createAttributeClone(attributes[key]));\n            $e43c17f117a819fb$var$validateAttributes(attributes[key], targetAttributes[key]);\n            $e43c17f117a819fb$var$copyAttributeContents(attributes[key], targetAttributes[key]);\n        }\n        if (mesh.matrixWorld.determinant() < 0) $e43c17f117a819fb$var$invertGeometry(targetGeometry);\n        return targetGeometry;\n    }\n}\n\n});\n\n\n//# sourceMappingURL=characterMovement.933f8c48.js.map\n","import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nfunction invertGeometry( geometry ) {\n\n\tconst { index, attributes } = geometry;\n\tif ( index ) {\n\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\tconst v0 = index.getX( i );\n\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\tindex.setX( i, v2 );\n\t\t\tindex.setX( i + 2, v0 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = attributes[ key ];\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( _intermediateGeometry.length === 0 ) {\n\n\t\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\t\ttargetGeometry.setIndex( null );\n\n\t\t\t// remove all geometry\n\t\t\tconst attrs = targetGeometry.attributes;\n\t\t\tfor ( const key in attrs ) {\n\n\t\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t\t}\n\n\t\t\t// create dummy attributes\n\t\t\tfor ( const key in this.attributes ) {\n\n\t\t\t\ttargetGeometry.setAttribute( this.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t}\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index.clone();\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t// copy the index\n\t\tif ( geometry.index ) {\n\n\t\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t\t}\n\n\t\t// copy and apply other attributes\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\t\tinvertGeometry( targetGeometry );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","get","$e43c17f117a819fb$export$3516980c1ea07296","set","s","enumerable","configurable","$ilwiq","$e43c17f117a819fb$var$_positionVector","Vector3","$e43c17f117a819fb$var$_normalVector","$e43c17f117a819fb$var$_tangentVector","$e43c17f117a819fb$var$_tangentVector4","Vector4","$e43c17f117a819fb$var$_morphVector","$e43c17f117a819fb$var$_temp","$e43c17f117a819fb$var$_skinIndex","$e43c17f117a819fb$var$_skinWeight","$e43c17f117a819fb$var$_matrix","Matrix4","$e43c17f117a819fb$var$_boneMatrix","$e43c17f117a819fb$var$validateAttributes","attr1","attr2","sameCount","count","sameNormalized","normalized","sameType","array","constructor","sameItemSize","itemSize","$e43c17f117a819fb$var$createAttributeClone","attr","countOverride","cons","BufferAttribute","$e43c17f117a819fb$var$copyAttributeContents","target","targetOffset","isInterleavedBufferAttribute","i","l","io","setX","getX","setY","getY","setZ","getZ","setW","getW","byteOffset","BYTES_PER_ELEMENT","temp","buffer","length","$e43c17f117a819fb$var$boneNormalTransform","mesh","index","skeleton","geometry","bones","boneInverses","fromBufferAttribute","attributes","skinIndex","skinWeight","elements","fill","weight","getComponent","boneIndex","multiplyMatrices","matrixWorld","$e43c17f117a819fb$var$addScaledMatrix","matrix","scale","targetArray","matrixArray","multiply","bindMatrix","premultiply","bindMatrixInverse","transformDirection","$e43c17f117a819fb$var$applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","j","jl","influence","morphAttribute","addScaledVector","sub","add","$e43c17f117a819fb$var$GeometryDiff","geometryHash","boneMatrices","primitiveCount","update","position","copy","version","boneTexture","computeBoneTexture","slice","didChange","equals","$e43c17f117a819fb$var$checkTypedArrayEquality","a","b","meshes","Array","isArray","finalMeshes","forEach","object","traverseVisible","c","isMesh","push","useGroups","applyWorldTransforms","_intermediateGeometry","map","BufferGeometry","_diffMap","WeakMap","getMaterials","materials","material","generate","targetGeometry","skipAttributes","geom","diff","_convertToStaticGeometry","setIndex","attrs","key","deleteAttribute","setAttribute","Float32Array","$e43c17f117a819fb$var$mergeBufferGeometries","geometries","options","updateIndex","isIndexed","attributesUsed","Set","keys","offset","clearGroups","attributesCount","name","has","undefined","size","addGroup","forceUpdateIndex","indexCount","Uint32Array","targetIndex","indexOffset","attrList","targetAttribute","needsUpdate","includeNormal","includes","includeTangent","targetAttributes","clone","normal","tangent","morphPosition","morphAttributes","morphNormal","morphTangent","morphTargetInfluences","normalMatrix","Matrix3","getNormalMatrix","isSkinnedMesh","applyBoneTransform","applyMatrix4","setXYZ","x","y","z","applyNormalMatrix","setXYZW","w","determinant","$e43c17f117a819fb$var$invertGeometry","v0","v2","setComponent"],"version":3,"file":"characterMovement.933f8c48.js.map"}