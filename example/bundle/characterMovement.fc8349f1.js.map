{"mappings":"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","sources":["<anon>","node_modules/three/examples/jsm/controls/OrbitControls.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"5Rd1x\", function(module, exports) {\n\n$parcel$export(module.exports, \"OrbitControls\", () => $443c013b983d0324$export$8ff7788029dfdf52);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\nconst $443c013b983d0324$var$_changeEvent = {\n    type: \"change\"\n};\nconst $443c013b983d0324$var$_startEvent = {\n    type: \"start\"\n};\nconst $443c013b983d0324$var$_endEvent = {\n    type: \"end\"\n};\nclass $443c013b983d0324$export$8ff7788029dfdf52 extends (0, $ilwiq.EventDispatcher) {\n    constructor(object, domElement){\n        super();\n        this.object = object;\n        this.domElement = domElement;\n        this.domElement.style.touchAction = \"none\"; // disable touch scroll\n        // Set to false to disable this control\n        this.enabled = true;\n        // \"target\" sets the location of focus, where the object orbits around\n        this.target = new (0, $ilwiq.Vector3)();\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n        // How far you can zoom in and out ( OrthographicCamera only )\n        this.minZoom = 0;\n        this.maxZoom = Infinity;\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        this.minPolarAngle = 0; // radians\n        this.maxPolarAngle = Math.PI; // radians\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n        this.minAzimuthAngle = -Infinity; // radians\n        this.maxAzimuthAngle = Infinity; // radians\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        this.enableDamping = false;\n        this.dampingFactor = 0.05;\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        this.enableZoom = true;\n        this.zoomSpeed = 1.0;\n        // Set to false to disable rotating\n        this.enableRotate = true;\n        this.rotateSpeed = 1.0;\n        // Set to false to disable panning\n        this.enablePan = true;\n        this.panSpeed = 1.0;\n        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n        this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        this.autoRotate = false;\n        this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n        // The four arrow keys\n        this.keys = {\n            LEFT: \"ArrowLeft\",\n            UP: \"ArrowUp\",\n            RIGHT: \"ArrowRight\",\n            BOTTOM: \"ArrowDown\"\n        };\n        // Mouse buttons\n        this.mouseButtons = {\n            LEFT: (0, $ilwiq.MOUSE).ROTATE,\n            MIDDLE: (0, $ilwiq.MOUSE).DOLLY,\n            RIGHT: (0, $ilwiq.MOUSE).PAN\n        };\n        // Touch fingers\n        this.touches = {\n            ONE: (0, $ilwiq.TOUCH).ROTATE,\n            TWO: (0, $ilwiq.TOUCH).DOLLY_PAN\n        };\n        // for reset\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.zoom0 = this.object.zoom;\n        // the target DOM element for key events\n        this._domElementKeyEvents = null;\n        //\n        // public methods\n        //\n        this.getPolarAngle = function() {\n            return spherical.phi;\n        };\n        this.getAzimuthalAngle = function() {\n            return spherical.theta;\n        };\n        this.getDistance = function() {\n            return this.object.position.distanceTo(this.target);\n        };\n        this.listenToKeyEvents = function(domElement) {\n            domElement.addEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = domElement;\n        };\n        this.stopListenToKeyEvents = function() {\n            this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = null;\n        };\n        this.saveState = function() {\n            scope.target0.copy(scope.target);\n            scope.position0.copy(scope.object.position);\n            scope.zoom0 = scope.object.zoom;\n        };\n        this.reset = function() {\n            scope.target.copy(scope.target0);\n            scope.object.position.copy(scope.position0);\n            scope.object.zoom = scope.zoom0;\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent($443c013b983d0324$var$_changeEvent);\n            scope.update();\n            state = STATE.NONE;\n        };\n        // this method is exposed, but perhaps it would be better if we can make it private...\n        this.update = function() {\n            const offset = new (0, $ilwiq.Vector3)();\n            // so camera.up is the orbit axis\n            const quat = new (0, $ilwiq.Quaternion)().setFromUnitVectors(object.up, new (0, $ilwiq.Vector3)(0, 1, 0));\n            const quatInverse = quat.clone().invert();\n            const lastPosition = new (0, $ilwiq.Vector3)();\n            const lastQuaternion = new (0, $ilwiq.Quaternion)();\n            const twoPI = 2 * Math.PI;\n            return function update() {\n                const position = scope.object.position;\n                offset.copy(position).sub(scope.target);\n                // rotate offset to \"y-axis-is-up\" space\n                offset.applyQuaternion(quat);\n                // angle from z-axis around y-axis\n                spherical.setFromVector3(offset);\n                if (scope.autoRotate && state === STATE.NONE) rotateLeft(getAutoRotationAngle());\n                if (scope.enableDamping) {\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n                } else {\n                    spherical.theta += sphericalDelta.theta;\n                    spherical.phi += sphericalDelta.phi;\n                }\n                // restrict theta to be between desired limits\n                let min = scope.minAzimuthAngle;\n                let max = scope.maxAzimuthAngle;\n                if (isFinite(min) && isFinite(max)) {\n                    if (min < -Math.PI) min += twoPI;\n                    else if (min > Math.PI) min -= twoPI;\n                    if (max < -Math.PI) max += twoPI;\n                    else if (max > Math.PI) max -= twoPI;\n                    if (min <= max) spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n                    else spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n                }\n                // restrict phi to be between desired limits\n                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n                spherical.makeSafe();\n                spherical.radius *= scale;\n                // restrict radius to be between desired limits\n                spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\n                // move target to panned location\n                if (scope.enableDamping === true) scope.target.addScaledVector(panOffset, scope.dampingFactor);\n                else scope.target.add(panOffset);\n                offset.setFromSpherical(spherical);\n                // rotate offset back to \"camera-up-vector-is-up\" space\n                offset.applyQuaternion(quatInverse);\n                position.copy(scope.target).add(offset);\n                scope.object.lookAt(scope.target);\n                if (scope.enableDamping === true) {\n                    sphericalDelta.theta *= 1 - scope.dampingFactor;\n                    sphericalDelta.phi *= 1 - scope.dampingFactor;\n                    panOffset.multiplyScalar(1 - scope.dampingFactor);\n                } else {\n                    sphericalDelta.set(0, 0, 0);\n                    panOffset.set(0, 0, 0);\n                }\n                scale = 1;\n                // update condition is:\n                // min(camera displacement, camera rotation in radians)^2 > EPS\n                // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n                    scope.dispatchEvent($443c013b983d0324$var$_changeEvent);\n                    lastPosition.copy(scope.object.position);\n                    lastQuaternion.copy(scope.object.quaternion);\n                    zoomChanged = false;\n                    return true;\n                }\n                return false;\n            };\n        }();\n        this.dispose = function() {\n            scope.domElement.removeEventListener(\"contextmenu\", onContextMenu);\n            scope.domElement.removeEventListener(\"pointerdown\", onPointerDown);\n            scope.domElement.removeEventListener(\"pointercancel\", onPointerUp);\n            scope.domElement.removeEventListener(\"wheel\", onMouseWheel);\n            scope.domElement.removeEventListener(\"pointermove\", onPointerMove);\n            scope.domElement.removeEventListener(\"pointerup\", onPointerUp);\n            if (scope._domElementKeyEvents !== null) {\n                scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n                scope._domElementKeyEvents = null;\n            }\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n        };\n        //\n        // internals\n        //\n        const scope = this;\n        const STATE = {\n            NONE: -1,\n            ROTATE: 0,\n            DOLLY: 1,\n            PAN: 2,\n            TOUCH_ROTATE: 3,\n            TOUCH_PAN: 4,\n            TOUCH_DOLLY_PAN: 5,\n            TOUCH_DOLLY_ROTATE: 6\n        };\n        let state = STATE.NONE;\n        const EPS = 0.000001;\n        // current position in spherical coordinates\n        const spherical = new (0, $ilwiq.Spherical)();\n        const sphericalDelta = new (0, $ilwiq.Spherical)();\n        let scale = 1;\n        const panOffset = new (0, $ilwiq.Vector3)();\n        let zoomChanged = false;\n        const rotateStart = new (0, $ilwiq.Vector2)();\n        const rotateEnd = new (0, $ilwiq.Vector2)();\n        const rotateDelta = new (0, $ilwiq.Vector2)();\n        const panStart = new (0, $ilwiq.Vector2)();\n        const panEnd = new (0, $ilwiq.Vector2)();\n        const panDelta = new (0, $ilwiq.Vector2)();\n        const dollyStart = new (0, $ilwiq.Vector2)();\n        const dollyEnd = new (0, $ilwiq.Vector2)();\n        const dollyDelta = new (0, $ilwiq.Vector2)();\n        const pointers = [];\n        const pointerPositions = {};\n        function getAutoRotationAngle() {\n            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n        }\n        function getZoomScale() {\n            return Math.pow(0.95, scope.zoomSpeed);\n        }\n        function rotateLeft(angle) {\n            sphericalDelta.theta -= angle;\n        }\n        function rotateUp(angle) {\n            sphericalDelta.phi -= angle;\n        }\n        const panLeft = function() {\n            const v = new (0, $ilwiq.Vector3)();\n            return function panLeft(distance, objectMatrix) {\n                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n                v.multiplyScalar(-distance);\n                panOffset.add(v);\n            };\n        }();\n        const panUp = function() {\n            const v = new (0, $ilwiq.Vector3)();\n            return function panUp(distance, objectMatrix) {\n                if (scope.screenSpacePanning === true) v.setFromMatrixColumn(objectMatrix, 1);\n                else {\n                    v.setFromMatrixColumn(objectMatrix, 0);\n                    v.crossVectors(scope.object.up, v);\n                }\n                v.multiplyScalar(distance);\n                panOffset.add(v);\n            };\n        }();\n        // deltaX and deltaY are in pixels; right and down are positive\n        const pan = function() {\n            const offset = new (0, $ilwiq.Vector3)();\n            return function pan(deltaX, deltaY) {\n                const element = scope.domElement;\n                if (scope.object.isPerspectiveCamera) {\n                    // perspective\n                    const position = scope.object.position;\n                    offset.copy(position).sub(scope.target);\n                    let targetDistance = offset.length();\n                    // half of the fov is center to top of screen\n                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n                    // we use only clientHeight here so aspect ratio does not distort speed\n                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n                } else if (scope.object.isOrthographicCamera) {\n                    // orthographic\n                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n                } else {\n                    // camera neither orthographic nor perspective\n                    console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n                    scope.enablePan = false;\n                }\n            };\n        }();\n        function dollyOut(dollyScale) {\n            if (scope.object.isPerspectiveCamera) scale /= dollyScale;\n            else if (scope.object.isOrthographicCamera) {\n                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n                scope.object.updateProjectionMatrix();\n                zoomChanged = true;\n            } else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        function dollyIn(dollyScale) {\n            if (scope.object.isPerspectiveCamera) scale *= dollyScale;\n            else if (scope.object.isOrthographicCamera) {\n                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n                scope.object.updateProjectionMatrix();\n                zoomChanged = true;\n            } else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        //\n        // event callbacks - update the object state\n        //\n        function handleMouseDownRotate(event) {\n            rotateStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownDolly(event) {\n            dollyStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownPan(event) {\n            panStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseMoveRotate(event) {\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            rotateStart.copy(rotateEnd);\n            scope.update();\n        }\n        function handleMouseMoveDolly(event) {\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n            if (dollyDelta.y > 0) dollyOut(getZoomScale());\n            else if (dollyDelta.y < 0) dollyIn(getZoomScale());\n            dollyStart.copy(dollyEnd);\n            scope.update();\n        }\n        function handleMouseMovePan(event) {\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n            scope.update();\n        }\n        function handleMouseWheel(event) {\n            if (event.deltaY < 0) dollyIn(getZoomScale());\n            else if (event.deltaY > 0) dollyOut(getZoomScale());\n            scope.update();\n        }\n        function handleKeyDown(event) {\n            let needsUpdate = false;\n            switch(event.code){\n                case scope.keys.UP:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    else pan(0, scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.BOTTOM:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    else pan(0, -scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.LEFT:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    else pan(scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.RIGHT:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    else pan(-scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n            }\n            if (needsUpdate) {\n                // prevent the browser from scrolling on cursor keys\n                event.preventDefault();\n                scope.update();\n            }\n        }\n        function handleTouchStartRotate() {\n            if (pointers.length === 1) rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n            else {\n                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n                rotateStart.set(x, y);\n            }\n        }\n        function handleTouchStartPan() {\n            if (pointers.length === 1) panStart.set(pointers[0].pageX, pointers[0].pageY);\n            else {\n                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n                panStart.set(x, y);\n            }\n        }\n        function handleTouchStartDolly() {\n            const dx = pointers[0].pageX - pointers[1].pageX;\n            const dy = pointers[0].pageY - pointers[1].pageY;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n        function handleTouchStartDollyPan() {\n            if (scope.enableZoom) handleTouchStartDolly();\n            if (scope.enablePan) handleTouchStartPan();\n        }\n        function handleTouchStartDollyRotate() {\n            if (scope.enableZoom) handleTouchStartDolly();\n            if (scope.enableRotate) handleTouchStartRotate();\n        }\n        function handleTouchMoveRotate(event) {\n            if (pointers.length == 1) rotateEnd.set(event.pageX, event.pageY);\n            else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                rotateEnd.set(x, y);\n            }\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            rotateStart.copy(rotateEnd);\n        }\n        function handleTouchMovePan(event) {\n            if (pointers.length === 1) panEnd.set(event.pageX, event.pageY);\n            else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                panEnd.set(x, y);\n            }\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n        }\n        function handleTouchMoveDolly(event) {\n            const position = getSecondPointerPosition(event);\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyEnd.set(0, distance);\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n            dollyOut(dollyDelta.y);\n            dollyStart.copy(dollyEnd);\n        }\n        function handleTouchMoveDollyPan(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enablePan) handleTouchMovePan(event);\n        }\n        function handleTouchMoveDollyRotate(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enableRotate) handleTouchMoveRotate(event);\n        }\n        //\n        // event handlers - FSM: listen for events and reset state\n        //\n        function onPointerDown(event) {\n            if (scope.enabled === false) return;\n            if (pointers.length === 0) {\n                scope.domElement.setPointerCapture(event.pointerId);\n                scope.domElement.addEventListener(\"pointermove\", onPointerMove);\n                scope.domElement.addEventListener(\"pointerup\", onPointerUp);\n            }\n            //\n            addPointer(event);\n            if (event.pointerType === \"touch\") onTouchStart(event);\n            else onMouseDown(event);\n        }\n        function onPointerMove(event) {\n            if (scope.enabled === false) return;\n            if (event.pointerType === \"touch\") onTouchMove(event);\n            else onMouseMove(event);\n        }\n        function onPointerUp(event) {\n            removePointer(event);\n            if (pointers.length === 0) {\n                scope.domElement.releasePointerCapture(event.pointerId);\n                scope.domElement.removeEventListener(\"pointermove\", onPointerMove);\n                scope.domElement.removeEventListener(\"pointerup\", onPointerUp);\n            }\n            scope.dispatchEvent($443c013b983d0324$var$_endEvent);\n            state = STATE.NONE;\n        }\n        function onMouseDown(event) {\n            let mouseAction;\n            switch(event.button){\n                case 0:\n                    mouseAction = scope.mouseButtons.LEFT;\n                    break;\n                case 1:\n                    mouseAction = scope.mouseButtons.MIDDLE;\n                    break;\n                case 2:\n                    mouseAction = scope.mouseButtons.RIGHT;\n                    break;\n                default:\n                    mouseAction = -1;\n            }\n            switch(mouseAction){\n                case (0, $ilwiq.MOUSE).DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseDownDolly(event);\n                    state = STATE.DOLLY;\n                    break;\n                case (0, $ilwiq.MOUSE).ROTATE:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    } else {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    }\n                    break;\n                case (0, $ilwiq.MOUSE).PAN:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    } else {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) scope.dispatchEvent($443c013b983d0324$var$_startEvent);\n        }\n        function onMouseMove(event) {\n            switch(state){\n                case STATE.ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleMouseMoveRotate(event);\n                    break;\n                case STATE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseMoveDolly(event);\n                    break;\n                case STATE.PAN:\n                    if (scope.enablePan === false) return;\n                    handleMouseMovePan(event);\n                    break;\n            }\n        }\n        function onMouseWheel(event) {\n            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;\n            event.preventDefault();\n            scope.dispatchEvent($443c013b983d0324$var$_startEvent);\n            handleMouseWheel(event);\n            scope.dispatchEvent($443c013b983d0324$var$_endEvent);\n        }\n        function onKeyDown(event) {\n            if (scope.enabled === false || scope.enablePan === false) return;\n            handleKeyDown(event);\n        }\n        function onTouchStart(event) {\n            trackPointer(event);\n            switch(pointers.length){\n                case 1:\n                    switch(scope.touches.ONE){\n                        case (0, $ilwiq.TOUCH).ROTATE:\n                            if (scope.enableRotate === false) return;\n                            handleTouchStartRotate();\n                            state = STATE.TOUCH_ROTATE;\n                            break;\n                        case (0, $ilwiq.TOUCH).PAN:\n                            if (scope.enablePan === false) return;\n                            handleTouchStartPan();\n                            state = STATE.TOUCH_PAN;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                case 2:\n                    switch(scope.touches.TWO){\n                        case (0, $ilwiq.TOUCH).DOLLY_PAN:\n                            if (scope.enableZoom === false && scope.enablePan === false) return;\n                            handleTouchStartDollyPan();\n                            state = STATE.TOUCH_DOLLY_PAN;\n                            break;\n                        case (0, $ilwiq.TOUCH).DOLLY_ROTATE:\n                            if (scope.enableZoom === false && scope.enableRotate === false) return;\n                            handleTouchStartDollyRotate();\n                            state = STATE.TOUCH_DOLLY_ROTATE;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) scope.dispatchEvent($443c013b983d0324$var$_startEvent);\n        }\n        function onTouchMove(event) {\n            trackPointer(event);\n            switch(state){\n                case STATE.TOUCH_ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleTouchMoveRotate(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_PAN:\n                    if (scope.enablePan === false) return;\n                    handleTouchMovePan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_PAN:\n                    if (scope.enableZoom === false && scope.enablePan === false) return;\n                    handleTouchMoveDollyPan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_ROTATE:\n                    if (scope.enableZoom === false && scope.enableRotate === false) return;\n                    handleTouchMoveDollyRotate(event);\n                    scope.update();\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n        }\n        function onContextMenu(event) {\n            if (scope.enabled === false) return;\n            event.preventDefault();\n        }\n        function addPointer(event) {\n            pointers.push(event);\n        }\n        function removePointer(event) {\n            delete pointerPositions[event.pointerId];\n            for(let i = 0; i < pointers.length; i++)if (pointers[i].pointerId == event.pointerId) {\n                pointers.splice(i, 1);\n                return;\n            }\n        }\n        function trackPointer(event) {\n            let position = pointerPositions[event.pointerId];\n            if (position === undefined) {\n                position = new (0, $ilwiq.Vector2)();\n                pointerPositions[event.pointerId] = position;\n            }\n            position.set(event.pageX, event.pageY);\n        }\n        function getSecondPointerPosition(event) {\n            const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n            return pointerPositions[pointer.pointerId];\n        }\n        //\n        scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n        scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n        scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n        scope.domElement.addEventListener(\"wheel\", onMouseWheel, {\n            passive: false\n        });\n        // force an update at start\n        this.update();\n    }\n}\n\n});\n\n\n//# sourceMappingURL=characterMovement.fc8349f1.js.map\n","import {\n\tEventDispatcher,\n\tMOUSE,\n\tQuaternion,\n\tSpherical,\n\tTOUCH,\n\tVector2,\n\tVector3\n} from 'three';\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nclass OrbitControls extends EventDispatcher {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper();\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.05;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.panSpeed = 1.0;\n\t\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n\t\t// Touch fingers\n\t\tthis.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.getDistance = function () {\n\n\t\t\treturn this.object.position.distanceTo( this.target );\n\n\t\t};\n\n\t\tthis.listenToKeyEvents = function ( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t};\n\n\t\tthis.stopListenToKeyEvents = function () {\n\n\t\t\tthis._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = null;\n\n\t\t};\n\n\t\tthis.saveState = function () {\n\n\t\t\tscope.target0.copy( scope.target );\n\t\t\tscope.position0.copy( scope.object.position );\n\t\t\tscope.zoom0 = scope.object.zoom;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tconst quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n\t\t\tconst quatInverse = quat.clone().invert();\n\n\t\t\tconst lastPosition = new Vector3();\n\t\t\tconst lastQuaternion = new Quaternion();\n\n\t\t\tconst twoPI = 2 * Math.PI;\n\n\t\t\treturn function update() {\n\n\t\t\t\tconst position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.enableDamping ) {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t}\n\n\t\t\t\t// restrict theta to be between desired limits\n\n\t\t\t\tlet min = scope.minAzimuthAngle;\n\t\t\t\tlet max = scope.maxAzimuthAngle;\n\n\t\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\t\tif ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n\t\t\t\t\tif ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n\t\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\t\tspherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tspherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\t\tMath.max( min, spherical.theta ) :\n\t\t\t\t\t\t\tMath.min( max, spherical.theta );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tscope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\t}\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function () {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n\t\t\tscope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tscope.domElement.removeEventListener( 'pointercancel', onPointerUp );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\n\t\t\tif ( scope._domElementKeyEvents !== null ) {\n\n\t\t\t\tscope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\t\tscope._domElementKeyEvents = null;\n\n\t\t\t}\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tconst scope = this;\n\n\t\tconst STATE = {\n\t\t\tNONE: - 1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_PAN: 4,\n\t\t\tTOUCH_DOLLY_PAN: 5,\n\t\t\tTOUCH_DOLLY_ROTATE: 6\n\t\t};\n\n\t\tlet state = STATE.NONE;\n\n\t\tconst EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tconst spherical = new Spherical();\n\t\tconst sphericalDelta = new Spherical();\n\n\t\tlet scale = 1;\n\t\tconst panOffset = new Vector3();\n\t\tlet zoomChanged = false;\n\n\t\tconst rotateStart = new Vector2();\n\t\tconst rotateEnd = new Vector2();\n\t\tconst rotateDelta = new Vector2();\n\n\t\tconst panStart = new Vector2();\n\t\tconst panEnd = new Vector2();\n\t\tconst panDelta = new Vector2();\n\n\t\tconst dollyStart = new Vector2();\n\t\tconst dollyEnd = new Vector2();\n\t\tconst dollyDelta = new Vector2();\n\n\t\tconst pointers = [];\n\t\tconst pointerPositions = {};\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tconst panLeft = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tconst panUp = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t\t}\n\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tconst pan = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\t\tconst element = scope.domElement;\n\n\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tconst position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tlet targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase scope.keys.UP:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tscope.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate() {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\trotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );\n\n\t\t\t\trotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartPan() {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );\n\n\t\t\t\tpanStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly() {\n\n\t\t\tconst dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;\n\t\t\tconst dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyPan() {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly();\n\n\t\t\tif ( scope.enablePan ) handleTouchStartPan();\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyRotate() {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly();\n\n\t\t\tif ( scope.enableRotate ) handleTouchStartRotate();\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\tif ( pointers.length == 1 ) {\n\n\t\t\t\trotateEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyOut( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchMovePan( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onPointerDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.setPointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\taddPointer( event );\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchStart( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseDown( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchMove( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseMove( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerUp( event ) {\n\n\t\t\tremovePointer( event );\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.releasePointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tlet mouseAction;\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tmouseAction = - 1;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseAction ) {\n\n\t\t\t\tcase MOUSE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.ROTATE:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.PAN:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tswitch ( scope.touches.ONE ) {\n\n\t\t\t\t\t\tcase TOUCH.ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartRotate();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.PAN:\n\n\t\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartPan();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tswitch ( scope.touches.TWO ) {\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyPan();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyRotate();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tfunction addPointer( event ) {\n\n\t\t\tpointers.push( event );\n\n\t\t}\n\n\t\tfunction removePointer( event ) {\n\n\t\t\tdelete pointerPositions[ event.pointerId ];\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\t\tpointers.splice( i, 1 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction trackPointer( event ) {\n\n\t\t\tlet position = pointerPositions[ event.pointerId ];\n\n\t\t\tif ( position === undefined ) {\n\n\t\t\t\tposition = new Vector2();\n\t\t\t\tpointerPositions[ event.pointerId ] = position;\n\n\t\t\t}\n\n\t\t\tposition.set( event.pageX, event.pageY );\n\n\t\t}\n\n\t\tfunction getSecondPointerPosition( event ) {\n\n\t\t\tconst pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];\n\n\t\t\treturn pointerPositions[ pointer.pointerId ];\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n\t\tscope.domElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tscope.domElement.addEventListener( 'pointercancel', onPointerUp );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t}\n\n}\n\nexport { OrbitControls };\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","get","$443c013b983d0324$export$8ff7788029dfdf52","set","s","enumerable","configurable","$ilwiq","$443c013b983d0324$var$_changeEvent","type","$443c013b983d0324$var$_startEvent","$443c013b983d0324$var$_endEvent","EventDispatcher","constructor","object","domElement","style","touchAction","enabled","target","Vector3","minDistance","maxDistance","Infinity","minZoom","maxZoom","minPolarAngle","maxPolarAngle","Math","PI","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","zoomSpeed","enableRotate","rotateSpeed","enablePan","panSpeed","screenSpacePanning","keyPanSpeed","autoRotate","autoRotateSpeed","keys","LEFT","UP","RIGHT","BOTTOM","mouseButtons","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","touches","ONE","TOUCH","TWO","DOLLY_PAN","target0","clone","position0","position","zoom0","zoom","_domElementKeyEvents","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","getDistance","distanceTo","listenToKeyEvents","addEventListener","onKeyDown","stopListenToKeyEvents","removeEventListener","saveState","scope","copy","reset","updateProjectionMatrix","dispatchEvent","update","state","STATE","NONE","offset","quat","Quaternion","setFromUnitVectors","up","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","rotateLeft","sphericalDelta","min","max","isFinite","makeSafe","radius","scale","addScaledVector","panOffset","add","setFromSpherical","lookAt","multiplyScalar","zoomChanged","distanceToSquared","EPS","dot","quaternion","dispose","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","onPointerMove","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","pow","angle","rotateUp","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","isPerspectiveCamera","targetDistance","length","tan","fov","clientHeight","matrix","isOrthographicCamera","right","left","clientWidth","top","bottom","console","warn","dollyOut","dollyScale","dollyIn","handleMouseDownRotate","event","clientX","clientY","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","x","y","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","getSecondPointerPosition","subVectors","handleTouchMovePan","handleTouchMoveDolly","setPointerCapture","pointerId","push","pointerType","onTouchStart","trackPointer","DOLLY_ROTATE","onMouseDown","mouseAction","button","ctrlKey","metaKey","shiftKey","onTouchMove","onMouseMove","handleMouseMoveRotate","removePointer","i","splice","releasePointerCapture","preventDefault","handleKeyDown","needsUpdate","undefined","pointer","passive"],"version":3,"file":"characterMovement.fc8349f1.js.map"}