{"mappings":"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","sources":["<anon>","node_modules/stats.js/build/stats.min.js","src/objects/MeshBVHHelper.js","example/clippedEdges.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"c8CJQ\", function(module, exports) {\n// stats.js - http://github.com/mrdoob/stats.js\n(function(f, e) {\n    module.exports = e();\n})(module.exports, function() {\n    var f = function() {\n        function e(a) {\n            c.appendChild(a.dom);\n            return a;\n        }\n        function u(a) {\n            for(var d = 0; d < c.children.length; d++)c.children[d].style.display = d === a ? \"block\" : \"none\";\n            l = a;\n        }\n        var l = 0, c = document.createElement(\"div\");\n        c.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n        c.addEventListener(\"click\", function(a) {\n            a.preventDefault();\n            u(++l % c.children.length);\n        }, !1);\n        var k = (performance || Date).now(), g = k, a = 0, r = e(new f.Panel(\"FPS\", \"#0ff\", \"#002\")), h = e(new f.Panel(\"MS\", \"#0f0\", \"#020\"));\n        if (self.performance && self.performance.memory) var t = e(new f.Panel(\"MB\", \"#f08\", \"#201\"));\n        u(0);\n        return {\n            REVISION: 16,\n            dom: c,\n            addPanel: e,\n            showPanel: u,\n            begin: function() {\n                k = (performance || Date).now();\n            },\n            end: function() {\n                a++;\n                var c = (performance || Date).now();\n                h.update(c - k, 200);\n                if (c > g + 1E3 && (r.update(1E3 * a / (c - g), 100), g = c, a = 0, t)) {\n                    var d = performance.memory;\n                    t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);\n                }\n                return c;\n            },\n            update: function() {\n                k = this.end();\n            },\n            domElement: c,\n            setMode: u\n        };\n    };\n    f.Panel = function(e, f, l) {\n        var c = Infinity, k = 0, g = Math.round, a = g(window.devicePixelRatio || 1), r = 80 * a, h = 48 * a, t = 3 * a, v = 2 * a, d = 3 * a, m = 15 * a, n = 74 * a, p = 30 * a, q = document.createElement(\"canvas\");\n        q.width = r;\n        q.height = h;\n        q.style.cssText = \"width:80px;height:48px\";\n        var b = q.getContext(\"2d\");\n        b.font = \"bold \" + 9 * a + \"px Helvetica,Arial,sans-serif\";\n        b.textBaseline = \"top\";\n        b.fillStyle = l;\n        b.fillRect(0, 0, r, h);\n        b.fillStyle = f;\n        b.fillText(e, t, v);\n        b.fillRect(d, m, n, p);\n        b.fillStyle = l;\n        b.globalAlpha = .9;\n        b.fillRect(d, m, n, p);\n        return {\n            dom: q,\n            update: function(h, w) {\n                c = Math.min(c, h);\n                k = Math.max(k, h);\n                b.fillStyle = l;\n                b.globalAlpha = 1;\n                b.fillRect(0, 0, r, m);\n                b.fillStyle = f;\n                b.fillText(g(h) + \" \" + e + \" (\" + g(c) + \"-\" + g(k) + \")\", t, v);\n                b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);\n                b.fillRect(d + n - a, m, a, p);\n                b.fillStyle = l;\n                b.globalAlpha = .9;\n                b.fillRect(d + n - a, m, a, g((1 - h / w) * p));\n            }\n        };\n    };\n    return f;\n});\n\n});\n\nparcelRegister(\"5ca9G\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHHelper\", () => $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $3c85f35a8c29fa9b$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nclass $3c85f35a8c29fa9b$var$MeshBVHRootHelper extends (0, $ilwiq.Object3D) {\n    get isMesh() {\n        return !this.displayEdges;\n    }\n    get isLineSegments() {\n        return this.displayEdges;\n    }\n    get isLine() {\n        return this.displayEdges;\n    }\n    constructor(bvh, material, depth = 10, group = 0){\n        super();\n        this.material = material;\n        this.geometry = new (0, $ilwiq.BufferGeometry)();\n        this.name = \"MeshBVHRootHelper\";\n        this.depth = depth;\n        this.displayParents = false;\n        this.bvh = bvh;\n        this.displayEdges = true;\n        this._group = group;\n    }\n    raycast() {}\n    update() {\n        const geometry = this.geometry;\n        const boundsTree = this.bvh;\n        const group = this._group;\n        geometry.dispose();\n        this.visible = false;\n        if (boundsTree) {\n            // count the number of bounds required\n            const targetDepth = this.depth - 1;\n            const displayParents = this.displayParents;\n            let boundsCount = 0;\n            boundsTree.traverse((depth, isLeaf)=>{\n                if (depth >= targetDepth || isLeaf) {\n                    boundsCount++;\n                    return true;\n                } else if (displayParents) boundsCount++;\n            }, group);\n            // fill in the position buffer with the bounds corners\n            let posIndex = 0;\n            const positionArray = new Float32Array(24 * boundsCount);\n            boundsTree.traverse((depth, isLeaf, boundingData)=>{\n                const terminate = depth >= targetDepth || isLeaf;\n                if (terminate || displayParents) {\n                    (0, $aw71y.arrayToBox)(0, boundingData, $3c85f35a8c29fa9b$var$boundingBox);\n                    const { min: min, max: max } = $3c85f35a8c29fa9b$var$boundingBox;\n                    for(let x = -1; x <= 1; x += 2){\n                        const xVal = x < 0 ? min.x : max.x;\n                        for(let y = -1; y <= 1; y += 2){\n                            const yVal = y < 0 ? min.y : max.y;\n                            for(let z = -1; z <= 1; z += 2){\n                                const zVal = z < 0 ? min.z : max.z;\n                                positionArray[posIndex + 0] = xVal;\n                                positionArray[posIndex + 1] = yVal;\n                                positionArray[posIndex + 2] = zVal;\n                                posIndex += 3;\n                            }\n                        }\n                    }\n                    return terminate;\n                }\n            }, group);\n            let indexArray;\n            let indices;\n            if (this.displayEdges) // fill in the index buffer to point to the corner points\n            indices = new Uint8Array([\n                // x axis\n                0,\n                4,\n                1,\n                5,\n                2,\n                6,\n                3,\n                7,\n                // y axis\n                0,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                7,\n                // z axis\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7\n            ]);\n            else indices = new Uint8Array([\n                // X-, X+\n                0,\n                1,\n                2,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                6,\n                7,\n                5,\n                // Y-, Y+\n                1,\n                4,\n                5,\n                0,\n                4,\n                1,\n                2,\n                3,\n                6,\n                3,\n                7,\n                6,\n                // Z-, Z+\n                0,\n                2,\n                4,\n                2,\n                6,\n                4,\n                1,\n                5,\n                3,\n                3,\n                5,\n                7\n            ]);\n            if (positionArray.length > 65535) indexArray = new Uint32Array(indices.length * boundsCount);\n            else indexArray = new Uint16Array(indices.length * boundsCount);\n            const indexLength = indices.length;\n            for(let i = 0; i < boundsCount; i++){\n                const posOffset = i * 8;\n                const indexOffset = i * indexLength;\n                for(let j = 0; j < indexLength; j++)indexArray[indexOffset + j] = posOffset + indices[j];\n            }\n            // update the geometry\n            geometry.setIndex(new (0, $ilwiq.BufferAttribute)(indexArray, 1, false));\n            geometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(positionArray, 3, false));\n            this.visible = true;\n        }\n    }\n}\nclass $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 extends (0, $ilwiq.Group) {\n    get color() {\n        return this.edgeMaterial.color;\n    }\n    get opacity() {\n        return this.edgeMaterial.opacity;\n    }\n    set opacity(v) {\n        this.edgeMaterial.opacity = v;\n        this.meshMaterial.opacity = v;\n    }\n    constructor(mesh = null, bvh = null, depth = 10){\n        // handle bvh, depth signature\n        if (mesh instanceof (0, $ff8ed.MeshBVH)) {\n            depth = bvh || 10;\n            bvh = mesh;\n            mesh = null;\n        }\n        // handle mesh, depth signature\n        if (typeof bvh === \"number\") {\n            depth = bvh;\n            bvh = null;\n        }\n        super();\n        this.name = \"MeshBVHHelper\";\n        this.depth = depth;\n        this.mesh = mesh;\n        this.bvh = bvh;\n        this.displayParents = false;\n        this.displayEdges = true;\n        this._roots = [];\n        const edgeMaterial = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        const meshMaterial = new (0, $ilwiq.MeshBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        meshMaterial.color = edgeMaterial.color;\n        this.edgeMaterial = edgeMaterial;\n        this.meshMaterial = meshMaterial;\n        this.update();\n    }\n    update() {\n        const bvh = this.bvh || this.mesh.geometry.boundsTree;\n        const totalRoots = bvh ? bvh._roots.length : 0;\n        while(this._roots.length > totalRoots){\n            const root = this._roots.pop();\n            root.geometry.dispose();\n            this.remove(root);\n        }\n        for(let i = 0; i < totalRoots; i++){\n            const { depth: depth, edgeMaterial: edgeMaterial, meshMaterial: meshMaterial, displayParents: displayParents, displayEdges: displayEdges } = this;\n            if (i >= this._roots.length) {\n                const root = new $3c85f35a8c29fa9b$var$MeshBVHRootHelper(bvh, edgeMaterial, depth, i);\n                this.add(root);\n                this._roots.push(root);\n            }\n            const root = this._roots[i];\n            root.bvh = bvh;\n            root.depth = depth;\n            root.displayParents = displayParents;\n            root.displayEdges = displayEdges;\n            root.material = displayEdges ? edgeMaterial : meshMaterial;\n            root.update();\n        }\n    }\n    updateMatrixWorld(...args) {\n        const mesh = this.mesh;\n        const parent = this.parent;\n        if (mesh !== null) {\n            mesh.updateWorldMatrix(true, false);\n            if (parent) this.matrix.copy(parent.matrixWorld).invert().multiply(mesh.matrixWorld);\n            else this.matrix.copy(mesh.matrixWorld);\n            this.matrix.decompose(this.position, this.quaternion, this.scale);\n        }\n        super.updateMatrixWorld(...args);\n    }\n    copy(source) {\n        this.depth = source.depth;\n        this.mesh = source.mesh;\n        this.bvh = source.bvh;\n        this.opacity = source.opacity;\n        this.color.copy(source.color);\n    }\n    clone() {\n        return new $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5(this.mesh, this.bvh, this.depth);\n    }\n    dispose() {\n        this.edgeMaterial.dispose();\n        this.meshMaterial.dispose();\n        const children = this.children;\n        for(let i = 0, l = children.length; i < l; i++)children[i].geometry.dispose();\n    }\n}\nclass $3c85f35a8c29fa9b$export$5ead38ed5c75a1c8 extends $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 {\n    constructor(...args){\n        super(...args);\n        console.warn(\"MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.\");\n    }\n}\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $c8CJQ = parcelRequire(\"c8CJQ\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\nvar $ff8ed = parcelRequire(\"ff8ed\");\nvar $5ca9G = parcelRequire(\"5ca9G\");\nconst $ab9a3f5bbc0893bb$var$params = {\n    useBVH: true,\n    helperDisplay: false,\n    helperDepth: 10,\n    wireframeDisplay: false,\n    displayModel: true,\n    animate: true,\n    animation: \"SPIN\",\n    invert: false\n};\nlet $ab9a3f5bbc0893bb$var$renderer, $ab9a3f5bbc0893bb$var$camera, $ab9a3f5bbc0893bb$var$scene, $ab9a3f5bbc0893bb$var$gui, $ab9a3f5bbc0893bb$var$stats;\nlet $ab9a3f5bbc0893bb$var$controls, $ab9a3f5bbc0893bb$var$clock;\nlet $ab9a3f5bbc0893bb$var$colliderBvh, $ab9a3f5bbc0893bb$var$colliderMesh, $ab9a3f5bbc0893bb$var$bvhHelper;\nlet $ab9a3f5bbc0893bb$var$frontSideModel, $ab9a3f5bbc0893bb$var$backSideModel, $ab9a3f5bbc0893bb$var$planeMesh;\nlet $ab9a3f5bbc0893bb$var$clippingPlanes, $ab9a3f5bbc0893bb$var$outlineLines;\nlet $ab9a3f5bbc0893bb$var$initialClip = false;\nlet $ab9a3f5bbc0893bb$var$outputElement = null;\nlet $ab9a3f5bbc0893bb$var$time = 0;\nconst $ab9a3f5bbc0893bb$var$tempVector = new $ilwiq.Vector3();\nconst $ab9a3f5bbc0893bb$var$tempVector1 = new $ilwiq.Vector3();\nconst $ab9a3f5bbc0893bb$var$tempVector2 = new $ilwiq.Vector3();\nconst $ab9a3f5bbc0893bb$var$tempVector3 = new $ilwiq.Vector3();\nconst $ab9a3f5bbc0893bb$var$tempLine = new $ilwiq.Line3();\nconst $ab9a3f5bbc0893bb$var$inverseMatrix = new $ilwiq.Matrix4();\nconst $ab9a3f5bbc0893bb$var$localPlane = new $ilwiq.Plane();\n$ab9a3f5bbc0893bb$var$init();\n$ab9a3f5bbc0893bb$var$render();\nfunction $ab9a3f5bbc0893bb$var$init() {\n    $ab9a3f5bbc0893bb$var$outputElement = document.getElementById(\"output\");\n    const bgColor = new $ilwiq.Color(0x263238).multiplyScalar(0.1);\n    // renderer setup\n    $ab9a3f5bbc0893bb$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $ab9a3f5bbc0893bb$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $ab9a3f5bbc0893bb$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $ab9a3f5bbc0893bb$var$renderer.setClearColor(bgColor, 1);\n    $ab9a3f5bbc0893bb$var$renderer.shadowMap.enabled = true;\n    $ab9a3f5bbc0893bb$var$renderer.shadowMap.type = $ilwiq.PCFSoftShadowMap;\n    $ab9a3f5bbc0893bb$var$renderer.outputEncoding = $ilwiq.sRGBEncoding;\n    $ab9a3f5bbc0893bb$var$renderer.localClippingEnabled = true;\n    document.body.appendChild($ab9a3f5bbc0893bb$var$renderer.domElement);\n    // scene setup\n    $ab9a3f5bbc0893bb$var$scene = new $ilwiq.Scene();\n    $ab9a3f5bbc0893bb$var$scene.fog = new $ilwiq.Fog(bgColor, 20, 70);\n    // lights\n    const light = new $ilwiq.DirectionalLight(0xffffff, 0.8);\n    light.position.set(1, 1.5, 2).multiplyScalar(50);\n    $ab9a3f5bbc0893bb$var$scene.add(light);\n    $ab9a3f5bbc0893bb$var$scene.add(new $ilwiq.HemisphereLight(0xffffff, 0x223344, 0.5));\n    // camera setup\n    $ab9a3f5bbc0893bb$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 50);\n    $ab9a3f5bbc0893bb$var$camera.position.set(0.4, 0.4, 0.4);\n    $ab9a3f5bbc0893bb$var$camera.far = 100;\n    $ab9a3f5bbc0893bb$var$camera.updateProjectionMatrix();\n    $ab9a3f5bbc0893bb$var$controls = new (0, $5Rd1x.OrbitControls)($ab9a3f5bbc0893bb$var$camera, $ab9a3f5bbc0893bb$var$renderer.domElement);\n    $ab9a3f5bbc0893bb$var$clock = new $ilwiq.Clock();\n    // clippingPlanes\n    $ab9a3f5bbc0893bb$var$clippingPlanes = [\n        new $ilwiq.Plane()\n    ];\n    $ab9a3f5bbc0893bb$var$planeMesh = new $ilwiq.Mesh(new $ilwiq.PlaneBufferGeometry(), new $ilwiq.MeshBasicMaterial({\n        side: $ilwiq.DoubleSide,\n        stencilWrite: true,\n        stencilFunc: $ilwiq.NotEqualStencilFunc,\n        stencilFail: $ilwiq.ZeroStencilOp,\n        stencilZFail: $ilwiq.ZeroStencilOp,\n        stencilZPass: $ilwiq.ZeroStencilOp\n    }));\n    $ab9a3f5bbc0893bb$var$planeMesh.scale.setScalar(1.5);\n    $ab9a3f5bbc0893bb$var$planeMesh.material.color.set(0x80deea).convertLinearToSRGB();\n    $ab9a3f5bbc0893bb$var$planeMesh.renderOrder = 2;\n    $ab9a3f5bbc0893bb$var$scene.add($ab9a3f5bbc0893bb$var$planeMesh);\n    // create line geometry with enough data to hold 100000 segments\n    const lineGeometry = new $ilwiq.BufferGeometry();\n    const linePosAttr = new $ilwiq.BufferAttribute(new Float32Array(300000), 3, false);\n    linePosAttr.setUsage($ilwiq.DynamicDrawUsage);\n    lineGeometry.setAttribute(\"position\", linePosAttr);\n    $ab9a3f5bbc0893bb$var$outlineLines = new $ilwiq.LineSegments(lineGeometry, new $ilwiq.LineBasicMaterial());\n    $ab9a3f5bbc0893bb$var$outlineLines.material.color.set(0x00acc1).convertSRGBToLinear();\n    $ab9a3f5bbc0893bb$var$outlineLines.frustumCulled = false;\n    $ab9a3f5bbc0893bb$var$outlineLines.renderOrder = 3;\n    // load the model\n    const loader = new (0, $7lx9d.GLTFLoader)();\n    loader.setMeshoptDecoder((0, $kp7Te.MeshoptDecoder));\n    loader.load(\"../models/internal_combustion_engine/model.gltf\", (gltf)=>{\n        // merge the geometry if needed\n        // let model = gltf.scene;\n        // model.updateMatrixWorld( true );\n        // create a merged version if it isn't already\n        // const geometries = [];\n        // model.traverse( c => {\n        // \tif ( c.isMesh ) {\n        // \t\tconst clonedGeometry = c.geometry.clone();\n        // \t\tclonedGeometry.applyMatrix4( c.matrixWorld );\n        // \t\tfor ( const key in clonedGeometry.attributes ) {\n        // \t\t\tif ( key === 'position' || key === 'normal' ) {\n        // \t\t\t\tcontinue;\n        // \t\t\t}\n        // \t\t\tclonedGeometry.deleteAttribute( key );\n        // \t\t}\n        // \t\tgeometries.push( clonedGeometry );\n        // \t}\n        // } );\n        // const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries( geometries );\n        // model = new THREE.Mesh( mergedGeometry, new THREE.MeshStandardMaterial() );\n        // Render Order\n        // 0. Render front model and back model with stencil\n        // 1. Render surface color model\n        // 2. Render clip pane cap\n        // 3. Render outlines\n        // use basic material because the using clip caps is expensive since the fragment\n        // shader has to run always.\n        const model = gltf.scene.children[0];\n        const mergedGeometry = model.geometry;\n        model.material = new $ilwiq.MeshBasicMaterial();\n        model.position.set(0, 0, 0);\n        model.quaternion.identity();\n        // color the surface of the geometry with an EQUAL depth to limit the amount of\n        // fragment shading that has to run.\n        const surfaceModel = model.clone();\n        surfaceModel.material = new $ilwiq.MeshStandardMaterial({\n            depthFunc: $ilwiq.EqualDepth\n        });\n        surfaceModel.renderOrder = 1;\n        $ab9a3f5bbc0893bb$var$outlineLines.scale.copy(model.scale);\n        $ab9a3f5bbc0893bb$var$outlineLines.position.set(0, 0, 0);\n        $ab9a3f5bbc0893bb$var$outlineLines.quaternion.identity();\n        model.updateMatrixWorld(true);\n        // Adjust all the materials to draw front and back side with stencil for clip cap\n        const matSet = new Set();\n        const materialMap = new Map();\n        $ab9a3f5bbc0893bb$var$frontSideModel = model;\n        $ab9a3f5bbc0893bb$var$frontSideModel.updateMatrixWorld(true);\n        $ab9a3f5bbc0893bb$var$frontSideModel.traverse((c)=>{\n            if (c.isMesh) {\n                if (materialMap.has(c.material)) {\n                    c.material = materialMap.get(c.material);\n                    return;\n                }\n                matSet.add(c.material);\n                const material = c.material.clone();\n                material.color.set(0xffffff);\n                material.roughness = 1.0;\n                material.metalness = 0.0;\n                material.side = $ilwiq.FrontSide;\n                material.stencilWrite = true;\n                material.stencilFail = $ilwiq.IncrementWrapStencilOp;\n                material.stencilZFail = $ilwiq.IncrementWrapStencilOp;\n                material.stencilZPass = $ilwiq.IncrementWrapStencilOp;\n                material.clippingPlanes = $ab9a3f5bbc0893bb$var$clippingPlanes;\n                materialMap.set(c.material, material);\n                c.material = material;\n            }\n        });\n        materialMap.clear();\n        $ab9a3f5bbc0893bb$var$backSideModel = $ab9a3f5bbc0893bb$var$frontSideModel.clone();\n        $ab9a3f5bbc0893bb$var$backSideModel.traverse((c)=>{\n            if (c.isMesh) {\n                if (materialMap.has(c.material)) {\n                    c.material = materialMap.get(c.material);\n                    return;\n                }\n                const material = c.material.clone();\n                material.color.set(0xffffff);\n                material.roughness = 1.0;\n                material.metalness = 0.0;\n                material.colorWrite = false;\n                material.depthWrite = false;\n                material.side = $ilwiq.BackSide;\n                material.stencilWrite = true;\n                material.stencilFail = $ilwiq.DecrementWrapStencilOp;\n                material.stencilZFail = $ilwiq.DecrementWrapStencilOp;\n                material.stencilZPass = $ilwiq.DecrementWrapStencilOp;\n                material.clippingPlanes = $ab9a3f5bbc0893bb$var$clippingPlanes;\n                materialMap.set(c.material, material);\n                c.material = material;\n            }\n        });\n        // create the collider and preview mesh\n        $ab9a3f5bbc0893bb$var$colliderBvh = new (0, $ff8ed.MeshBVH)(mergedGeometry, {\n            maxLeafTris: 3\n        });\n        mergedGeometry.boundsTree = $ab9a3f5bbc0893bb$var$colliderBvh;\n        $ab9a3f5bbc0893bb$var$colliderMesh = new $ilwiq.Mesh(mergedGeometry, new $ilwiq.MeshBasicMaterial({\n            wireframe: true,\n            transparent: true,\n            opacity: 0.01,\n            depthWrite: false\n        }));\n        $ab9a3f5bbc0893bb$var$colliderMesh.renderOrder = 2;\n        $ab9a3f5bbc0893bb$var$colliderMesh.position.copy(model.position);\n        $ab9a3f5bbc0893bb$var$colliderMesh.rotation.copy(model.rotation);\n        $ab9a3f5bbc0893bb$var$colliderMesh.scale.copy(model.scale);\n        $ab9a3f5bbc0893bb$var$bvhHelper = new (0, $5ca9G.MeshBVHHelper)($ab9a3f5bbc0893bb$var$colliderMesh, parseInt($ab9a3f5bbc0893bb$var$params.helperDepth));\n        $ab9a3f5bbc0893bb$var$bvhHelper.depth = parseInt($ab9a3f5bbc0893bb$var$params.helperDepth);\n        $ab9a3f5bbc0893bb$var$bvhHelper.update();\n        // create group of meshes and offset it so they're centered\n        const group = new $ilwiq.Group();\n        group.add($ab9a3f5bbc0893bb$var$frontSideModel, $ab9a3f5bbc0893bb$var$backSideModel, surfaceModel, $ab9a3f5bbc0893bb$var$colliderMesh, $ab9a3f5bbc0893bb$var$bvhHelper, $ab9a3f5bbc0893bb$var$outlineLines);\n        const box = new $ilwiq.Box3();\n        box.setFromObject($ab9a3f5bbc0893bb$var$frontSideModel);\n        box.getCenter(group.position).multiplyScalar(-1);\n        group.updateMatrixWorld(true);\n        $ab9a3f5bbc0893bb$var$scene.add(group);\n    });\n    // dat.gui\n    $ab9a3f5bbc0893bb$var$gui = new (0, $jiuw3.GUI)();\n    $ab9a3f5bbc0893bb$var$gui.add($ab9a3f5bbc0893bb$var$params, \"invert\");\n    $ab9a3f5bbc0893bb$var$gui.add($ab9a3f5bbc0893bb$var$params, \"animate\");\n    $ab9a3f5bbc0893bb$var$gui.add($ab9a3f5bbc0893bb$var$params, \"animation\", [\n        \"SPIN\",\n        \"OSCILLATE\"\n    ]).onChange(()=>{\n        $ab9a3f5bbc0893bb$var$time = 0;\n    });\n    $ab9a3f5bbc0893bb$var$gui.add($ab9a3f5bbc0893bb$var$params, \"displayModel\");\n    $ab9a3f5bbc0893bb$var$gui.add($ab9a3f5bbc0893bb$var$params, \"useBVH\");\n    const helperFolder = $ab9a3f5bbc0893bb$var$gui.addFolder(\"helper\");\n    helperFolder.add($ab9a3f5bbc0893bb$var$params, \"wireframeDisplay\");\n    helperFolder.add($ab9a3f5bbc0893bb$var$params, \"helperDisplay\");\n    helperFolder.add($ab9a3f5bbc0893bb$var$params, \"helperDepth\", 1, 20, 1).onChange((v)=>{\n        if ($ab9a3f5bbc0893bb$var$bvhHelper) {\n            $ab9a3f5bbc0893bb$var$bvhHelper.depth = parseInt(v);\n            $ab9a3f5bbc0893bb$var$bvhHelper.update();\n        }\n    });\n    helperFolder.open();\n    $ab9a3f5bbc0893bb$var$gui.open();\n    // stats\n    $ab9a3f5bbc0893bb$var$stats = new (0, (/*@__PURE__*/$parcel$interopDefault($c8CJQ)))();\n    document.body.appendChild($ab9a3f5bbc0893bb$var$stats.domElement);\n    window.addEventListener(\"resize\", function() {\n        $ab9a3f5bbc0893bb$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $ab9a3f5bbc0893bb$var$camera.updateProjectionMatrix();\n        $ab9a3f5bbc0893bb$var$renderer.setSize(window.innerWidth, window.innerHeight);\n        $ab9a3f5bbc0893bb$var$renderer.setPixelRatio(window.devicePixelRatio);\n    }, false);\n}\nfunction $ab9a3f5bbc0893bb$var$render() {\n    if ($ab9a3f5bbc0893bb$var$bvhHelper) {\n        $ab9a3f5bbc0893bb$var$bvhHelper.visible = $ab9a3f5bbc0893bb$var$params.helperDisplay;\n        $ab9a3f5bbc0893bb$var$colliderMesh.visible = $ab9a3f5bbc0893bb$var$params.wireframeDisplay;\n        $ab9a3f5bbc0893bb$var$frontSideModel.visible = $ab9a3f5bbc0893bb$var$params.displayModel;\n        $ab9a3f5bbc0893bb$var$backSideModel.visible = $ab9a3f5bbc0893bb$var$params.displayModel;\n    }\n    // make the outlines darker if the model is shown\n    $ab9a3f5bbc0893bb$var$outlineLines.material.color.set($ab9a3f5bbc0893bb$var$params.displayModel ? 0x00acc1 : 0x4dd0e1).convertSRGBToLinear();\n    const delta = Math.min($ab9a3f5bbc0893bb$var$clock.getDelta(), 0.03);\n    if ($ab9a3f5bbc0893bb$var$params.animate) {\n        $ab9a3f5bbc0893bb$var$time += delta;\n        if ($ab9a3f5bbc0893bb$var$params.animation === \"SPIN\") {\n            $ab9a3f5bbc0893bb$var$planeMesh.rotation.x = 0.25 * $ab9a3f5bbc0893bb$var$time;\n            $ab9a3f5bbc0893bb$var$planeMesh.rotation.y = 0.25 * $ab9a3f5bbc0893bb$var$time;\n            $ab9a3f5bbc0893bb$var$planeMesh.rotation.z = 0.25 * $ab9a3f5bbc0893bb$var$time;\n            $ab9a3f5bbc0893bb$var$planeMesh.position.set(0, 0, 0);\n        } else {\n            $ab9a3f5bbc0893bb$var$planeMesh.position.set(Math.sin(0.25 * $ab9a3f5bbc0893bb$var$time) * 0.325, 0, 0);\n            $ab9a3f5bbc0893bb$var$planeMesh.rotation.set(0, Math.PI / 2, 0);\n        }\n        $ab9a3f5bbc0893bb$var$planeMesh.updateMatrixWorld();\n    }\n    const clippingPlane = $ab9a3f5bbc0893bb$var$clippingPlanes[0];\n    clippingPlane.normal.set(0, 0, $ab9a3f5bbc0893bb$var$params.invert ? 1 : -1);\n    clippingPlane.constant = 0;\n    clippingPlane.applyMatrix4($ab9a3f5bbc0893bb$var$planeMesh.matrixWorld);\n    // Perform the clipping\n    if ($ab9a3f5bbc0893bb$var$colliderBvh && ($ab9a3f5bbc0893bb$var$params.animate || !$ab9a3f5bbc0893bb$var$initialClip)) {\n        $ab9a3f5bbc0893bb$var$initialClip = true;\n        // get the clipping plane in the local space of the BVH\n        $ab9a3f5bbc0893bb$var$inverseMatrix.copy($ab9a3f5bbc0893bb$var$colliderMesh.matrixWorld).invert();\n        $ab9a3f5bbc0893bb$var$localPlane.copy(clippingPlane).applyMatrix4($ab9a3f5bbc0893bb$var$inverseMatrix);\n        let index = 0;\n        const posAttr = $ab9a3f5bbc0893bb$var$outlineLines.geometry.attributes.position;\n        const startTime = window.performance.now();\n        $ab9a3f5bbc0893bb$var$colliderBvh.shapecast({\n            intersectsBounds: (box)=>{\n                // if we're not using the BVH then skip straight to iterating over all triangles\n                if (!$ab9a3f5bbc0893bb$var$params.useBVH) return 0, $Mleu6.CONTAINED;\n                return $ab9a3f5bbc0893bb$var$localPlane.intersectsBox(box);\n            },\n            intersectsTriangle: (tri)=>{\n                // check each triangle edge to see if it intersects with the plane. If so then\n                // add it to the list of segments.\n                let count = 0;\n                $ab9a3f5bbc0893bb$var$tempLine.start.copy(tri.a);\n                $ab9a3f5bbc0893bb$var$tempLine.end.copy(tri.b);\n                if ($ab9a3f5bbc0893bb$var$localPlane.intersectLine($ab9a3f5bbc0893bb$var$tempLine, $ab9a3f5bbc0893bb$var$tempVector)) {\n                    posAttr.setXYZ(index, $ab9a3f5bbc0893bb$var$tempVector.x, $ab9a3f5bbc0893bb$var$tempVector.y, $ab9a3f5bbc0893bb$var$tempVector.z);\n                    index++;\n                    count++;\n                }\n                $ab9a3f5bbc0893bb$var$tempLine.start.copy(tri.b);\n                $ab9a3f5bbc0893bb$var$tempLine.end.copy(tri.c);\n                if ($ab9a3f5bbc0893bb$var$localPlane.intersectLine($ab9a3f5bbc0893bb$var$tempLine, $ab9a3f5bbc0893bb$var$tempVector)) {\n                    posAttr.setXYZ(index, $ab9a3f5bbc0893bb$var$tempVector.x, $ab9a3f5bbc0893bb$var$tempVector.y, $ab9a3f5bbc0893bb$var$tempVector.z);\n                    count++;\n                    index++;\n                }\n                $ab9a3f5bbc0893bb$var$tempLine.start.copy(tri.c);\n                $ab9a3f5bbc0893bb$var$tempLine.end.copy(tri.a);\n                if ($ab9a3f5bbc0893bb$var$localPlane.intersectLine($ab9a3f5bbc0893bb$var$tempLine, $ab9a3f5bbc0893bb$var$tempVector)) {\n                    posAttr.setXYZ(index, $ab9a3f5bbc0893bb$var$tempVector.x, $ab9a3f5bbc0893bb$var$tempVector.y, $ab9a3f5bbc0893bb$var$tempVector.z);\n                    count++;\n                    index++;\n                }\n                // When the plane passes through a vertex and one of the edges of the triangle, there will be three intersections, two of which must be repeated\n                if (count === 3) {\n                    $ab9a3f5bbc0893bb$var$tempVector1.fromBufferAttribute(posAttr, index - 3);\n                    $ab9a3f5bbc0893bb$var$tempVector2.fromBufferAttribute(posAttr, index - 2);\n                    $ab9a3f5bbc0893bb$var$tempVector3.fromBufferAttribute(posAttr, index - 1);\n                    // If the last point is a duplicate intersection\n                    if ($ab9a3f5bbc0893bb$var$tempVector3.equals($ab9a3f5bbc0893bb$var$tempVector1) || $ab9a3f5bbc0893bb$var$tempVector3.equals($ab9a3f5bbc0893bb$var$tempVector2)) {\n                        count--;\n                        index--;\n                    } else if ($ab9a3f5bbc0893bb$var$tempVector1.equals($ab9a3f5bbc0893bb$var$tempVector2)) {\n                        // If the last point is not a duplicate intersection\n                        // Set the penultimate point as a distinct point and delete the last point\n                        posAttr.setXYZ(index - 2, $ab9a3f5bbc0893bb$var$tempVector3);\n                        count--;\n                        index--;\n                    }\n                }\n                // If we only intersected with one or three sides then just remove it. This could be handled\n                // more gracefully.\n                if (count !== 2) index -= count;\n            }\n        });\n        // set the draw range to only the new segments and offset the lines so they don't intersect with the geometry\n        $ab9a3f5bbc0893bb$var$outlineLines.geometry.setDrawRange(0, index);\n        $ab9a3f5bbc0893bb$var$outlineLines.position.copy(clippingPlane.normal).multiplyScalar(-0.00001);\n        posAttr.needsUpdate = true;\n        const delta = window.performance.now() - startTime;\n        $ab9a3f5bbc0893bb$var$outputElement.innerText = `${parseFloat(delta.toFixed(3))}ms`;\n    }\n    $ab9a3f5bbc0893bb$var$stats.update();\n    requestAnimationFrame($ab9a3f5bbc0893bb$var$render);\n    $ab9a3f5bbc0893bb$var$controls.update();\n    $ab9a3f5bbc0893bb$var$renderer.render($ab9a3f5bbc0893bb$var$scene, $ab9a3f5bbc0893bb$var$camera);\n}\n\n\n//# sourceMappingURL=clippedEdges.93034cce.js.map\n","// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.bvh || this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n","import * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n// import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport Stats from 'stats.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { MeshBVH, MeshBVHHelper, CONTAINED } from '..';\n\nconst params = {\n\tuseBVH: true,\n\n\thelperDisplay: false,\n\thelperDepth: 10,\n\n\twireframeDisplay: false,\n\tdisplayModel: true,\n\n\tanimate: true,\n\tanimation: 'SPIN',\n\tinvert: false,\n};\n\nlet renderer, camera, scene, gui, stats;\nlet controls, clock;\nlet colliderBvh, colliderMesh, bvhHelper;\nlet frontSideModel, backSideModel, planeMesh;\nlet clippingPlanes, outlineLines;\nlet initialClip = false;\nlet outputElement = null;\nlet time = 0;\n\nconst tempVector = new THREE.Vector3();\nconst tempVector1 = new THREE.Vector3();\nconst tempVector2 = new THREE.Vector3();\nconst tempVector3 = new THREE.Vector3();\nconst tempLine = new THREE.Line3();\nconst inverseMatrix = new THREE.Matrix4();\nconst localPlane = new THREE.Plane();\n\ninit();\nrender();\n\nfunction init() {\n\n\toutputElement = document.getElementById( 'output' );\n\n\tconst bgColor = new THREE.Color( 0x263238 ).multiplyScalar( 0.1 );\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.shadowMap.enabled = true;\n\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\trenderer.localClippingEnabled = true;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\tscene.fog = new THREE.Fog( bgColor, 20, 70 );\n\n\t// lights\n\tconst light = new THREE.DirectionalLight( 0xffffff, 0.8 );\n\tlight.position.set( 1, 1.5, 2 ).multiplyScalar( 50 );\n\tscene.add( light );\n\tscene.add( new THREE.HemisphereLight( 0xffffff, 0x223344, 0.5 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 50 );\n\tcamera.position.set( 0.4, 0.4, 0.4 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\tclock = new THREE.Clock();\n\n\t// clippingPlanes\n\tclippingPlanes = [\n\t\tnew THREE.Plane(),\n\t];\n\n\tplaneMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial( {\n\t\tside: THREE.DoubleSide,\n\t\tstencilWrite: true,\n\t\tstencilFunc: THREE.NotEqualStencilFunc,\n\t\tstencilFail: THREE.ZeroStencilOp,\n\t\tstencilZFail: THREE.ZeroStencilOp,\n\t\tstencilZPass: THREE.ZeroStencilOp,\n\t} ) );\n\tplaneMesh.scale.setScalar( 1.5 );\n\tplaneMesh.material.color.set( 0x80deea ).convertLinearToSRGB();\n\tplaneMesh.renderOrder = 2;\n\tscene.add( planeMesh );\n\n\t// create line geometry with enough data to hold 100000 segments\n\tconst lineGeometry = new THREE.BufferGeometry();\n\tconst linePosAttr = new THREE.BufferAttribute( new Float32Array( 300000 ), 3, false );\n\tlinePosAttr.setUsage( THREE.DynamicDrawUsage );\n\tlineGeometry.setAttribute( 'position', linePosAttr );\n\toutlineLines = new THREE.LineSegments( lineGeometry, new THREE.LineBasicMaterial() );\n\toutlineLines.material.color.set( 0x00acc1 ).convertSRGBToLinear();\n\toutlineLines.frustumCulled = false;\n\toutlineLines.renderOrder = 3;\n\n\t// load the model\n\tconst loader = new GLTFLoader();\n\tloader.setMeshoptDecoder( MeshoptDecoder );\n\tloader\n\t\t.load( '../models/internal_combustion_engine/model.gltf', gltf => {\n\n\t\t\t// merge the geometry if needed\n\t\t\t// let model = gltf.scene;\n\t\t\t// model.updateMatrixWorld( true );\n\n\t\t\t// create a merged version if it isn't already\n\t\t\t// const geometries = [];\n\t\t\t// model.traverse( c => {\n\n\t\t\t// \tif ( c.isMesh ) {\n\n\t\t\t// \t\tconst clonedGeometry = c.geometry.clone();\n\t\t\t// \t\tclonedGeometry.applyMatrix4( c.matrixWorld );\n\t\t\t// \t\tfor ( const key in clonedGeometry.attributes ) {\n\n\t\t\t// \t\t\tif ( key === 'position' || key === 'normal' ) {\n\n\t\t\t// \t\t\t\tcontinue;\n\n\t\t\t// \t\t\t}\n\n\t\t\t// \t\t\tclonedGeometry.deleteAttribute( key );\n\n\t\t\t// \t\t}\n\n\t\t\t// \t\tgeometries.push( clonedGeometry );\n\n\t\t\t// \t}\n\n\t\t\t// } );\n\n\t\t\t// const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries( geometries );\n\t\t\t// model = new THREE.Mesh( mergedGeometry, new THREE.MeshStandardMaterial() );\n\n\t\t\t// Render Order\n\t\t\t// 0. Render front model and back model with stencil\n\t\t\t// 1. Render surface color model\n\t\t\t// 2. Render clip pane cap\n\t\t\t// 3. Render outlines\n\n\t\t\t// use basic material because the using clip caps is expensive since the fragment\n\t\t\t// shader has to run always.\n\t\t\tconst model = gltf.scene.children[ 0 ];\n\t\t\tconst mergedGeometry = model.geometry;\n\t\t\tmodel.material = new THREE.MeshBasicMaterial();\n\t\t\tmodel.position.set( 0, 0, 0 );\n\t\t\tmodel.quaternion.identity();\n\n\t\t\t// color the surface of the geometry with an EQUAL depth to limit the amount of\n\t\t\t// fragment shading that has to run.\n\t\t\tconst surfaceModel = model.clone();\n\t\t\tsurfaceModel.material = new THREE.MeshStandardMaterial( {\n\t\t\t\tdepthFunc: THREE.EqualDepth,\n\t\t\t} );\n\t\t\tsurfaceModel.renderOrder = 1;\n\n\t\t\toutlineLines.scale.copy( model.scale );\n\t\t\toutlineLines.position.set( 0, 0, 0 );\n\t\t\toutlineLines.quaternion.identity();\n\n\t\t\tmodel.updateMatrixWorld( true );\n\n\t\t\t// Adjust all the materials to draw front and back side with stencil for clip cap\n\t\t\tconst matSet = new Set();\n\t\t\tconst materialMap = new Map();\n\t\t\tfrontSideModel = model;\n\t\t\tfrontSideModel.updateMatrixWorld( true );\n\t\t\tfrontSideModel.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tif ( materialMap.has( c.material ) ) {\n\n\t\t\t\t\t\tc.material = materialMap.get( c.material );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmatSet.add( c.material );\n\n\t\t\t\t\tconst material = c.material.clone();\n\t\t\t\t\tmaterial.color.set( 0xffffff );\n\t\t\t\t\tmaterial.roughness = 1.0;\n\t\t\t\t\tmaterial.metalness = 0.0;\n\t\t\t\t\tmaterial.side = THREE.FrontSide;\n\t\t\t\t\tmaterial.stencilWrite = true;\n\t\t\t\t\tmaterial.stencilFail = THREE.IncrementWrapStencilOp;\n\t\t\t\t\tmaterial.stencilZFail = THREE.IncrementWrapStencilOp;\n\t\t\t\t\tmaterial.stencilZPass = THREE.IncrementWrapStencilOp;\n\t\t\t\t\tmaterial.clippingPlanes = clippingPlanes;\n\n\t\t\t\t\tmaterialMap.set( c.material, material );\n\t\t\t\t\tc.material = material;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tmaterialMap.clear();\n\n\t\t\tbackSideModel = frontSideModel.clone();\n\t\t\tbackSideModel.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tif ( materialMap.has( c.material ) ) {\n\n\t\t\t\t\t\tc.material = materialMap.get( c.material );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst material = c.material.clone();\n\t\t\t\t\tmaterial.color.set( 0xffffff );\n\t\t\t\t\tmaterial.roughness = 1.0;\n\t\t\t\t\tmaterial.metalness = 0.0;\n\t\t\t\t\tmaterial.colorWrite = false;\n\t\t\t\t\tmaterial.depthWrite = false;\n\t\t\t\t\tmaterial.side = THREE.BackSide;\n\t\t\t\t\tmaterial.stencilWrite = true;\n\t\t\t\t\tmaterial.stencilFail = THREE.DecrementWrapStencilOp;\n\t\t\t\t\tmaterial.stencilZFail = THREE.DecrementWrapStencilOp;\n\t\t\t\t\tmaterial.stencilZPass = THREE.DecrementWrapStencilOp;\n\t\t\t\t\tmaterial.clippingPlanes = clippingPlanes;\n\n\t\t\t\t\tmaterialMap.set( c.material, material );\n\t\t\t\t\tc.material = material;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// create the collider and preview mesh\n\t\t\tcolliderBvh = new MeshBVH( mergedGeometry, { maxLeafTris: 3 } );\n\t\t\tmergedGeometry.boundsTree = colliderBvh;\n\n\t\t\tcolliderMesh = new THREE.Mesh( mergedGeometry, new THREE.MeshBasicMaterial( {\n\t\t\t\twireframe: true,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.01,\n\t\t\t\tdepthWrite: false,\n\t\t\t} ) );\n\t\t\tcolliderMesh.renderOrder = 2;\n\t\t\tcolliderMesh.position.copy( model.position );\n\t\t\tcolliderMesh.rotation.copy( model.rotation );\n\t\t\tcolliderMesh.scale.copy( model.scale );\n\n\t\t\tbvhHelper = new MeshBVHHelper( colliderMesh, parseInt( params.helperDepth ) );\n\t\t\tbvhHelper.depth = parseInt( params.helperDepth );\n\t\t\tbvhHelper.update();\n\n\t\t\t// create group of meshes and offset it so they're centered\n\t\t\tconst group = new THREE.Group();\n\t\t\tgroup.add( frontSideModel, backSideModel, surfaceModel, colliderMesh, bvhHelper, outlineLines );\n\n\t\t\tconst box = new THREE.Box3();\n\t\t\tbox.setFromObject( frontSideModel );\n\t\t\tbox.getCenter( group.position ).multiplyScalar( - 1 );\n\t\t\tgroup.updateMatrixWorld( true );\n\t\t\tscene.add( group );\n\n\t\t} );\n\n\t// dat.gui\n\tgui = new GUI();\n\n\tgui.add( params, 'invert' );\n\tgui.add( params, 'animate' );\n\tgui.add( params, 'animation', [ 'SPIN', 'OSCILLATE' ] ).onChange( () => {\n\n\t\ttime = 0;\n\n\t} );\n\tgui.add( params, 'displayModel' );\n\tgui.add( params, 'useBVH' );\n\n\tconst helperFolder = gui.addFolder( 'helper' );\n\thelperFolder.add( params, 'wireframeDisplay' );\n\thelperFolder.add( params, 'helperDisplay' );\n\thelperFolder.add( params, 'helperDepth', 1, 20, 1 ).onChange( v => {\n\n\t\tif ( bvhHelper ) {\n\n\t\t\tbvhHelper.depth = parseInt( v );\n\t\t\tbvhHelper.update();\n\n\t\t}\n\n\t} );\n\thelperFolder.open();\n\n\tgui.open();\n\n\t// stats\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.domElement );\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\n\t}, false );\n\n}\n\nfunction render() {\n\n\tif ( bvhHelper ) {\n\n\t\tbvhHelper.visible = params.helperDisplay;\n\t\tcolliderMesh.visible = params.wireframeDisplay;\n\n\t\tfrontSideModel.visible = params.displayModel;\n\t\tbackSideModel.visible = params.displayModel;\n\n\t}\n\n\t// make the outlines darker if the model is shown\n\toutlineLines.material.color\n\t\t.set( params.displayModel ? 0x00acc1 : 0x4dd0e1 )\n\t\t.convertSRGBToLinear();\n\n\tconst delta = Math.min( clock.getDelta(), 0.03 );\n\tif ( params.animate ) {\n\n\t\ttime += delta;\n\n\t\tif ( params.animation === 'SPIN' ) {\n\n\t\t\tplaneMesh.rotation.x = 0.25 * time;\n\t\t\tplaneMesh.rotation.y = 0.25 * time;\n\t\t\tplaneMesh.rotation.z = 0.25 * time;\n\t\t\tplaneMesh.position.set( 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\tplaneMesh.position.set( Math.sin( 0.25 * time ) * 0.325, 0, 0 );\n\t\t\tplaneMesh.rotation.set( 0, Math.PI / 2, 0 );\n\n\t\t}\n\n\t\tplaneMesh.updateMatrixWorld();\n\n\t}\n\n\tconst clippingPlane = clippingPlanes[ 0 ];\n\tclippingPlane.normal.set( 0, 0, params.invert ? 1 : - 1 );\n\tclippingPlane.constant = 0;\n\tclippingPlane.applyMatrix4( planeMesh.matrixWorld );\n\n\t// Perform the clipping\n\tif ( colliderBvh && ( params.animate || ! initialClip ) ) {\n\n\t\tinitialClip = true;\n\n\t\t// get the clipping plane in the local space of the BVH\n\t\tinverseMatrix.copy( colliderMesh.matrixWorld ).invert();\n\t\tlocalPlane.copy( clippingPlane ).applyMatrix4( inverseMatrix );\n\n\t\tlet index = 0;\n\t\tconst posAttr = outlineLines.geometry.attributes.position;\n\t\tconst startTime = window.performance.now();\n\t\tcolliderBvh.shapecast( {\n\n\t\t\tintersectsBounds: box => {\n\n\t\t\t\t// if we're not using the BVH then skip straight to iterating over all triangles\n\t\t\t\tif ( ! params.useBVH ) {\n\n\t\t\t\t\treturn CONTAINED;\n\n\t\t\t\t}\n\n\t\t\t\treturn localPlane.intersectsBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t// check each triangle edge to see if it intersects with the plane. If so then\n\t\t\t\t// add it to the list of segments.\n\t\t\t\tlet count = 0;\n\n\t\t\t\ttempLine.start.copy( tri.a );\n\t\t\t\ttempLine.end.copy( tri.b );\n\t\t\t\tif ( localPlane.intersectLine( tempLine, tempVector ) ) {\n\n\t\t\t\t\tposAttr.setXYZ( index, tempVector.x, tempVector.y, tempVector.z );\n\t\t\t\t\tindex ++;\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t\ttempLine.start.copy( tri.b );\n\t\t\t\ttempLine.end.copy( tri.c );\n\t\t\t\tif ( localPlane.intersectLine( tempLine, tempVector ) ) {\n\n\t\t\t\t\tposAttr.setXYZ( index, tempVector.x, tempVector.y, tempVector.z );\n\t\t\t\t\tcount ++;\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\ttempLine.start.copy( tri.c );\n\t\t\t\ttempLine.end.copy( tri.a );\n\t\t\t\tif ( localPlane.intersectLine( tempLine, tempVector ) ) {\n\n\t\t\t\t\tposAttr.setXYZ( index, tempVector.x, tempVector.y, tempVector.z );\n\t\t\t\t\tcount ++;\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\t// When the plane passes through a vertex and one of the edges of the triangle, there will be three intersections, two of which must be repeated\n\t\t\t\tif ( count === 3 ) {\n\n\t\t\t\t\ttempVector1.fromBufferAttribute( posAttr, index - 3 );\n\t\t\t\t\ttempVector2.fromBufferAttribute( posAttr, index - 2 );\n\t\t\t\t\ttempVector3.fromBufferAttribute( posAttr, index - 1 );\n\t\t\t\t\t// If the last point is a duplicate intersection\n\t\t\t\t\tif ( tempVector3.equals( tempVector1 ) || tempVector3.equals( tempVector2 ) ) {\n\n\t\t\t\t\t\tcount --;\n\t\t\t\t\t\tindex --;\n\n\t\t\t\t\t} else if ( tempVector1.equals( tempVector2 ) ) {\n\n\t\t\t\t\t\t// If the last point is not a duplicate intersection\n\t\t\t\t\t\t// Set the penultimate point as a distinct point and delete the last point\n\t\t\t\t\t\tposAttr.setXYZ( index - 2, tempVector3 );\n\t\t\t\t\t\tcount --;\n\t\t\t\t\t\tindex --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// If we only intersected with one or three sides then just remove it. This could be handled\n\t\t\t\t// more gracefully.\n\t\t\t\tif ( count !== 2 ) {\n\n\t\t\t\t\tindex -= count;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t} );\n\n\t\t// set the draw range to only the new segments and offset the lines so they don't intersect with the geometry\n\t\toutlineLines.geometry.setDrawRange( 0, index );\n\t\toutlineLines.position.copy( clippingPlane.normal ).multiplyScalar( - 0.00001 );\n\t\tposAttr.needsUpdate = true;\n\n\t\tconst delta = window.performance.now() - startTime;\n\t\toutputElement.innerText = `${ parseFloat( delta.toFixed( 3 ) ) }ms`;\n\n\t}\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tcontrols.update();\n\n\trenderer.render( scene, camera );\n\n}\n\n"],"names":["$ab9a3f5bbc0893bb$var$renderer","$ab9a3f5bbc0893bb$var$camera","$ab9a3f5bbc0893bb$var$scene","$ab9a3f5bbc0893bb$var$gui","$ab9a3f5bbc0893bb$var$stats","$ab9a3f5bbc0893bb$var$controls","$ab9a3f5bbc0893bb$var$clock","$ab9a3f5bbc0893bb$var$colliderBvh","$ab9a3f5bbc0893bb$var$colliderMesh","$ab9a3f5bbc0893bb$var$bvhHelper","$ab9a3f5bbc0893bb$var$frontSideModel","$ab9a3f5bbc0893bb$var$backSideModel","$ab9a3f5bbc0893bb$var$planeMesh","$ab9a3f5bbc0893bb$var$clippingPlanes","$ab9a3f5bbc0893bb$var$outlineLines","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","f","e","a","c","appendChild","dom","u","d","children","length","style","display","l","document","createElement","cssText","addEventListener","preventDefault","k","performance","Date","now","g","r","Panel","h","self","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","Infinity","Math","round","window","devicePixelRatio","v","m","n","p","q","width","height","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","w","min","max","drawImage","Object","defineProperty","get","$3c85f35a8c29fa9b$export$e57d74bcb7e3bec5","set","s","enumerable","configurable","$ilwiq","$aw71y","$ff8ed","$3c85f35a8c29fa9b$var$boundingBox","Box3","$3c85f35a8c29fa9b$var$MeshBVHRootHelper","Object3D","isMesh","displayEdges","isLineSegments","isLine","constructor","bvh","material","depth","group","geometry","BufferGeometry","name","displayParents","_group","raycast","boundsTree","dispose","visible","indexArray","indices","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","arrayToBox","x","xVal","y","yVal","z","zVal","Uint8Array","Uint32Array","Uint16Array","indexLength","i","posOffset","indexOffset","j","setIndex","BufferAttribute","setAttribute","Group","color","edgeMaterial","opacity","meshMaterial","mesh","MeshBVH","_roots","LineBasicMaterial","transparent","depthWrite","MeshBasicMaterial","totalRoots","root","pop","remove","add","push","updateMatrixWorld","args","parent","updateWorldMatrix","matrix","copy","matrixWorld","invert","multiply","decompose","position","quaternion","scale","source","clone","$7lx9d","$kp7Te","$5Rd1x","$c8CJQ","$jiuw3","$Mleu6","$5ca9G","$ab9a3f5bbc0893bb$var$params","useBVH","helperDisplay","helperDepth","wireframeDisplay","displayModel","animate","animation","$ab9a3f5bbc0893bb$var$initialClip","$ab9a3f5bbc0893bb$var$outputElement","$ab9a3f5bbc0893bb$var$time","$ab9a3f5bbc0893bb$var$tempVector","Vector3","$ab9a3f5bbc0893bb$var$tempVector1","$ab9a3f5bbc0893bb$var$tempVector2","$ab9a3f5bbc0893bb$var$tempVector3","$ab9a3f5bbc0893bb$var$tempLine","Line3","$ab9a3f5bbc0893bb$var$inverseMatrix","Matrix4","$ab9a3f5bbc0893bb$var$localPlane","Plane","$ab9a3f5bbc0893bb$var$init","getElementById","bgColor","Color","multiplyScalar","WebGLRenderer","antialias","setPixelRatio","setSize","innerWidth","innerHeight","setClearColor","shadowMap","enabled","type","PCFSoftShadowMap","outputEncoding","sRGBEncoding","localClippingEnabled","body","Scene","fog","Fog","light","DirectionalLight","HemisphereLight","PerspectiveCamera","far","updateProjectionMatrix","OrbitControls","Clock","Mesh","PlaneBufferGeometry","side","DoubleSide","stencilWrite","stencilFunc","NotEqualStencilFunc","stencilFail","ZeroStencilOp","stencilZFail","stencilZPass","setScalar","convertLinearToSRGB","renderOrder","lineGeometry","linePosAttr","setUsage","DynamicDrawUsage","LineSegments","convertSRGBToLinear","frustumCulled","loader","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","load","gltf","model","scene","mergedGeometry","identity","surfaceModel","MeshStandardMaterial","depthFunc","EqualDepth","matSet","Set","materialMap","Map","has","roughness","metalness","FrontSide","IncrementWrapStencilOp","clippingPlanes","clear","colorWrite","BackSide","DecrementWrapStencilOp","maxLeafTris","wireframe","rotation","MeshBVHHelper","parseInt","box","setFromObject","getCenter","GUI","onChange","helperFolder","addFolder","open","__esModule","default","aspect","$ab9a3f5bbc0893bb$var$render","delta","getDelta","sin","PI","clippingPlane","normal","constant","applyMatrix4","index","posAttr","attributes","startTime","shapecast","intersectsBounds","intersectsBox","CONTAINED","intersectsTriangle","tri","count","start","intersectLine","setXYZ","fromBufferAttribute","equals","setDrawRange","needsUpdate","innerText","parseFloat","toFixed","requestAnimationFrame","render"],"version":3,"file":"clippedEdges.93034cce.js.map"}