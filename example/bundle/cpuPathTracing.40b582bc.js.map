{"mappings":"IUyBI,EAAO,EAAQ,EAAU,EAAO,EAChC,EACA,EAAa,EAAS,EAAM,EAAO,EACnC,EAAiB,EAAkB,EACnC,EAAiB,EACjB,EAAM,EAAW,EAAW,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,GT5BhC,IAgBA,EAhBI,EAAU,IAAI,IAgBlB,EAfA,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,C,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,G,I,E,E,SC+BA,IAAM,EAAU,IAAI,EAAA,kBAAiB,CAAG,GAAK,EAAG,EAAG,GAAK,EAAG,GAIrD,EAAY,IAAI,EAAA,cAAa,CACnC,EAAU,YAAY,CAAE,WAAY,IAAI,EAAA,sBAAqB,CAAG,CAAE,GAAK,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,EAAG,CAAE,IACvG,EAAU,YAAY,CAAE,KAAM,IAAI,EAAA,sBAAqB,CAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAE,GAEhF,OAAM,EAEL,YAAa,CAAQ,CAAG,CAEvB,IAAI,CAAC,KAAK,CAAG,IAAI,EAAA,IAAG,CAAG,EAAW,EAEnC,CAEA,SAAU,CAET,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,EAE5B,CAEA,OAAQ,CAAQ,CAAG,CAElB,EAAS,MAAM,CAAE,IAAI,CAAC,KAAK,CAAE,EAE9B,CAEA,IAAI,UAAW,CAEd,OAAO,IAAI,C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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/three/examples/jsm/postprocessing/Pass.js","src/utils/ExtensionUtilities.js","src/utils/GeometryRayIntersectUtilities.js","src/workers/GenerateMeshBVHWorker.js","src/workers/utils/WorkerBase.js","node_modules/@parcel/runtime-js/lib/runtime-b9d8bae84a2a3c49.js","node_modules/@parcel/runtime-js/lib/helpers/get-worker-url.js","node_modules/@parcel/runtime-js/lib/runtime-d15a0abb8846916d.js","example/cpuPathTracing.js","example/pathtracing/materialSampling.js","example/pathtracing/utils.js","example/pathtracing/ggxSampling.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = new Map();\nfunction $18c11f3350a906ea$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$18c11f3350a906ea$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping.get(id);\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nparcelRegister(\"RPVlj\", function(module, exports) {\n\n$parcel$export(module.exports, \"FullScreenQuad\", () => $0a1d3a5a6a49de03$export$3983474c8e6e978b);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $0a1d3a5a6a49de03$export$802bc10488da99c7 {\n    constructor(){\n        this.isPass = true;\n        // if set to true, the pass is processed by the composer\n        this.enabled = true;\n        // if set to true, the pass indicates to swap read and write buffer after rendering\n        this.needsSwap = true;\n        // if set to true, the pass clears its buffer before rendering\n        this.clear = false;\n        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n        this.renderToScreen = false;\n    }\n    setSize() {}\n    render() {\n        console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n    }\n    dispose() {}\n}\n// Helper for passes that need to fill the viewport with a single quad.\nconst $0a1d3a5a6a49de03$var$_camera = new (0, $ilwiq.OrthographicCamera)(-1, 1, 1, -1, 0, 1);\n// https://github.com/mrdoob/three.js/pull/21358\nconst $0a1d3a5a6a49de03$var$_geometry = new (0, $ilwiq.BufferGeometry)();\n$0a1d3a5a6a49de03$var$_geometry.setAttribute(\"position\", new (0, $ilwiq.Float32BufferAttribute)([\n    -1,\n    3,\n    0,\n    -1,\n    -1,\n    0,\n    3,\n    -1,\n    0\n], 3));\n$0a1d3a5a6a49de03$var$_geometry.setAttribute(\"uv\", new (0, $ilwiq.Float32BufferAttribute)([\n    0,\n    2,\n    0,\n    0,\n    2,\n    0\n], 2));\nclass $0a1d3a5a6a49de03$export$3983474c8e6e978b {\n    constructor(material){\n        this._mesh = new (0, $ilwiq.Mesh)($0a1d3a5a6a49de03$var$_geometry, material);\n    }\n    dispose() {\n        this._mesh.geometry.dispose();\n    }\n    render(renderer) {\n        renderer.render(this._mesh, $0a1d3a5a6a49de03$var$_camera);\n    }\n    get material() {\n        return this._mesh.material;\n    }\n    set material(value) {\n        this._mesh.material = value;\n    }\n}\n\n});\n\nparcelRegister(\"4h5hN\", function(module, exports) {\n\n$parcel$export(module.exports, \"acceleratedRaycast\", () => $31ccd9a92979d6bb$export$a0dc2935489c814a);\n$parcel$export(module.exports, \"computeBoundsTree\", () => $31ccd9a92979d6bb$export$749bba8a65fa6d70);\n$parcel$export(module.exports, \"disposeBoundsTree\", () => $31ccd9a92979d6bb$export$e0a981a7a32ddba4);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $b4YKL = parcelRequire(\"b4YKL\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $31ccd9a92979d6bb$var$ray = /* @__PURE__ */ new (0, $ilwiq.Ray)();\nconst $31ccd9a92979d6bb$var$tmpInverseMatrix = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $31ccd9a92979d6bb$var$origMeshRaycastFunc = (0, $ilwiq.Mesh).prototype.raycast;\nfunction $31ccd9a92979d6bb$export$a0dc2935489c814a(raycaster, intersects) {\n    if (this.geometry.boundsTree) {\n        if (this.material === undefined) return;\n        $31ccd9a92979d6bb$var$tmpInverseMatrix.copy(this.matrixWorld).invert();\n        $31ccd9a92979d6bb$var$ray.copy(raycaster.ray).applyMatrix4($31ccd9a92979d6bb$var$tmpInverseMatrix);\n        const bvh = this.geometry.boundsTree;\n        if (raycaster.firstHitOnly === true) {\n            const hit = (0, $b4YKL.convertRaycastIntersect)(bvh.raycastFirst($31ccd9a92979d6bb$var$ray, this.material), this, raycaster);\n            if (hit) intersects.push(hit);\n        } else {\n            const hits = bvh.raycast($31ccd9a92979d6bb$var$ray, this.material);\n            for(let i = 0, l = hits.length; i < l; i++){\n                const hit = (0, $b4YKL.convertRaycastIntersect)(hits[i], this, raycaster);\n                if (hit) intersects.push(hit);\n            }\n        }\n    } else $31ccd9a92979d6bb$var$origMeshRaycastFunc.call(this, raycaster, intersects);\n}\nfunction $31ccd9a92979d6bb$export$749bba8a65fa6d70(options) {\n    this.boundsTree = new (0, $ff8ed.MeshBVH)(this, options);\n    return this.boundsTree;\n}\nfunction $31ccd9a92979d6bb$export$e0a981a7a32ddba4() {\n    this.boundsTree = null;\n}\n\n});\nparcelRegister(\"b4YKL\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertRaycastIntersect\", () => $810f31c6ff4f494e$export$adb106eed99e8cd8);\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nfunction $810f31c6ff4f494e$export$adb106eed99e8cd8(hit, object, raycaster) {\n    if (hit === null) return null;\n    hit.point.applyMatrix4(object.matrixWorld);\n    hit.distance = hit.point.distanceTo(raycaster.ray.origin);\n    hit.object = object;\n    if (hit.distance < raycaster.near || hit.distance > raycaster.far) return null;\n    else return hit;\n}\n\n});\n\n\nparcelRegister(\"8todg\", function(module, exports) {\n\n$parcel$export(module.exports, \"GenerateMeshBVHWorker\", () => $62b3d05905f83386$export$426cc6213ad628cf);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\n\nvar $77YCt = parcelRequire(\"77YCt\");\n\nclass $62b3d05905f83386$export$426cc6213ad628cf extends (0, $77YCt.WorkerBase) {\n    constructor(){\n        const worker = new Worker((parcelRequire(\"bSef7\")));\n        super(worker);\n        this.name = \"GenerateMeshBVHWorker\";\n    }\n    runTask(worker, geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            if (geometry.getAttribute(\"position\").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.\");\n            worker.onerror = (e)=>{\n                reject(new Error(`GenerateMeshBVHWorker: ${e.message}`));\n            };\n            worker.onmessage = (e)=>{\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.serialized) {\n                    const { serialized: serialized, position: position } = data;\n                    const bvh = (0, $ff8ed.MeshBVH).deserialize(serialized, geometry, {\n                        setIndex: false\n                    });\n                    const boundsOptions = Object.assign({\n                        setBoundingBox: true\n                    }, options);\n                    // we need to replace the arrays because they're neutered entirely by the\n                    // webworker transfer.\n                    geometry.attributes.position.array = position;\n                    if (serialized.index) {\n                        if (geometry.index) geometry.index.array = serialized.index;\n                        else {\n                            const newIndex = new (0, $ilwiq.BufferAttribute)(serialized.index, 1, false);\n                            geometry.setIndex(newIndex);\n                        }\n                    }\n                    if (boundsOptions.setBoundingBox) geometry.boundingBox = bvh.getBoundingBox(new (0, $ilwiq.Box3)());\n                    if (options.onProgress) options.onProgress(data.progress);\n                    resolve(bvh);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array : null;\n            const position = geometry.attributes.position.array;\n            const transferable = [\n                position\n            ];\n            if (index) transferable.push(index);\n            worker.postMessage({\n                index: index,\n                position: position,\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress),\n                    groups: [\n                        ...geometry.groups\n                    ]\n                }\n            }, transferable.map((arr)=>arr.buffer).filter((v)=>typeof SharedArrayBuffer === \"undefined\" || !(v instanceof SharedArrayBuffer)));\n        });\n    }\n}\n\n});\nparcelRegister(\"77YCt\", function(module, exports) {\n\n$parcel$export(module.exports, \"WorkerBase\", () => $5308359e4b33977a$export$8dbf7c43841b75b7);\nclass $5308359e4b33977a$export$8dbf7c43841b75b7 {\n    constructor(worker){\n        this.name = \"WorkerBase\";\n        this.running = false;\n        this.worker = worker;\n        this.worker.onerror = (e)=>{\n            if (e.message) throw new Error(`${this.name}: Could not create Web Worker with error \"${e.message}\"`);\n            else throw new Error(`${this.name}: Could not create Web Worker.`);\n        };\n    }\n    runTask() {}\n    generate(...args) {\n        if (this.running) throw new Error(\"GenerateMeshBVHWorker: Already running job.\");\n        if (this.worker === null) throw new Error(\"GenerateMeshBVHWorker: Worker has been disposed.\");\n        this.running = true;\n        const promise = this.runTask(this.worker, ...args);\n        promise.finally(()=>{\n            this.running = false;\n        });\n        return promise;\n    }\n    dispose() {\n        this.worker.terminate();\n        this.worker = null;\n    }\n}\n\n});\n\nparcelRegister(\"bSef7\", function(module, exports) {\n\nvar $7ryUf = parcelRequire(\"7ryUf\");\nlet $8a4fc930af686efe$var$url = new URL(\"generateMeshBVH.worker.17f4c1c5.js\", import.meta.url);\nmodule.exports = $7ryUf($8a4fc930af686efe$var$url.toString(), $8a4fc930af686efe$var$url.origin, true);\n\n});\nparcelRegister(\"7ryUf\", function(module, exports) {\n\"use strict\";\nmodule.exports = function(workerUrl, origin, isESM) {\n    if (origin === self.location.origin) // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n    else {\n        // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n        var source = isESM ? \"import \" + JSON.stringify(workerUrl) + \";\" : \"importScripts(\" + JSON.stringify(workerUrl) + \");\";\n        return URL.createObjectURL(new Blob([\n            source\n        ], {\n            type: \"application/javascript\"\n        }));\n    }\n};\n\n});\n\n\n\nvar $89b625478b825bdc$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(new URL(\"\", import.meta.url).toString(), JSON.parse('[\"bTAAs\",\"cpuPathTracing.40b582bc.js\",\"6J6WW\",\"generateMeshBVH.worker.17f4c1c5.js\",\"acVmZ\",\"generateMeshBVH.worker.aad48e6e.js\",\"gr8Yf\",\"asyncGenerate.22609466.js\",\"j19h5\",\"asyncGenerate.e8b1599c.js\",\"30Pwg\",\"asyncGenerate.77ce35af.js\",\"2tzBs\",\"characterMovement.89c1b67b.js\",\"6UuCC\",\"characterMovement.5fc59dbe.js\",\"6mMEU\",\"characterMovement.fc8349f1.js\",\"i0zVc\",\"clippedEdges.dcf40b33.js\"]'));\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $7ePFa = parcelRequire(\"7ePFa\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $c526280960e2adb4$var$tempVector = new (0, $ilwiq.Vector3)();\nconst $c526280960e2adb4$var$tempVector1 = new (0, $ilwiq.Vector3)();\nconst $c526280960e2adb4$var$tempVector2 = new (0, $ilwiq.Vector3)();\nconst $c526280960e2adb4$export$fd293b15f47e270 = 1e-7;\nconst $c526280960e2adb4$export$16687fcdb041a226 = 16;\nconst $c526280960e2adb4$export$83cca5794a482c0 = [\n    [\n        1,\n        1\n    ],\n    [\n        -1,\n        -3\n    ],\n    [\n        -3,\n        2\n    ],\n    [\n        4,\n        -1\n    ],\n    [\n        -5,\n        -2\n    ],\n    [\n        2,\n        5\n    ],\n    [\n        5,\n        3\n    ],\n    [\n        3,\n        -5\n    ],\n    [\n        -2,\n        6\n    ],\n    [\n        0,\n        -7\n    ],\n    [\n        -4,\n        -6\n    ],\n    [\n        -6,\n        4\n    ],\n    [\n        -8,\n        0\n    ],\n    [\n        7,\n        -4\n    ],\n    [\n        6,\n        7\n    ],\n    [\n        -7,\n        -8\n    ]\n];\nfunction $c526280960e2adb4$export$cbf90d93e26e479(cosine, f0) {\n    return f0 + (1.0 - f0) * Math.pow(1.0 - cosine, 5.0);\n}\nfunction $c526280960e2adb4$export$ecd5dd9a6150ab1f(cosine, iorRatio) {\n    // Schlick approximation\n    const r0 = Math.pow((1 - iorRatio) / (1 + iorRatio), 2);\n    return $c526280960e2adb4$export$cbf90d93e26e479(cosine, r0);\n}\nfunction $c526280960e2adb4$export$f49311db2be090a0(dir, norm, iorRatio, target) {\n    // snell's law\n    // ior1 * sin( t1 ) = ior2 * sin( t2 )\n    let cosTheta = Math.min(-dir.dot(norm), 1.0);\n    $c526280960e2adb4$var$tempVector.copy(dir).addScaledVector(norm, cosTheta).multiplyScalar(iorRatio);\n    target.copy(norm).multiplyScalar(-Math.sqrt(Math.abs(1.0 - $c526280960e2adb4$var$tempVector.lengthSq()))).add($c526280960e2adb4$var$tempVector);\n}\nfunction $c526280960e2adb4$export$4d7afc9e2770a1ec(normal, targetMatrix) {\n    if (Math.abs(normal.x) > 0.5) $c526280960e2adb4$var$tempVector.set(0, 1, 0);\n    else $c526280960e2adb4$var$tempVector.set(1, 0, 0);\n    $c526280960e2adb4$var$tempVector1.crossVectors(normal, $c526280960e2adb4$var$tempVector).normalize();\n    $c526280960e2adb4$var$tempVector2.crossVectors(normal, $c526280960e2adb4$var$tempVector1).normalize();\n    targetMatrix.makeBasis($c526280960e2adb4$var$tempVector2, $c526280960e2adb4$var$tempVector1, normal);\n}\nfunction $c526280960e2adb4$export$5fef809e32451cd0(a, b, target) {\n    return target.addVectors(a, b).normalize();\n}\nfunction $c526280960e2adb4$export$c4618275c5af62bc(direction, surfaceNormal, geometryNormal) {\n    const aboveSurfaceNormal = direction.dot(surfaceNormal) > 0;\n    const aboveGeometryNormal = direction.dot(geometryNormal) > 0;\n    return aboveSurfaceNormal === aboveGeometryNormal;\n}\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $5d3bc9a671a608d4$var$_V = new (0, $ilwiq.Vector3)();\nconst $5d3bc9a671a608d4$var$_T1 = new (0, $ilwiq.Vector3)();\nconst $5d3bc9a671a608d4$var$_T2 = new (0, $ilwiq.Vector3)();\nconst $5d3bc9a671a608d4$var$_N = new (0, $ilwiq.Vector3)();\nconst $5d3bc9a671a608d4$var$_Z_VECTOR = new (0, $ilwiq.Vector3)(0, 0, 1);\nconst $5d3bc9a671a608d4$var$M_PI = Math.PI;\nfunction $5d3bc9a671a608d4$export$e0e6fc83417c4e49(incidentDir, roughnessX, roughnessY, random1, random2, target) {\n    // TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n    // function below, as well\n    // Implementation from reference [1]\n    // stretch view\n    const V = $5d3bc9a671a608d4$var$_V.set(roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z).normalize();\n    // orthonormal basis\n    const T1 = V.z < 0.9999 ? $5d3bc9a671a608d4$var$_T1.crossVectors(V, $5d3bc9a671a608d4$var$_Z_VECTOR).normalize() : $5d3bc9a671a608d4$var$_T1.set(1, 0, 0);\n    const T2 = $5d3bc9a671a608d4$var$_T2.crossVectors(T1, V);\n    // sample point with polar coordinates (r, phi)\n    const a = 1.0 / (1.0 + V.z);\n    const r = Math.sqrt(random1);\n    const phi = random2 < a ? random2 / a * $5d3bc9a671a608d4$var$M_PI : $5d3bc9a671a608d4$var$M_PI + (random2 - a) / (1.0 - a) * $5d3bc9a671a608d4$var$M_PI;\n    const P1 = r * Math.cos(phi);\n    const P2 = r * Math.sin(phi) * (random2 < a ? 1.0 : V.z);\n    // compute normal\n    T1.multiplyScalar(P1);\n    T2.multiplyScalar(P2);\n    const N = $5d3bc9a671a608d4$var$_N.addVectors(T1, T2).addScaledVector(V, Math.sqrt(Math.max(0.0, 1.0 - P1 * P1 - P2 * P2)));\n    // unstretch\n    N.x *= roughnessX;\n    N.y *= roughnessY;\n    N.z = Math.max(0.0, N.z);\n    N.normalize();\n    target.copy(N);\n    return target;\n}\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfunction $5d3bc9a671a608d4$var$ggxLamda(theta, roughness) {\n    const tanTheta = Math.tan(theta);\n    const tanTheta2 = tanTheta * tanTheta;\n    const alpha2 = roughness * roughness;\n    const numerator = -1 + Math.sqrt(1 + alpha2 * tanTheta2);\n    return numerator / 2;\n}\nfunction $5d3bc9a671a608d4$export$8dfbefd49188d375(theta, roughness) {\n    return 1.0 / (1.0 + $5d3bc9a671a608d4$var$ggxLamda(theta, roughness));\n}\nfunction $5d3bc9a671a608d4$export$55874a84998f17b(wi, wo, roughness) {\n    const incidentTheta = Math.acos(wi.z);\n    const scatterTheta = Math.acos(wo.z);\n    return 1.0 / (1 + $5d3bc9a671a608d4$var$ggxLamda(incidentTheta, roughness) + $5d3bc9a671a608d4$var$ggxLamda(scatterTheta, roughness));\n}\nfunction $5d3bc9a671a608d4$export$fea7bf0f85d89c60(halfVector, roughness) {\n    // See equation (33) from reference [0]\n    const a2 = roughness * roughness;\n    const cosTheta = halfVector.z;\n    const cosTheta4 = Math.pow(cosTheta, 4);\n    if (cosTheta === 0) return 0;\n    const theta = Math.acos(halfVector.z);\n    const tanTheta = Math.tan(theta);\n    const tanTheta2 = Math.pow(tanTheta, 2);\n    const denom = Math.PI * cosTheta4 * Math.pow(a2 + tanTheta2, 2);\n    return a2 / denom;\n// See equation (1) from reference [2]\n// const { x, y, z } = halfVector;\n// const a2 = roughness * roughness;\n// const mult = x * x / a2 + y * y / a2 + z * z;\n// const mult2 = mult * mult;\n// return 1.0 / Math.PI * a2 * mult2;\n}\nfunction $5d3bc9a671a608d4$export$4a51b6e1d8ff04e7(wi, halfVector, roughness) {\n    const incidentTheta = Math.acos(wi.z);\n    const D = $5d3bc9a671a608d4$export$fea7bf0f85d89c60(halfVector, roughness);\n    const G1 = $5d3bc9a671a608d4$export$8dfbefd49188d375(incidentTheta, roughness);\n    return D * G1 * Math.max(0.0, wi.dot(halfVector)) / wi.z;\n}\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// Technically this value should be based on the index of refraction of the given dielectric.\nconst $1b31943f275a7345$var$tempDir = new (0, $ilwiq.Vector3)();\nconst $1b31943f275a7345$var$halfVector = new (0, $ilwiq.Vector3)();\nconst $1b31943f275a7345$var$tempColor = new (0, $ilwiq.Color)();\nconst $1b31943f275a7345$var$whiteColor = new (0, $ilwiq.Color)(0xffffff);\n// diffuse\nfunction $1b31943f275a7345$var$diffusePDF(wo, wi, material, hit) {\n    // https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n    const cosValue = wi.z;\n    return cosValue / Math.PI;\n}\nfunction $1b31943f275a7345$var$diffuseDirection(wo, hit, material, lightDirection) {\n    lightDirection.randomDirection();\n    lightDirection.z += 1;\n    lightDirection.normalize();\n}\nfunction $1b31943f275a7345$var$diffuseColor(wo, wi, material, hit, colorTarget) {\n    // TODO: scale by 1 - F here\n    // note on division by PI\n    // https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    const { metalness: metalness, transmission: transmission } = material;\n    colorTarget.copy(material.color).multiplyScalar((1.0 - metalness) * wi.z / Math.PI / Math.PI).multiplyScalar(1.0 - transmission);\n}\n// specular\nfunction $1b31943f275a7345$var$specularPDF(wo, wi, material, hit) {\n    // See equation (17) in http://jcgt.org/published/0003/02/03/\n    const filteredRoughness = hit.filteredSurfaceRoughness;\n    (0, $c526280960e2adb4$export$5fef809e32451cd0)(wi, wo, $1b31943f275a7345$var$halfVector);\n    return (0, $5d3bc9a671a608d4$export$4a51b6e1d8ff04e7)(wi, $1b31943f275a7345$var$halfVector, filteredRoughness) / (4 * wi.dot($1b31943f275a7345$var$halfVector));\n}\nfunction $1b31943f275a7345$var$specularDirection(wo, hit, material, lightDirection) {\n    // sample ggx vndf distribution which gives a new normal\n    const filteredRoughness = hit.filteredSurfaceRoughness;\n    (0, $5d3bc9a671a608d4$export$e0e6fc83417c4e49)(wo, filteredRoughness, filteredRoughness, Math.random(), Math.random(), $1b31943f275a7345$var$halfVector);\n    // apply to new ray by reflecting off the new normal\n    lightDirection.copy(wo).reflect($1b31943f275a7345$var$halfVector).multiplyScalar(-1);\n}\nfunction $1b31943f275a7345$var$specularColor(wo, wi, material, hit, colorTarget) {\n    // if roughness is set to 0 then D === NaN which results in black pixels\n    const { metalness: metalness, ior: ior } = material;\n    const { frontFace: frontFace } = hit;\n    const filteredRoughness = hit.filteredSurfaceRoughness;\n    (0, $c526280960e2adb4$export$5fef809e32451cd0)(wo, wi, $1b31943f275a7345$var$halfVector);\n    const iorRatio = frontFace ? 1 / ior : ior;\n    const G = (0, $5d3bc9a671a608d4$export$55874a84998f17b)(wi, wo, filteredRoughness);\n    const D = (0, $5d3bc9a671a608d4$export$fea7bf0f85d89c60)($1b31943f275a7345$var$halfVector, filteredRoughness);\n    let F = (0, $c526280960e2adb4$export$ecd5dd9a6150ab1f)(wi.dot($1b31943f275a7345$var$halfVector), iorRatio);\n    const cosTheta = Math.min(wo.z, 1.0);\n    const sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n    const cannotRefract = iorRatio * sinTheta > 1.0;\n    if (cannotRefract) F = 1;\n    colorTarget.lerpColors($1b31943f275a7345$var$whiteColor, material.color, metalness).multiplyScalar(G * D / (4 * Math.abs(wi.z * wo.z))).multiplyScalar((0, $ilwiq.MathUtils).lerp(F, 1.0, metalness)).multiplyScalar(wi.z); // scale the light by the direction the light is coming in from\n}\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, hit ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/ // TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfunction $1b31943f275a7345$var$transmissionPDF(wo, wi, material, hit) {\n    const { ior: ior } = material;\n    const { frontFace: frontFace } = hit;\n    const ratio = frontFace ? 1 / ior : ior;\n    const cosTheta = Math.min(wo.z, 1.0);\n    const sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n    let reflectance = (0, $c526280960e2adb4$export$ecd5dd9a6150ab1f)(cosTheta, ratio);\n    const cannotRefract = ratio * sinTheta > 1.0;\n    if (cannotRefract) return 0.0;\n    return 1.0 / (1.0 - reflectance);\n}\nfunction $1b31943f275a7345$var$transmissionDirection(wo, hit, material, lightDirection) {\n    const { roughness: roughness, ior: ior } = material;\n    const { frontFace: frontFace } = hit;\n    const ratio = frontFace ? 1 / ior : ior;\n    $1b31943f275a7345$var$tempDir.copy(wo).multiplyScalar(-1);\n    (0, $c526280960e2adb4$export$f49311db2be090a0)($1b31943f275a7345$var$tempDir, new (0, $ilwiq.Vector3)(0, 0, 1), ratio, lightDirection);\n    $1b31943f275a7345$var$tempDir.randomDirection().multiplyScalar(roughness);\n    lightDirection.add($1b31943f275a7345$var$tempDir);\n}\nfunction $1b31943f275a7345$var$transmissionColor(wo, wi, material, hit, colorTarget) {\n    const { metalness: metalness, transmission: transmission } = material;\n    colorTarget.copy(material.color).multiplyScalar(1.0 - metalness).multiplyScalar(transmission);\n}\nfunction $1b31943f275a7345$export$b238c09be3ebd1a7(wo, wi, material, hit) {\n    const { ior: ior, metalness: metalness, transmission: transmission } = material;\n    const { frontFace: frontFace } = hit;\n    const ratio = frontFace ? 1 / ior : ior;\n    const cosTheta = Math.min(wo.z, 1.0);\n    const sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n    let reflectance = (0, $c526280960e2adb4$export$ecd5dd9a6150ab1f)(cosTheta, ratio);\n    const cannotRefract = ratio * sinTheta > 1.0;\n    if (cannotRefract) reflectance = 1;\n    let spdf = 0;\n    let dpdf = 0;\n    let tpdf = 0;\n    if (wi.z < 0) tpdf = $1b31943f275a7345$var$transmissionPDF(wo, wi, material, hit);\n    else {\n        spdf = $1b31943f275a7345$var$specularPDF(wo, wi, material, hit);\n        dpdf = $1b31943f275a7345$var$diffusePDF(wo, wi, material, hit);\n    }\n    const transSpecularProb = (0, $ilwiq.MathUtils).lerp(reflectance, 1.0, metalness);\n    const diffSpecularProb = 0.5 + 0.5 * metalness;\n    const pdf = spdf * transmission * transSpecularProb + tpdf * transmission * (1.0 - transSpecularProb) + spdf * (1.0 - transmission) * diffSpecularProb + dpdf * (1.0 - transmission) * (1.0 - diffSpecularProb);\n    return pdf;\n}\nfunction $1b31943f275a7345$export$f582f72c7e832743(wo, wi, material, hit, targetColor) {\n    if (wi.z < 0) $1b31943f275a7345$var$transmissionColor(wo, wi, material, hit, targetColor);\n    else {\n        $1b31943f275a7345$var$diffuseColor(wo, wi, material, hit, targetColor);\n        targetColor.multiplyScalar(1.0 - material.transmission);\n        $1b31943f275a7345$var$specularColor(wo, wi, material, hit, $1b31943f275a7345$var$tempColor);\n        targetColor.add($1b31943f275a7345$var$tempColor);\n    }\n}\nfunction $1b31943f275a7345$export$98d4fd8b0924db66(wo, hit, material, sampleInfo) {\n    const lightDirection = sampleInfo.direction;\n    const { ior: ior, metalness: metalness, transmission: transmission } = material;\n    const { frontFace: frontFace } = hit;\n    const ratio = frontFace ? 1 / ior : ior;\n    const cosTheta = Math.min(wo.z, 1.0);\n    const sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n    let reflectance = (0, $c526280960e2adb4$export$ecd5dd9a6150ab1f)(cosTheta, ratio);\n    const cannotRefract = ratio * sinTheta > 1.0;\n    if (cannotRefract) reflectance = 1;\n    if (Math.random() < transmission) {\n        const specularProb = (0, $ilwiq.MathUtils).lerp(reflectance, 1.0, metalness);\n        if (Math.random() < specularProb) $1b31943f275a7345$var$specularDirection(wo, hit, material, lightDirection);\n        else $1b31943f275a7345$var$transmissionDirection(wo, hit, material, lightDirection);\n    } else {\n        const specularProb = 0.5 + 0.5 * metalness;\n        if (Math.random() < specularProb) $1b31943f275a7345$var$specularDirection(wo, hit, material, lightDirection);\n        else $1b31943f275a7345$var$diffuseDirection(wo, hit, material, lightDirection);\n    }\n    sampleInfo.pdf = $1b31943f275a7345$export$b238c09be3ebd1a7(wo, lightDirection, material, hit);\n    $1b31943f275a7345$export$f582f72c7e832743(wo, lightDirection, material, hit, sampleInfo.color);\n}\n\n\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $4h5hN = parcelRequire(\"4h5hN\");\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n\nvar $8todg = parcelRequire(\"8todg\");\n\n$ilwiq.Mesh.prototype.raycast = (0, $4h5hN.acceleratedRaycast);\n$ilwiq.BufferGeometry.prototype.computeBoundsTree = (0, $4h5hN.computeBoundsTree);\n$ilwiq.BufferGeometry.prototype.disposeBoundsTree = (0, $4h5hN.disposeBoundsTree);\nlet $3acf429b35a6b753$var$scene, $3acf429b35a6b753$var$camera, $3acf429b35a6b753$var$renderer, $3acf429b35a6b753$var$light, $3acf429b35a6b753$var$clock;\nlet $3acf429b35a6b753$var$fsQuad, $3acf429b35a6b753$var$controls;\nlet $3acf429b35a6b753$var$dataTexture, $3acf429b35a6b753$var$samples, $3acf429b35a6b753$var$task, $3acf429b35a6b753$var$delay, $3acf429b35a6b753$var$scanLinePercent;\nlet $3acf429b35a6b753$var$scanLineElement, $3acf429b35a6b753$var$containerElement, $3acf429b35a6b753$var$outputContainer;\nlet $3acf429b35a6b753$var$renderStartTime, $3acf429b35a6b753$var$computationTime;\nlet $3acf429b35a6b753$var$mesh, $3acf429b35a6b753$var$materials, $3acf429b35a6b753$var$lightMesh, $3acf429b35a6b753$var$floorMesh;\n// constants\nconst $3acf429b35a6b753$var$DELAY_TIME = 300;\nconst $3acf429b35a6b753$var$FADE_DELAY = 150;\n// reusable fields\nconst $3acf429b35a6b753$var$triangle = new $ilwiq.Triangle();\nconst $3acf429b35a6b753$var$normal0 = new $ilwiq.Vector3();\nconst $3acf429b35a6b753$var$normal1 = new $ilwiq.Vector3();\nconst $3acf429b35a6b753$var$normal2 = new $ilwiq.Vector3();\nconst $3acf429b35a6b753$var$barycoord = new $ilwiq.Vector3();\nconst $3acf429b35a6b753$var$spherical = new $ilwiq.Spherical();\nconst $3acf429b35a6b753$var$normalBasis = new $ilwiq.Matrix4();\nconst $3acf429b35a6b753$var$invBasis = new $ilwiq.Matrix4();\nconst $3acf429b35a6b753$var$localDirection = new $ilwiq.Vector3();\nconst $3acf429b35a6b753$var$tempColor = new $ilwiq.Color();\nconst $3acf429b35a6b753$var$tempVector = new $ilwiq.Vector3();\nconst $3acf429b35a6b753$var$models = {};\nconst $3acf429b35a6b753$var$params = {\n    model: \"Dragon\",\n    resolution: {\n        resolutionScale: 0.5,\n        smoothImageScaling: false,\n        stretchImage: true\n    },\n    pathTracing: {\n        pause: false,\n        displayScanLine: false,\n        antialiasing: true,\n        bounces: 10,\n        filterGlossyFactor: 0.5,\n        smoothNormals: true,\n        directLightSampling: true\n    },\n    material: {\n        color: \"#0099ff\",\n        emissive: \"#000000\",\n        emissiveIntensity: 1,\n        roughness: 0.1,\n        metalness: 0.0,\n        ior: 1.8,\n        transmission: 0.0\n    },\n    floor: {\n        enable: true,\n        color: \"#7f7f7f\",\n        roughness: 0.1,\n        metalness: 0.1,\n        width: 10,\n        height: 10\n    },\n    light: {\n        enable: true,\n        position: \"Diagonal\",\n        intensity: 30.0,\n        color: \"#ffffff\",\n        width: 1,\n        height: 1\n    },\n    environment: {\n        skyMode: \"sky\",\n        skyIntensity: 0.025\n    }\n};\n$3acf429b35a6b753$var$init();\n$3acf429b35a6b753$var$render();\nfunction $3acf429b35a6b753$var$init() {\n    // renderer setup\n    $3acf429b35a6b753$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $3acf429b35a6b753$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $3acf429b35a6b753$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $3acf429b35a6b753$var$renderer.setClearColor(0, 1);\n    $3acf429b35a6b753$var$renderer.outputEncoding = $ilwiq.sRGBEncoding;\n    // container of the canvas and scan line to be centered\n    $3acf429b35a6b753$var$containerElement = document.createElement(\"div\");\n    $3acf429b35a6b753$var$containerElement.style.position = \"absolute\";\n    $3acf429b35a6b753$var$containerElement.style.inset = \"0\";\n    $3acf429b35a6b753$var$containerElement.style.margin = \"auto\";\n    $3acf429b35a6b753$var$containerElement.style.zIndex = \"-1\";\n    document.body.appendChild($3acf429b35a6b753$var$containerElement);\n    $3acf429b35a6b753$var$containerElement.appendChild($3acf429b35a6b753$var$renderer.domElement);\n    // scan line element for tracking render progress\n    $3acf429b35a6b753$var$scanLineElement = document.createElement(\"div\");\n    $3acf429b35a6b753$var$scanLineElement.style.width = \"100%\";\n    $3acf429b35a6b753$var$scanLineElement.style.position = \"absolute\";\n    $3acf429b35a6b753$var$scanLineElement.style.borderBottom = \"1px solid #e91e63\";\n    $3acf429b35a6b753$var$scanLineElement.style.visibility = \"hidden\";\n    $3acf429b35a6b753$var$containerElement.appendChild($3acf429b35a6b753$var$scanLineElement);\n    $3acf429b35a6b753$var$outputContainer = document.getElementById(\"output\");\n    $3acf429b35a6b753$var$fsQuad = new (0, $RPVlj.FullScreenQuad)(new $ilwiq.MeshBasicMaterial());\n    $3acf429b35a6b753$var$fsQuad.material.transparent = true;\n    // scene setup\n    $3acf429b35a6b753$var$scene = new $ilwiq.Scene();\n    // camera setup\n    $3acf429b35a6b753$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);\n    $3acf429b35a6b753$var$camera.position.set(-2.5, 1.5, 2.5);\n    $3acf429b35a6b753$var$camera.far = 100;\n    $3acf429b35a6b753$var$camera.updateProjectionMatrix();\n    // light\n    $3acf429b35a6b753$var$light = new $ilwiq.HemisphereLight(0xffffff, 0x666666, 1);\n    $3acf429b35a6b753$var$scene.add($3acf429b35a6b753$var$light);\n    $3acf429b35a6b753$var$lightMesh = new $ilwiq.Mesh(new $ilwiq.PlaneBufferGeometry(1, 1, 1, 1), new $ilwiq.MeshBasicMaterial({\n        side: $ilwiq.DoubleSide\n    }));\n    $3acf429b35a6b753$var$lightMesh.position.set(2, 2, 2);\n    $3acf429b35a6b753$var$lightMesh.lookAt(0, 0, 0);\n    $3acf429b35a6b753$var$scene.add($3acf429b35a6b753$var$lightMesh);\n    $3acf429b35a6b753$var$floorMesh = new $ilwiq.Mesh(new $ilwiq.PlaneBufferGeometry(1, 1, 1, 1), new $ilwiq.MeshStandardMaterial({\n        side: $ilwiq.DoubleSide\n    }));\n    $3acf429b35a6b753$var$floorMesh.rotation.x = -Math.PI / 2;\n    $3acf429b35a6b753$var$floorMesh.scale.setScalar(1);\n    $3acf429b35a6b753$var$floorMesh.material.ior = 1.6;\n    $3acf429b35a6b753$var$floorMesh.material.transmission = 0;\n    $3acf429b35a6b753$var$scene.add($3acf429b35a6b753$var$floorMesh);\n    $3acf429b35a6b753$var$controls = new (0, $5Rd1x.OrbitControls)($3acf429b35a6b753$var$camera, $3acf429b35a6b753$var$renderer.domElement);\n    $3acf429b35a6b753$var$controls.addEventListener(\"change\", $3acf429b35a6b753$var$resetImage);\n    window.addEventListener(\"resize\", $3acf429b35a6b753$var$onResize, false);\n    $3acf429b35a6b753$var$onResize();\n    // Load sphere\n    $3acf429b35a6b753$var$models[\"Sphere\"] = null;\n    {\n        const sphereMesh = new $ilwiq.Mesh(new $ilwiq.SphereGeometry(1, 100, 50), new $ilwiq.MeshStandardMaterial());\n        const { geometry: geometry, materials: materials } = $3acf429b35a6b753$var$mergeMeshes([\n            sphereMesh\n        ], true);\n        const merged = new $ilwiq.Mesh(geometry, new $ilwiq.MeshStandardMaterial());\n        $3acf429b35a6b753$var$scene.add(merged);\n        geometry.computeBoundsTree({\n            strategy: (0, $Mleu6.SAH),\n            maxLeafTris: 1\n        });\n        $3acf429b35a6b753$var$models[\"Sphere\"] = {\n            mesh: merged,\n            materials: materials,\n            floorHeight: -1\n        };\n    }\n    $3acf429b35a6b753$var$models[\"Cornell Box\"] = null;\n    {\n        const planeGeom = new $ilwiq.PlaneBufferGeometry(1, 1, 1, 1);\n        const leftWall = new $ilwiq.Mesh(planeGeom, new $ilwiq.MeshStandardMaterial({\n            color: 0x00ee00,\n            side: $ilwiq.DoubleSide\n        }));\n        leftWall.rotation.y = Math.PI / 2;\n        leftWall.position.x = -2;\n        leftWall.scale.setScalar(4);\n        leftWall.updateMatrixWorld(true);\n        const rightWall = new $ilwiq.Mesh(planeGeom, new $ilwiq.MeshStandardMaterial({\n            color: 0xee0000\n        }));\n        rightWall.rotation.y = Math.PI / 2;\n        rightWall.position.x = 2;\n        rightWall.scale.setScalar(4);\n        rightWall.updateMatrixWorld(true);\n        const backWall = new $ilwiq.Mesh(planeGeom, new $ilwiq.MeshStandardMaterial({\n            color: 0xeeeeee\n        }));\n        backWall.position.z = -2;\n        backWall.scale.setScalar(4);\n        backWall.updateMatrixWorld(true);\n        const ceiling = new $ilwiq.Mesh(planeGeom.clone(), new $ilwiq.MeshStandardMaterial({\n            color: 0xeeeeee\n        }));\n        ceiling.rotation.x = Math.PI / 2;\n        ceiling.position.y = 2;\n        ceiling.scale.setScalar(4);\n        ceiling.updateMatrixWorld(true);\n        const box = new $ilwiq.Mesh(new $ilwiq.BoxGeometry(1, 2, 1), new $ilwiq.MeshStandardMaterial({\n            side: $ilwiq.DoubleSide\n        }));\n        box.position.y = -1;\n        box.position.x = -0.6;\n        box.position.z = -0.25;\n        box.rotation.y = Math.PI / 4;\n        const box2 = new $ilwiq.Mesh(new $ilwiq.BoxGeometry(1, 1, 1), new $ilwiq.MeshStandardMaterial({\n            side: $ilwiq.DoubleSide\n        }));\n        box2.position.y = -1.5;\n        box2.position.x = 0.75;\n        box2.position.z = 0.5;\n        box2.rotation.y = -Math.PI / 8;\n        const { geometry: geometry, materials: materials } = $3acf429b35a6b753$var$mergeMeshes([\n            box,\n            box2,\n            leftWall,\n            rightWall,\n            backWall,\n            ceiling\n        ], true);\n        const merged = new $ilwiq.Mesh(geometry, new $ilwiq.MeshStandardMaterial());\n        $3acf429b35a6b753$var$scene.add(merged);\n        geometry.computeBoundsTree({\n            strategy: (0, $Mleu6.SAH),\n            maxLeafTris: 1\n        });\n        $3acf429b35a6b753$var$models[\"Cornell Box\"] = {\n            mesh: merged,\n            materials: materials,\n            floorHeight: -2\n        };\n    }\n    // Load dragon\n    $3acf429b35a6b753$var$models[\"Dragon\"] = null;\n    new (0, $7lx9d.GLTFLoader)().load(\"../models/DragonAttenuation.glb\", (gltf)=>{\n        let mesh;\n        gltf.scene.traverse((c)=>{\n            if (c.isMesh && c.name === \"Dragon\") mesh = c;\n        });\n        mesh.material = new $ilwiq.MeshStandardMaterial();\n        mesh.geometry.center().scale(0.25, 0.25, 0.25).rotateX(Math.PI / 2);\n        mesh.position.set(0, 0, 0);\n        mesh.scale.set(1, 1, 1);\n        mesh.quaternion.identity();\n        const { geometry: geometry, materials: materials } = $3acf429b35a6b753$var$mergeMeshes([\n            mesh\n        ], true);\n        const merged = new $ilwiq.Mesh(geometry, new $ilwiq.MeshStandardMaterial());\n        const generator = new (0, $8todg.GenerateMeshBVHWorker)();\n        generator.generate(geometry, {\n            maxLeafTris: 1,\n            strategy: (0, $Mleu6.SAH)\n        }).then((bvh)=>{\n            $3acf429b35a6b753$var$models[\"Dragon\"] = {\n                mesh: merged,\n                materials: materials,\n                floorHeight: mesh.geometry.boundingBox.min.y\n            };\n            geometry.boundsTree = bvh;\n            generator.dispose();\n            $3acf429b35a6b753$var$scene.add(merged);\n        });\n    });\n    $3acf429b35a6b753$var$models[\"Engine\"] = null;\n    new (0, $7lx9d.GLTFLoader)().setMeshoptDecoder((0, $kp7Te.MeshoptDecoder)).load(\"../models/internal_combustion_engine/model.gltf\", (gltf)=>{\n        const originalMesh = gltf.scene.children[0];\n        const originalGeometry = originalMesh.geometry;\n        const newGeometry = new $ilwiq.BufferGeometry();\n        const ogPosAttr = originalGeometry.attributes.position;\n        const ogNormAttr = originalGeometry.attributes.normal;\n        const posAttr = new $ilwiq.BufferAttribute(new Float32Array(ogPosAttr.count * 3), 3, false);\n        const normAttr = new $ilwiq.BufferAttribute(new Float32Array(ogNormAttr.count * 3), 3, false);\n        const vec = new $ilwiq.Vector3();\n        for(let i = 0, l = ogPosAttr.count; i < l; i++){\n            vec.fromBufferAttribute(ogPosAttr, i);\n            posAttr.setXYZ(i, vec.x, vec.y, vec.z);\n            vec.fromBufferAttribute(ogNormAttr, i);\n            vec.multiplyScalar(1 / 127);\n            normAttr.setXYZ(i, vec.x, vec.y, vec.z);\n        }\n        originalMesh.scale.multiplyScalar(5);\n        originalMesh.updateMatrixWorld();\n        newGeometry.setAttribute(\"position\", posAttr);\n        newGeometry.setAttribute(\"normal\", normAttr);\n        newGeometry.setAttribute(\"materialIndex\", new $ilwiq.BufferAttribute(new Uint8Array(posAttr.count), 1, false));\n        newGeometry.setIndex(originalGeometry.index);\n        newGeometry.applyMatrix4(originalMesh.matrixWorld).center();\n        newGeometry.computeBoundingBox();\n        const mesh = new $ilwiq.Mesh(newGeometry, new $ilwiq.MeshStandardMaterial());\n        const generator = new (0, $8todg.GenerateMeshBVHWorker)();\n        generator.generate(newGeometry, {\n            maxLeafTris: 1,\n            strategy: (0, $Mleu6.CENTER)\n        }).then((bvh)=>{\n            $3acf429b35a6b753$var$models[\"Engine\"] = {\n                mesh: mesh,\n                materials: [\n                    new $ilwiq.MeshStandardMaterial()\n                ],\n                floorHeight: newGeometry.boundingBox.min.y\n            };\n            newGeometry.boundsTree = bvh;\n            generator.dispose();\n            $3acf429b35a6b753$var$scene.add(mesh);\n        });\n    });\n    $3acf429b35a6b753$var$samples = 0;\n    $3acf429b35a6b753$var$clock = new $ilwiq.Clock();\n    const gui = new (0, $jiuw3.GUI)();\n    gui.add($3acf429b35a6b753$var$params, \"model\", Object.keys($3acf429b35a6b753$var$models)).onChange($3acf429b35a6b753$var$resetImage);\n    const resolutionFolder = gui.addFolder(\"resolution\");\n    resolutionFolder.add($3acf429b35a6b753$var$params.resolution, \"resolutionScale\", 0.1, 1, 0.01).onChange($3acf429b35a6b753$var$onResize);\n    resolutionFolder.add($3acf429b35a6b753$var$params.resolution, \"smoothImageScaling\").onChange($3acf429b35a6b753$var$onResize);\n    resolutionFolder.add($3acf429b35a6b753$var$params.resolution, \"stretchImage\").onChange($3acf429b35a6b753$var$onResize);\n    resolutionFolder.open();\n    const pathTracingFolder = gui.addFolder(\"path tracing\");\n    pathTracingFolder.add($3acf429b35a6b753$var$params.pathTracing, \"pause\");\n    pathTracingFolder.add($3acf429b35a6b753$var$params.pathTracing, \"displayScanLine\").onChange((v)=>{\n        $3acf429b35a6b753$var$scanLineElement.style.visibility = v ? \"visible\" : \"hidden\";\n    });\n    pathTracingFolder.add($3acf429b35a6b753$var$params.pathTracing, \"antialiasing\").onChange($3acf429b35a6b753$var$resetImage);\n    pathTracingFolder.add($3acf429b35a6b753$var$params.pathTracing, \"directLightSampling\").onChange($3acf429b35a6b753$var$resetImage);\n    pathTracingFolder.add($3acf429b35a6b753$var$params.pathTracing, \"smoothNormals\").onChange($3acf429b35a6b753$var$resetImage);\n    pathTracingFolder.add($3acf429b35a6b753$var$params.pathTracing, \"bounces\", 1, 50, 1).onChange($3acf429b35a6b753$var$resetImage);\n    pathTracingFolder.add($3acf429b35a6b753$var$params.pathTracing, \"filterGlossyFactor\", 0, 1, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    pathTracingFolder.open();\n    const materialFolder = gui.addFolder(\"model\");\n    materialFolder.addColor($3acf429b35a6b753$var$params.material, \"color\").onChange($3acf429b35a6b753$var$resetImage);\n    materialFolder.addColor($3acf429b35a6b753$var$params.material, \"emissive\").onChange($3acf429b35a6b753$var$resetImage);\n    materialFolder.add($3acf429b35a6b753$var$params.material, \"emissiveIntensity\", 0, 5, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    materialFolder.add($3acf429b35a6b753$var$params.material, \"roughness\", 0, 1.0, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    materialFolder.add($3acf429b35a6b753$var$params.material, \"metalness\", 0, 1.0, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    materialFolder.add($3acf429b35a6b753$var$params.material, \"transmission\", 0, 1.0, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    materialFolder.add($3acf429b35a6b753$var$params.material, \"ior\", 1.0, 2.5, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    materialFolder.open();\n    const floorFolder = gui.addFolder(\"floor\");\n    floorFolder.add($3acf429b35a6b753$var$params.floor, \"enable\").onChange($3acf429b35a6b753$var$resetImage);\n    floorFolder.addColor($3acf429b35a6b753$var$params.floor, \"color\").onChange($3acf429b35a6b753$var$resetImage);\n    floorFolder.add($3acf429b35a6b753$var$params.floor, \"roughness\", 0, 1, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    floorFolder.add($3acf429b35a6b753$var$params.floor, \"metalness\", 0, 1, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    floorFolder.add($3acf429b35a6b753$var$params.floor, \"width\", 3, 20, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    floorFolder.add($3acf429b35a6b753$var$params.floor, \"height\", 3, 20, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    const lightFolder = gui.addFolder(\"light\");\n    lightFolder.add($3acf429b35a6b753$var$params.light, \"enable\").onChange($3acf429b35a6b753$var$resetImage);\n    lightFolder.addColor($3acf429b35a6b753$var$params.light, \"color\").onChange($3acf429b35a6b753$var$resetImage);\n    lightFolder.add($3acf429b35a6b753$var$params.light, \"intensity\", 0, 100, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    lightFolder.add($3acf429b35a6b753$var$params.light, \"width\", 0, 5, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    lightFolder.add($3acf429b35a6b753$var$params.light, \"height\", 0, 5, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    lightFolder.add($3acf429b35a6b753$var$params.light, \"position\", [\n        \"Diagonal\",\n        \"Above\",\n        \"Below\"\n    ]).onChange($3acf429b35a6b753$var$resetImage);\n    const envFolder = gui.addFolder(\"environment\");\n    envFolder.add($3acf429b35a6b753$var$params.environment, \"skyMode\", [\n        \"sky\",\n        \"sun\",\n        \"checkerboard\"\n    ]).onChange($3acf429b35a6b753$var$resetImage);\n    envFolder.add($3acf429b35a6b753$var$params.environment, \"skyIntensity\", 0, 5, 0.001).onChange($3acf429b35a6b753$var$resetImage);\n    $3acf429b35a6b753$var$onResize();\n}\n// Merges meshes into a single geometry, returns a series of materials and geometry with a vertex attribute buffer\n// containing information about the material index to use\nfunction $3acf429b35a6b753$var$mergeMeshes(meshes, cloneGeometry = true) {\n    const transformedGeometry = [];\n    const materials = [];\n    for(let i = 0, l = meshes.length; i < l; i++){\n        const mesh = meshes[i];\n        const originalGeometry = meshes[i].geometry;\n        const geom = cloneGeometry ? originalGeometry.clone() : cloneGeometry;\n        mesh.updateMatrixWorld();\n        geom.applyMatrix4(mesh.matrixWorld);\n        const vertexCount = geom.attributes.position.count;\n        const materialIndexArray = new Uint8Array(vertexCount).fill(i);\n        geom.setAttribute(\"materialIndex\", new $ilwiq.BufferAttribute(materialIndexArray, 1, false));\n        transformedGeometry.push(geom);\n        materials.push(mesh.material);\n    }\n    const geometry = $7ePFa.mergeBufferGeometries(transformedGeometry, false);\n    return {\n        geometry: geometry,\n        materials: materials\n    };\n}\nfunction $3acf429b35a6b753$var$onResize() {\n    function resizeDataTexture(w, h) {\n        if (!$3acf429b35a6b753$var$dataTexture || $3acf429b35a6b753$var$dataTexture.image.width !== w || $3acf429b35a6b753$var$dataTexture.image.height !== h) {\n            if ($3acf429b35a6b753$var$dataTexture) $3acf429b35a6b753$var$dataTexture.dispose();\n            $3acf429b35a6b753$var$dataTexture = new $ilwiq.DataTexture(new Float32Array(w * h * 4), w, h, $ilwiq.RGBAFormat, $ilwiq.FloatType);\n            $3acf429b35a6b753$var$resetImage();\n        }\n    }\n    $3acf429b35a6b753$var$camera.aspect = window.innerWidth / window.innerHeight;\n    $3acf429b35a6b753$var$camera.updateProjectionMatrix();\n    // compute the new resolution based on the use parameters\n    const dpr = window.devicePixelRatio;\n    const resolutionScale = $3acf429b35a6b753$var$params.resolution.resolutionScale;\n    if ($3acf429b35a6b753$var$params.resolution.stretchImage) {\n        $3acf429b35a6b753$var$containerElement.style.width = `${window.innerWidth}px`;\n        $3acf429b35a6b753$var$containerElement.style.height = `${window.innerHeight}px`;\n        $3acf429b35a6b753$var$renderer.setSize(window.innerWidth, window.innerHeight);\n        $3acf429b35a6b753$var$renderer.setPixelRatio(dpr * resolutionScale);\n        resizeDataTexture(Math.floor(window.innerWidth * dpr * resolutionScale), Math.floor(window.innerHeight * dpr * resolutionScale));\n    } else {\n        $3acf429b35a6b753$var$containerElement.style.width = `${window.innerWidth * resolutionScale}px`;\n        $3acf429b35a6b753$var$containerElement.style.height = `${window.innerHeight * resolutionScale}px`;\n        $3acf429b35a6b753$var$renderer.setSize(Math.floor(window.innerWidth * resolutionScale), Math.floor(window.innerHeight * resolutionScale));\n        $3acf429b35a6b753$var$renderer.setPixelRatio(dpr);\n        resizeDataTexture(Math.floor(window.innerWidth * dpr * resolutionScale), Math.floor(window.innerHeight * dpr * resolutionScale));\n    }\n    $3acf429b35a6b753$var$renderer.domElement.style.imageRendering = $3acf429b35a6b753$var$params.resolution.smoothImageScaling ? \"auto\" : \"pixelated\";\n}\nfunction $3acf429b35a6b753$var$resetImage() {\n    // clear the draw buffer and restart the path tracing loop\n    $3acf429b35a6b753$var$dataTexture.image.data.fill(0);\n    $3acf429b35a6b753$var$dataTexture.needsUpdate = true;\n    $3acf429b35a6b753$var$samples = 0;\n    $3acf429b35a6b753$var$task = $3acf429b35a6b753$var$runPathTracingLoop();\n    $3acf429b35a6b753$var$delay = 0;\n    $3acf429b35a6b753$var$scanLineElement.style.visibility = \"hidden\";\n    $3acf429b35a6b753$var$scanLinePercent = 100;\n    $3acf429b35a6b753$var$lightMesh.scale.set($3acf429b35a6b753$var$params.light.width, $3acf429b35a6b753$var$params.light.height, 1);\n    $3acf429b35a6b753$var$lightMesh.material.color.set($3acf429b35a6b753$var$params.light.color).multiplyScalar($3acf429b35a6b753$var$params.light.intensity);\n    $3acf429b35a6b753$var$lightMesh.visible = $3acf429b35a6b753$var$params.light.enable;\n    $3acf429b35a6b753$var$floorMesh.scale.set($3acf429b35a6b753$var$params.floor.width, $3acf429b35a6b753$var$params.floor.height, 1);\n    $3acf429b35a6b753$var$floorMesh.material.color.set($3acf429b35a6b753$var$params.floor.color);\n    $3acf429b35a6b753$var$floorMesh.material.roughness = Math.pow($3acf429b35a6b753$var$params.floor.roughness, 2.0); // perceptual roughness\n    $3acf429b35a6b753$var$floorMesh.material.metalness = $3acf429b35a6b753$var$params.floor.metalness;\n    $3acf429b35a6b753$var$floorMesh.visible = $3acf429b35a6b753$var$params.floor.enable;\n}\nfunction* $3acf429b35a6b753$var$runPathTracingLoop() {\n    // extract options\n    const { width: width, height: height, data: data } = $3acf429b35a6b753$var$dataTexture.image;\n    const bounces = parseInt($3acf429b35a6b753$var$params.pathTracing.bounces);\n    const skyIntensity = parseFloat($3acf429b35a6b753$var$params.environment.skyIntensity);\n    const skyMode = $3acf429b35a6b753$var$params.environment.skyMode;\n    const smoothNormals = $3acf429b35a6b753$var$params.pathTracing.smoothNormals;\n    // reusable variables\n    const radianceColor = new $ilwiq.Color();\n    const throughputColor = new $ilwiq.Color();\n    const halfVector = new $ilwiq.Vector3();\n    const normal = new $ilwiq.Vector3();\n    const ssPoint = new $ilwiq.Vector2();\n    const rayStack = new Array(bounces).fill().map(()=>new $ilwiq.Ray());\n    const lightForward = new $ilwiq.Vector3(0, 0, 1).transformDirection($3acf429b35a6b753$var$lightMesh.matrixWorld);\n    const lightWidth = $3acf429b35a6b753$var$lightMesh.scale.x;\n    const lightHeight = $3acf429b35a6b753$var$lightMesh.scale.y;\n    const raycaster = new $ilwiq.Raycaster();\n    raycaster.firstHitOnly = true;\n    const seedRay = new $ilwiq.Ray();\n    const sampleInfo = {\n        pdf: 0,\n        color: new $ilwiq.Color(),\n        direction: new $ilwiq.Vector3()\n    };\n    // initialization of progress variables\n    let lastStartTime = performance.now();\n    $3acf429b35a6b753$var$renderStartTime = performance.now();\n    $3acf429b35a6b753$var$computationTime = 0;\n    $3acf429b35a6b753$var$scanLinePercent = 100;\n    $3acf429b35a6b753$var$scanLineElement.style.visibility = $3acf429b35a6b753$var$params.pathTracing.displayScanLine ? \"visible\" : \"hidden\";\n    // ensure the materials are all set to double side for transmissive rendering\n    $3acf429b35a6b753$var$mesh.material.side = $ilwiq.DoubleSide;\n    $3acf429b35a6b753$var$materials.forEach((material)=>{\n        material.side = $ilwiq.DoubleSide;\n    });\n    while(true){\n        let randomOffsetX = 0;\n        let randomOffsetY = 0;\n        if ($3acf429b35a6b753$var$params.pathTracing.antialiasing) {\n            const antiAliasIndex = $3acf429b35a6b753$var$samples % (0, $c526280960e2adb4$export$83cca5794a482c0).length;\n            [randomOffsetX, randomOffsetY] = (0, $c526280960e2adb4$export$83cca5794a482c0)[antiAliasIndex];\n            randomOffsetX = randomOffsetX / (0, $c526280960e2adb4$export$16687fcdb041a226) / width;\n            randomOffsetY = randomOffsetY / (0, $c526280960e2adb4$export$16687fcdb041a226) / height;\n        }\n        for(let y = height - 1; y >= 0; y--)for(let x = 0; x < width; x++){\n            // get the camera ray\n            ssPoint.set(randomOffsetX + x / (width - 1), randomOffsetY + y / (height - 1));\n            raycaster.setFromCamera({\n                x: ssPoint.x * 2 - 1,\n                y: ssPoint.y * 2 - 1\n            }, $3acf429b35a6b753$var$camera);\n            // get the camera look direction\n            $3acf429b35a6b753$var$tempVector.set(0, 0, -1).transformDirection($3acf429b35a6b753$var$camera.matrixWorld);\n            // copy the ray to the starting ray to pass into the pathTrace function and adjust it\n            // so ti starts at the camera near clip plane\n            seedRay.direction.copy(raycaster.ray.direction);\n            seedRay.origin.copy(raycaster.ray.origin).addScaledVector(raycaster.ray.direction, $3acf429b35a6b753$var$camera.near / raycaster.ray.direction.dot($3acf429b35a6b753$var$tempVector));\n            // run the path trace\n            radianceColor.set(0);\n            pathTrace(seedRay, radianceColor);\n            // accumulate a rolling average color into the data texture\n            const index = (y * width + x) * 4;\n            const r = data[index + 0];\n            const g = data[index + 1];\n            const b = data[index + 2];\n            data[index + 0] += (radianceColor.r - r) / ($3acf429b35a6b753$var$samples + 1);\n            data[index + 1] += (radianceColor.g - g) / ($3acf429b35a6b753$var$samples + 1);\n            data[index + 2] += (radianceColor.b - b) / ($3acf429b35a6b753$var$samples + 1);\n            data[index + 3] = 1.0;\n            // if we've rendered for ~16ms then wait for the next tick\n            const delta = performance.now() - lastStartTime;\n            if (delta > 16) {\n                $3acf429b35a6b753$var$computationTime += delta;\n                $3acf429b35a6b753$var$scanLinePercent = 100 * y / height;\n                yield;\n                lastStartTime = performance.now();\n            }\n        }\n        $3acf429b35a6b753$var$samples++;\n    }\n    // extract other necessary information from the hit\n    function expandHitInformation(hit, ray, accumulatedRoughness) {\n        const object = hit.object;\n        const posAttr = object.geometry.attributes.position;\n        const normalAttr = object.geometry.attributes.normal;\n        const materialAttr = object.geometry.attributes.materialIndex;\n        const face = hit.face;\n        const geometryNormal = hit.face.normal;\n        if (smoothNormals) {\n            const point = hit.point;\n            $3acf429b35a6b753$var$triangle.a.fromBufferAttribute(posAttr, face.a);\n            $3acf429b35a6b753$var$triangle.b.fromBufferAttribute(posAttr, face.b);\n            $3acf429b35a6b753$var$triangle.c.fromBufferAttribute(posAttr, face.c);\n            $3acf429b35a6b753$var$normal0.fromBufferAttribute(normalAttr, face.a);\n            $3acf429b35a6b753$var$normal1.fromBufferAttribute(normalAttr, face.b);\n            $3acf429b35a6b753$var$normal2.fromBufferAttribute(normalAttr, face.c);\n            $3acf429b35a6b753$var$triangle.getBarycoord(point, $3acf429b35a6b753$var$barycoord);\n            normal.setScalar(0).addScaledVector($3acf429b35a6b753$var$normal0, $3acf429b35a6b753$var$barycoord.x).addScaledVector($3acf429b35a6b753$var$normal1, $3acf429b35a6b753$var$barycoord.y).addScaledVector($3acf429b35a6b753$var$normal2, $3acf429b35a6b753$var$barycoord.z).normalize();\n        } else normal.copy(geometryNormal);\n        geometryNormal.transformDirection(object.matrixWorld);\n        normal.transformDirection(object.matrixWorld);\n        const hitFrontFace = geometryNormal.dot(ray.direction) < 0;\n        if (!hitFrontFace) {\n            normal.multiplyScalar(-1);\n            geometryNormal.multiplyScalar(-1);\n        }\n        let material = object.material;\n        if (materialAttr) {\n            const materialIndex = materialAttr.getX(face.a);\n            material = $3acf429b35a6b753$var$materials[materialIndex];\n        }\n        hit.material = material;\n        hit.normal = normal;\n        hit.geometryNormal = geometryNormal;\n        hit.frontFace = hitFrontFace;\n        // compute the filtered roughness value to use during specular reflection computations. A minimum\n        // value of 1e-6 is needed because the GGX functions do not work with a roughness value of 0 and\n        // the accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n        hit.filteredSurfaceRoughness = Math.min(Math.max(1e-6, material.roughness, accumulatedRoughness * $3acf429b35a6b753$var$params.pathTracing.filterGlossyFactor * 5.0), 1.0);\n    }\n    // trace a path starting at the given ray\n    function pathTrace(ray, targetColor) {\n        let currentRay = ray;\n        let lastPdf = 0;\n        let accumulatedRoughness = 0;\n        throughputColor.set(0xffffff);\n        for(let i = 0; i < bounces; i++){\n            // get the ray intersection\n            let hit = null;\n            raycaster.ray.copy(currentRay);\n            const objects = [\n                $3acf429b35a6b753$var$mesh\n            ];\n            if ($3acf429b35a6b753$var$params.light.enable) objects.push($3acf429b35a6b753$var$lightMesh);\n            if ($3acf429b35a6b753$var$params.floor.enable) objects.push($3acf429b35a6b753$var$floorMesh);\n            hit = raycaster.intersectObjects(objects, true)[0];\n            // check if we hit the light or the model\n            if (hit) {\n                if (hit.object === $3acf429b35a6b753$var$lightMesh) {\n                    // only add light on one side\n                    if (i === 0) {\n                        const lightColor = $3acf429b35a6b753$var$lightMesh.material.color;\n                        targetColor.r = Math.min(lightColor.r, 1.0);\n                        targetColor.g = Math.min(lightColor.g, 1.0);\n                        targetColor.b = Math.min(lightColor.b, 1.0);\n                    } else if (currentRay.direction.dot(lightForward) < 0) {\n                        // only add light on one side\n                        const lightDistSq = hit.distance * hit.distance;\n                        const lightArea = lightWidth * lightHeight;\n                        const lightPdf = lightDistSq / (lightArea * -currentRay.direction.dot(lightForward));\n                        const weight = lastPdf / (lastPdf + lightPdf);\n                        targetColor.r += weight * throughputColor.r * $3acf429b35a6b753$var$lightMesh.material.color.r;\n                        targetColor.g += weight * throughputColor.g * $3acf429b35a6b753$var$lightMesh.material.color.g;\n                        targetColor.b += weight * throughputColor.b * $3acf429b35a6b753$var$lightMesh.material.color.b;\n                    }\n                    break;\n                } else {\n                    expandHitInformation(hit, currentRay, accumulatedRoughness);\n                    const { material: material } = hit;\n                    const nextRay = rayStack[i];\n                    // get the local normal frame\n                    (0, $c526280960e2adb4$export$4d7afc9e2770a1ec)(hit.normal, $3acf429b35a6b753$var$normalBasis);\n                    $3acf429b35a6b753$var$invBasis.copy($3acf429b35a6b753$var$normalBasis).invert();\n                    /* Direct Light Sampling */ if ($3acf429b35a6b753$var$params.light.enable) {\n                        // get a random point on the surface of the light\n                        $3acf429b35a6b753$var$tempVector.set(Math.random() - 0.5, Math.random() - 0.5, 0).applyMatrix4($3acf429b35a6b753$var$lightMesh.matrixWorld);\n                        // get a ray to the light point\n                        // note that the ray always starts on the front side of the face implying that transmissive\n                        // contributions are not included here.\n                        nextRay.origin.copy(hit.point).addScaledVector(hit.geometryNormal, (0, $c526280960e2adb4$export$fd293b15f47e270));\n                        nextRay.direction.subVectors($3acf429b35a6b753$var$tempVector, nextRay.origin).normalize();\n                        if (nextRay.direction.dot(lightForward) < 0 && (0, $c526280960e2adb4$export$c4618275c5af62bc)(nextRay.direction, hit.normal, hit.geometryNormal)) {\n                            // compute the probability of hitting the light on the hemisphere\n                            const lightArea = lightWidth * lightHeight;\n                            const lightDistSq = nextRay.origin.distanceToSquared($3acf429b35a6b753$var$tempVector);\n                            const lightPdf = lightDistSq / (lightArea * -nextRay.direction.dot(lightForward));\n                            raycaster.ray.copy(nextRay);\n                            const shadowHit = raycaster.intersectObjects(objects, true)[0];\n                            if (shadowHit && shadowHit.object === $3acf429b35a6b753$var$lightMesh) {\n                                // get the incoming and outgoing directions in the normal frame\n                                $3acf429b35a6b753$var$localDirection.copy(currentRay.direction).applyMatrix4($3acf429b35a6b753$var$invBasis).multiplyScalar(-1).normalize();\n                                $3acf429b35a6b753$var$tempVector.copy(nextRay.direction).applyMatrix4($3acf429b35a6b753$var$invBasis).normalize();\n                                $3acf429b35a6b753$var$localDirection.normalize();\n                                // get the material color and pdf\n                                (0, $1b31943f275a7345$export$f582f72c7e832743)($3acf429b35a6b753$var$localDirection, $3acf429b35a6b753$var$tempVector, material, hit, $3acf429b35a6b753$var$tempColor);\n                                // add light contribution to the final color\n                                const materialPdf = (0, $1b31943f275a7345$export$b238c09be3ebd1a7)($3acf429b35a6b753$var$localDirection, $3acf429b35a6b753$var$tempVector, material, hit);\n                                const misWeight = lightPdf / (materialPdf + lightPdf);\n                                targetColor.r += $3acf429b35a6b753$var$lightMesh.material.color.r * throughputColor.r * $3acf429b35a6b753$var$tempColor.r * misWeight / lightPdf;\n                                targetColor.g += $3acf429b35a6b753$var$lightMesh.material.color.g * throughputColor.g * $3acf429b35a6b753$var$tempColor.g * misWeight / lightPdf;\n                                targetColor.b += $3acf429b35a6b753$var$lightMesh.material.color.b * throughputColor.b * $3acf429b35a6b753$var$tempColor.b * misWeight / lightPdf;\n                            }\n                        }\n                    }\n                    /* BSDF Sampling */ // compute the outgoing vector (towards the camera) to feed into the bsdf to get the\n                    // incident light vector.\n                    $3acf429b35a6b753$var$localDirection.copy(currentRay.direction).applyMatrix4($3acf429b35a6b753$var$invBasis).multiplyScalar(-1).normalize();\n                    // sample the surface to get the pdf, reflected color, and direction\n                    (0, $1b31943f275a7345$export$98d4fd8b0924db66)($3acf429b35a6b753$var$localDirection, hit, material, sampleInfo);\n                    // accumulate a roughness based on the sin of the half vector with the surface normal which\n                    // can be used with subsequent ray bounces to avoid fireflies similar to Blender functionality\n                    halfVector.addVectors($3acf429b35a6b753$var$localDirection, sampleInfo.direction).normalize();\n                    accumulatedRoughness += Math.sin(Math.acos(halfVector.z));\n                    // transform ray back to world frame and offset from surface\n                    nextRay.direction.copy(sampleInfo.direction).applyMatrix4($3acf429b35a6b753$var$normalBasis).normalize();\n                    const isBelowSurface = nextRay.direction.dot(hit.geometryNormal) < 0;\n                    nextRay.origin.copy(hit.point).addScaledVector(hit.geometryNormal, isBelowSurface ? -(0, $c526280960e2adb4$export$fd293b15f47e270) : (0, $c526280960e2adb4$export$fd293b15f47e270));\n                    // emission contribution\n                    const { emissive: emissive, emissiveIntensity: emissiveIntensity } = material;\n                    targetColor.r += emissiveIntensity * emissive.r * throughputColor.r;\n                    targetColor.g += emissiveIntensity * emissive.g * throughputColor.g;\n                    targetColor.b += emissiveIntensity * emissive.b * throughputColor.b;\n                    // If our PDF indicates there's a less than 0 probability of sampling this new direction then\n                    // don't include it in our sampling and terminate the ray modeling that the ray has been absorbed.\n                    if (sampleInfo.pdf <= 0 || !(0, $c526280960e2adb4$export$c4618275c5af62bc)(nextRay.direction, hit.normal, hit.geometryNormal)) break;\n                    sampleInfo.color.multiplyScalar(1 / sampleInfo.pdf);\n                    throughputColor.multiply(sampleInfo.color);\n                    currentRay = nextRay;\n                    lastPdf = sampleInfo.pdf;\n                }\n            } else {\n                // TODO: is this contribution supposed to be weighted with multiple importance sampling, as well?\n                sampleSkyBox(currentRay.direction, $3acf429b35a6b753$var$tempColor);\n                $3acf429b35a6b753$var$tempColor.multiply(throughputColor);\n                targetColor.add($3acf429b35a6b753$var$tempColor);\n                break;\n            }\n        }\n    }\n    // sample the skybox in the given direction and put the sampled color into \"target\"\n    function sampleSkyBox(direction, target) {\n        if (skyMode === \"checkerboard\") {\n            $3acf429b35a6b753$var$spherical.setFromVector3(direction);\n            const angleStep = Math.PI / 10;\n            const thetaEven = Math.floor($3acf429b35a6b753$var$spherical.theta / angleStep) % 2 === 0;\n            const phiEven = Math.floor($3acf429b35a6b753$var$spherical.phi / angleStep) % 2 === 0;\n            const isBlack = thetaEven === phiEven;\n            target.set(isBlack ? 0 : 0xffffff).multiplyScalar(1.5);\n            target.multiplyScalar(skyIntensity);\n        } else if (skyMode === \"sun\") {\n            $3acf429b35a6b753$var$normal0.setScalar(1).normalize();\n            let value = Math.max(0.0, direction.dot($3acf429b35a6b753$var$normal0) + 1.0) / 2.0;\n            value *= value;\n            target.r = $ilwiq.MathUtils.lerp(0.01, 0.5, value);\n            target.g = $ilwiq.MathUtils.lerp(0.01, 0.7, value);\n            target.b = $ilwiq.MathUtils.lerp(0.01, 1.0, value);\n            if (value > 0.95) {\n                let value2 = (value - 0.95) / 0.05;\n                value2 *= value2;\n                target.r = $ilwiq.MathUtils.lerp(0.5, 10.0, value2);\n                target.g = $ilwiq.MathUtils.lerp(0.7, 10.0, value2);\n                target.b = $ilwiq.MathUtils.lerp(1.0, 10.0, value2);\n            }\n            target.multiplyScalar(skyIntensity);\n        } else {\n            const value = (direction.y + 0.5) / 2.0;\n            target.r = $ilwiq.MathUtils.lerp(1.0, 0.5, value);\n            target.g = $ilwiq.MathUtils.lerp(1.0, 0.7, value);\n            target.b = $ilwiq.MathUtils.lerp(1.0, 1.0, value);\n            target.multiplyScalar(skyIntensity);\n        }\n    }\n}\nfunction $3acf429b35a6b753$var$toHumanReadableTime(ms) {\n    ms = ms || 0;\n    let seconds = ms * 1e-3;\n    const minutes = Math.floor(seconds / 60);\n    seconds = seconds - minutes * 60;\n    const minutesString = (minutes < 10 ? \"0\" : \"\") + minutes;\n    const secondsString = (seconds < 10 ? \"0\" : \"\") + seconds.toFixed(3);\n    return `${minutesString}m ${secondsString}s`;\n}\nfunction $3acf429b35a6b753$var$render() {\n    requestAnimationFrame($3acf429b35a6b753$var$render);\n    for(const key in $3acf429b35a6b753$var$models)if ($3acf429b35a6b753$var$models[key]) $3acf429b35a6b753$var$models[key].mesh.visible = false;\n    // select the model and initialize set the 0 material with the user settings\n    if ($3acf429b35a6b753$var$models[$3acf429b35a6b753$var$params.model]) {\n        const model = $3acf429b35a6b753$var$models[$3acf429b35a6b753$var$params.model];\n        model.mesh.visible = true;\n        $3acf429b35a6b753$var$mesh = model.mesh;\n        $3acf429b35a6b753$var$materials = model.materials;\n        $3acf429b35a6b753$var$floorMesh.position.y = model.floorHeight;\n        // initialize ior and transmission not present on materials already\n        $3acf429b35a6b753$var$materials.forEach((m)=>{\n            if (m.ior === undefined) m.ior = 1;\n            if (m.transmission === undefined) m.transmission = 0.0;\n        });\n        const material = $3acf429b35a6b753$var$materials[0];\n        material.color.set($3acf429b35a6b753$var$params.material.color).convertSRGBToLinear();\n        material.emissive.set($3acf429b35a6b753$var$params.material.emissive).convertSRGBToLinear();\n        material.emissiveIntensity = parseFloat($3acf429b35a6b753$var$params.material.emissiveIntensity);\n        material.ior = parseFloat($3acf429b35a6b753$var$params.material.ior);\n        material.metalness = parseFloat($3acf429b35a6b753$var$params.material.metalness);\n        material.transmission = parseFloat($3acf429b35a6b753$var$params.material.transmission);\n        // use a \"perceptualRoughness\" concept when interpreting user input\n        // https://google.github.io/filament/Filament.html#materialsystem/standardmodelsummary\n        material.roughness = Math.pow(parseFloat($3acf429b35a6b753$var$params.material.roughness), 2.0);\n        // adjust the position of the area light before rendering\n        switch($3acf429b35a6b753$var$params.light.position){\n            case \"Below\":\n                $3acf429b35a6b753$var$lightMesh.rotation.set(-Math.PI / 2, 0, 0);\n                $3acf429b35a6b753$var$lightMesh.position.set(0, model.floorHeight + 1e-3, 0);\n                break;\n            case \"Above\":\n                $3acf429b35a6b753$var$lightMesh.rotation.set(Math.PI / 2, 0, 0);\n                $3acf429b35a6b753$var$lightMesh.position.set(0, 1.999, 0);\n                break;\n            default:\n                $3acf429b35a6b753$var$lightMesh.position.set(2, 2, 2);\n                $3acf429b35a6b753$var$lightMesh.lookAt(0, 0, 0);\n                break;\n        }\n    } else {\n        $3acf429b35a6b753$var$mesh = null;\n        $3acf429b35a6b753$var$materials = null;\n        $3acf429b35a6b753$var$floorMesh.position.y = 0;\n    }\n    // Fade the path traced image in after the user stops moving the camera\n    let fade = 0;\n    if ($3acf429b35a6b753$var$delay > $3acf429b35a6b753$var$FADE_DELAY) fade = Math.min(($3acf429b35a6b753$var$delay - $3acf429b35a6b753$var$FADE_DELAY) / ($3acf429b35a6b753$var$DELAY_TIME - $3acf429b35a6b753$var$FADE_DELAY), 1.0);\n    // update the scan line\n    $3acf429b35a6b753$var$scanLineElement.style.bottom = `${$3acf429b35a6b753$var$scanLinePercent}%`;\n    if ($3acf429b35a6b753$var$params.resolution.stretchImage) $3acf429b35a6b753$var$scanLineElement.style.borderBottomWidth = `${Math.ceil(1 / $3acf429b35a6b753$var$params.resolution.resolutionScale)}px`;\n    else $3acf429b35a6b753$var$scanLineElement.style.borderBottomWidth = \"1px\";\n    // render the scene\n    $3acf429b35a6b753$var$renderer.render($3acf429b35a6b753$var$scene, $3acf429b35a6b753$var$camera);\n    $3acf429b35a6b753$var$renderer.autoClear = false;\n    // overlay the path traced image\n    $3acf429b35a6b753$var$fsQuad.material.map = $3acf429b35a6b753$var$dataTexture;\n    $3acf429b35a6b753$var$fsQuad.material.opacity = fade;\n    $3acf429b35a6b753$var$fsQuad.render($3acf429b35a6b753$var$renderer);\n    $3acf429b35a6b753$var$renderer.autoClear = true;\n    // run the path tracing\n    // world matrices are up to date because of the above render\n    if ($3acf429b35a6b753$var$mesh && !$3acf429b35a6b753$var$params.pathTracing.pause) $3acf429b35a6b753$var$task.next();\n    // force the data texture to upload now that it's changed but do it after render so the\n    // upload happens asynchronously and will be ready next frame.\n    $3acf429b35a6b753$var$dataTexture.needsUpdate = true;\n    $3acf429b35a6b753$var$renderer.compile($3acf429b35a6b753$var$fsQuad._mesh);\n    // count down the fade\n    if ($3acf429b35a6b753$var$delay < $3acf429b35a6b753$var$DELAY_TIME) $3acf429b35a6b753$var$delay += $3acf429b35a6b753$var$clock.getDelta() * 1e3;\n    $3acf429b35a6b753$var$outputContainer.innerText = `completed samples : ${$3acf429b35a6b753$var$samples}\\n` + `computation time  : ${$3acf429b35a6b753$var$toHumanReadableTime($3acf429b35a6b753$var$computationTime)}\\n` + `elapsed time      : ${$3acf429b35a6b753$var$toHumanReadableTime(performance.now() - $3acf429b35a6b753$var$renderStartTime)}`;\n}\n\n\n//# sourceMappingURL=cpuPathTracing.40b582bc.js.map\n","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\tthis.isPass = true;\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nconst _geometry = new BufferGeometry();\n_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n","import { Box3, BufferAttribute } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport { WorkerBase } from './utils/WorkerBase.js';\n\nexport class GenerateMeshBVHWorker extends WorkerBase {\n\n\tconstructor() {\n\n\t\tconst worker = new Worker( new URL( './generateMeshBVH.worker.js', import.meta.url ), { type: 'module' } );\n\t\tsuper( worker );\n\t\tthis.name = 'GenerateMeshBVHWorker';\n\n\t}\n\n\trunTask( worker, geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tif (\n\t\t\t\tgeometry.getAttribute( 'position' ).isInterleavedBufferAttribute ||\n\t\t\t\tgeometry.index && geometry.index.isInterleavedBufferAttribute\n\t\t\t) {\n\n\t\t\t\tthrow new Error( 'GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.' );\n\n\t\t\t}\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `GenerateMeshBVHWorker: ${ e.message }` ) );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.serialized ) {\n\n\t\t\t\t\tconst { serialized, position } = data;\n\t\t\t\t\tconst bvh = MeshBVH.deserialize( serialized, geometry, { setIndex: false } );\n\t\t\t\t\tconst boundsOptions = Object.assign( {\n\n\t\t\t\t\t\tsetBoundingBox: true,\n\n\t\t\t\t\t}, options );\n\n\t\t\t\t\t// we need to replace the arrays because they're neutered entirely by the\n\t\t\t\t\t// webworker transfer.\n\t\t\t\t\tgeometry.attributes.position.array = position;\n\t\t\t\t\tif ( serialized.index ) {\n\n\t\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\t\tgeometry.index.array = serialized.index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst newIndex = new BufferAttribute( serialized.index, 1, false );\n\t\t\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundsOptions.setBoundingBox ) {\n\n\t\t\t\t\t\tgeometry.boundingBox = bvh.getBoundingBox( new Box3() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( bvh );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\t\tconst position = geometry.attributes.position.array;\n\t\t\tconst transferable = [ position ];\n\t\t\tif ( index ) {\n\n\t\t\t\ttransferable.push( index );\n\n\t\t\t}\n\n\t\t\tworker.postMessage( {\n\n\t\t\t\tindex,\n\t\t\t\tposition,\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t\tgroups: [ ... geometry.groups ],\n\t\t\t\t},\n\n\t\t\t}, transferable.map( arr => arr.buffer ).filter( v => ( typeof SharedArrayBuffer === 'undefined' ) || ! ( v instanceof SharedArrayBuffer ) ) );\n\n\t\t} );\n\n\t}\n\n}\n","export class WorkerBase {\n\n\tconstructor( worker ) {\n\n\t\tthis.name = 'WorkerBase';\n\t\tthis.running = false;\n\t\tthis.worker = worker;\n\t\tthis.worker.onerror = e => {\n\n\t\t\tif ( e.message ) {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker with error \"${ e.message }\"` );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker.` );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\trunTask() {}\n\n\tgenerate( ...args ) {\n\n\t\tif ( this.running ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Already running job.' );\n\n\t\t}\n\n\t\tif ( this.worker === null ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Worker has been disposed.' );\n\n\t\t}\n\n\t\tthis.running = true;\n\n\t\tconst promise = this.runTask( this.worker, ...args );\n\t\tpromise.finally( () => {\n\n\t\t\tthis.running = false;\n\n\t\t} );\n\n\t\treturn promise;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.worker.terminate();\n\t\tthis.worker = null;\n\n\t}\n\n}\n","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(\"generateMeshBVH.worker.17f4c1c5.js\");\nmodule.exports = workerURL(url.toString(), url.origin, true);","\"use strict\";\n\nmodule.exports = function (workerUrl, origin, isESM) {\n  if (origin === self.location.origin) {\n    // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n  } else {\n    // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n    var source = isESM ? 'import ' + JSON.stringify(workerUrl) + ';' : 'importScripts(' + JSON.stringify(workerUrl) + ');';\n    return URL.createObjectURL(new Blob([source], {\n      type: 'application/javascript'\n    }));\n  }\n};","require('./helpers/bundle-manifest').register(new __parcel__URL__(\"\").toString(),JSON.parse(\"[\\\"bTAAs\\\",\\\"cpuPathTracing.40b582bc.js\\\",\\\"6J6WW\\\",\\\"generateMeshBVH.worker.17f4c1c5.js\\\",\\\"acVmZ\\\",\\\"generateMeshBVH.worker.aad48e6e.js\\\",\\\"gr8Yf\\\",\\\"asyncGenerate.22609466.js\\\",\\\"j19h5\\\",\\\"asyncGenerate.e8b1599c.js\\\",\\\"30Pwg\\\",\\\"asyncGenerate.77ce35af.js\\\",\\\"2tzBs\\\",\\\"characterMovement.89c1b67b.js\\\",\\\"6UuCC\\\",\\\"characterMovement.5fc59dbe.js\\\",\\\"6mMEU\\\",\\\"characterMovement.fc8349f1.js\\\",\\\"i0zVc\\\",\\\"clippedEdges.dcf40b33.js\\\"]\"));","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { bsdfSample, bsdfColor, bsdfPdf } from './pathtracing/materialSampling.js';\n\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport {\n\tacceleratedRaycast,\n\tcomputeBoundsTree,\n\tdisposeBoundsTree,\n\tSAH,\n\tCENTER,\n} from '..';\nimport {\n\tGenerateMeshBVHWorker,\n} from '../src/workers/GenerateMeshBVHWorker.js';\nimport { ANTIALIAS_OFFSETS, ANTIALIAS_WIDTH, EPSILON, getBasisFromNormal, isDirectionValid } from './pathtracing/utils.js';\n\nTHREE.Mesh.prototype.raycast = acceleratedRaycast;\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n\nlet scene, camera, renderer, light, clock;\nlet fsQuad, controls;\nlet dataTexture, samples, task, delay, scanLinePercent;\nlet scanLineElement, containerElement, outputContainer;\nlet renderStartTime, computationTime;\nlet mesh, materials, lightMesh, floorMesh;\n\n// constants\nconst DELAY_TIME = 300;\nconst FADE_DELAY = 150;\n\n// reusable fields\nconst triangle = new THREE.Triangle();\nconst normal0 = new THREE.Vector3();\nconst normal1 = new THREE.Vector3();\nconst normal2 = new THREE.Vector3();\nconst barycoord = new THREE.Vector3();\nconst spherical = new THREE.Spherical();\nconst normalBasis = new THREE.Matrix4();\nconst invBasis = new THREE.Matrix4();\nconst localDirection = new THREE.Vector3();\nconst tempColor = new THREE.Color();\nconst tempVector = new THREE.Vector3();\n\nconst models = {};\nconst params = {\n\tmodel: 'Dragon',\n\tresolution: {\n\t\tresolutionScale: 0.5,\n\t\tsmoothImageScaling: false,\n\t\tstretchImage: true,\n\t},\n\tpathTracing: {\n\t\tpause: false,\n\t\tdisplayScanLine: false,\n\t\tantialiasing: true,\n\t\tbounces: 10,\n\t\tfilterGlossyFactor: 0.5,\n\t\tsmoothNormals: true,\n\t\tdirectLightSampling: true,\n\t},\n\tmaterial: {\n\t\tcolor: '#0099ff',\n\t\temissive: '#000000',\n\t\temissiveIntensity: 1,\n\t\troughness: 0.1,\n\t\tmetalness: 0.0,\n\t\tior: 1.8,\n\t\ttransmission: 0.0,\n\t},\n\tfloor: {\n\t\tenable: true,\n\t\tcolor: '#7f7f7f',\n\t\troughness: 0.1,\n\t\tmetalness: 0.1,\n\t\twidth: 10,\n\t\theight: 10,\n\t},\n\tlight: {\n\t\tenable: true,\n\t\tposition: 'Diagonal',\n\t\tintensity: 30.0,\n\t\tcolor: '#ffffff',\n\t\twidth: 1,\n\t\theight: 1,\n\t},\n\tenvironment: {\n\t\tskyMode: 'sky',\n\t\tskyIntensity: 0.025,\n\t}\n};\n\ninit();\nrender();\n\nfunction init() {\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0, 1 );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\n\t// container of the canvas and scan line to be centered\n\tcontainerElement = document.createElement( 'div' );\n\tcontainerElement.style.position = 'absolute';\n\tcontainerElement.style.inset = '0';\n\tcontainerElement.style.margin = 'auto';\n\tcontainerElement.style.zIndex = '-1';\n\tdocument.body.appendChild( containerElement );\n\tcontainerElement.appendChild( renderer.domElement );\n\n\t// scan line element for tracking render progress\n\tscanLineElement = document.createElement( 'div' );\n\tscanLineElement.style.width = '100%';\n\tscanLineElement.style.position = 'absolute';\n\tscanLineElement.style.borderBottom = '1px solid #e91e63';\n\tscanLineElement.style.visibility = 'hidden';\n\tcontainerElement.appendChild( scanLineElement );\n\n\toutputContainer = document.getElementById( 'output' );\n\n\tfsQuad = new FullScreenQuad( new THREE.MeshBasicMaterial() );\n\tfsQuad.material.transparent = true;\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( - 2.5, 1.5, 2.5 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\t// light\n\tlight = new THREE.HemisphereLight( 0xffffff, 0x666666, 1 );\n\tscene.add( light );\n\n\tlightMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 1, 1, 1, 1 ),\n\t\tnew THREE.MeshBasicMaterial( { side: THREE.DoubleSide } ),\n\t);\n\tlightMesh.position.set( 2, 2, 2 );\n\tlightMesh.lookAt( 0, 0, 0 );\n\tscene.add( lightMesh );\n\n\tfloorMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 1, 1, 1, 1 ),\n\t\tnew THREE.MeshStandardMaterial( { side: THREE.DoubleSide } ),\n\t);\n\tfloorMesh.rotation.x = - Math.PI / 2;\n\tfloorMesh.scale.setScalar( 1 );\n\tfloorMesh.material.ior = 1.6;\n\tfloorMesh.material.transmission = 0;\n\tscene.add( floorMesh );\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.addEventListener( 'change', resetImage );\n\n\twindow.addEventListener( 'resize', onResize, false );\n\tonResize();\n\n\t// Load sphere\n\tmodels[ 'Sphere' ] = null;\n\t{\n\n\t\tconst sphereMesh = new THREE.Mesh(\n\t\t\tnew THREE.SphereGeometry( 1, 100, 50 ),\n\t\t\tnew THREE.MeshStandardMaterial(),\n\t\t);\n\n\t\tconst { geometry, materials } = mergeMeshes( [ sphereMesh ], true );\n\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\tscene.add( merged );\n\n\t\tgeometry.computeBoundsTree( { strategy: SAH, maxLeafTris: 1 } );\n\t\tmodels[ 'Sphere' ] = { mesh: merged, materials, floorHeight: - 1 };\n\n\t}\n\n\tmodels[ 'Cornell Box' ] = null;\n\t{\n\n\t\tconst planeGeom = new THREE.PlaneBufferGeometry( 1, 1, 1, 1 );\n\t\tconst leftWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0x00ee00,\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} )\n\t\t);\n\t\tleftWall.rotation.y = Math.PI / 2;\n\t\tleftWall.position.x = - 2;\n\t\tleftWall.scale.setScalar( 4 );\n\t\tleftWall.updateMatrixWorld( true );\n\n\t\tconst rightWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xee0000,\n\t\t\t} ),\n\t\t);\n\t\trightWall.rotation.y = Math.PI / 2;\n\t\trightWall.position.x = 2;\n\t\trightWall.scale.setScalar( 4 );\n\t\trightWall.updateMatrixWorld( true );\n\n\t\tconst backWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xeeeeee,\n\t\t\t} ),\n\t\t);\n\t\tbackWall.position.z = - 2;\n\t\tbackWall.scale.setScalar( 4 );\n\t\tbackWall.updateMatrixWorld( true );\n\n\t\tconst ceiling = new THREE.Mesh(\n\t\t\tplaneGeom.clone(),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xeeeeee,\n\t\t\t} ),\n\t\t);\n\t\tceiling.rotation.x = Math.PI / 2;\n\t\tceiling.position.y = 2;\n\t\tceiling.scale.setScalar( 4 );\n\t\tceiling.updateMatrixWorld( true );\n\n\t\tconst box = new THREE.Mesh(\n\t\t\tnew THREE.BoxGeometry( 1, 2, 1 ),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} ),\n\t\t);\n\t\tbox.position.y = - 1.0;\n\t\tbox.position.x = - 0.6;\n\t\tbox.position.z = - 0.25;\n\t\tbox.rotation.y = Math.PI / 4;\n\n\t\tconst box2 = new THREE.Mesh(\n\t\t\tnew THREE.BoxGeometry( 1, 1, 1 ),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} ),\n\t\t);\n\t\tbox2.position.y = - 1.5;\n\t\tbox2.position.x = 0.75;\n\t\tbox2.position.z = 0.5;\n\t\tbox2.rotation.y = - Math.PI / 8;\n\n\t\tconst { geometry, materials } = mergeMeshes( [ box, box2, leftWall, rightWall, backWall, ceiling ], true );\n\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\tscene.add( merged );\n\n\t\tgeometry.computeBoundsTree( { strategy: SAH, maxLeafTris: 1 } );\n\t\tmodels[ 'Cornell Box' ] = { mesh: merged, materials, floorHeight: - 2 };\n\n\t}\n\n\t// Load dragon\n\tmodels[ 'Dragon' ] = null;\n\tnew GLTFLoader()\n\t\t.load( '../models/DragonAttenuation.glb', gltf => {\n\n\t\t\tlet mesh;\n\t\t\tgltf.scene.traverse( c => {\n\n\t\t\t\tif ( c.isMesh && c.name === 'Dragon' ) {\n\n\t\t\t\t\tmesh = c;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tmesh.material = new THREE.MeshStandardMaterial();\n\t\t\tmesh.geometry.center().scale( 0.25, 0.25, 0.25 ).rotateX( Math.PI / 2 );\n\t\t\tmesh.position.set( 0, 0, 0 );\n\t\t\tmesh.scale.set( 1, 1, 1 );\n\t\t\tmesh.quaternion.identity();\n\n\t\t\tconst { geometry, materials } = mergeMeshes( [ mesh ], true );\n\t\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\t\tconst generator = new GenerateMeshBVHWorker();\n\t\t\tgenerator\n\t\t\t\t.generate( geometry, { maxLeafTris: 1, strategy: SAH } )\n\t\t\t\t.then( bvh => {\n\n\t\t\t\t\tmodels[ 'Dragon' ] = { mesh: merged, materials, floorHeight: mesh.geometry.boundingBox.min.y };\n\t\t\t\t\tgeometry.boundsTree = bvh;\n\t\t\t\t\tgenerator.dispose();\n\t\t\t\t\tscene.add( merged );\n\n\t\t\t\t} );\n\n\t\t} );\n\n\tmodels[ 'Engine' ] = null;\n\tnew GLTFLoader()\n\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t.load( '../models/internal_combustion_engine/model.gltf', gltf => {\n\n\t\t\tconst originalMesh = gltf.scene.children[ 0 ];\n\t\t\tconst originalGeometry = originalMesh.geometry;\n\t\t\tconst newGeometry = new THREE.BufferGeometry();\n\n\t\t\tconst ogPosAttr = originalGeometry.attributes.position;\n\t\t\tconst ogNormAttr = originalGeometry.attributes.normal;\n\t\t\tconst posAttr = new THREE.BufferAttribute( new Float32Array( ogPosAttr.count * 3 ), 3, false );\n\t\t\tconst normAttr = new THREE.BufferAttribute( new Float32Array( ogNormAttr.count * 3 ), 3, false );\n\n\t\t\tconst vec = new THREE.Vector3();\n\t\t\tfor ( let i = 0, l = ogPosAttr.count; i < l; i ++ ) {\n\n\t\t\t\tvec.fromBufferAttribute( ogPosAttr, i );\n\t\t\t\tposAttr.setXYZ( i, vec.x, vec.y, vec.z );\n\n\t\t\t\tvec.fromBufferAttribute( ogNormAttr, i );\n\t\t\t\tvec.multiplyScalar( 1 / 127 );\n\t\t\t\tnormAttr.setXYZ( i, vec.x, vec.y, vec.z );\n\n\t\t\t}\n\n\t\t\toriginalMesh.scale.multiplyScalar( 5 );\n\t\t\toriginalMesh.updateMatrixWorld();\n\t\t\tnewGeometry.setAttribute( 'position', posAttr );\n\t\t\tnewGeometry.setAttribute( 'normal', normAttr );\n\t\t\tnewGeometry.setAttribute( 'materialIndex', new THREE.BufferAttribute( new Uint8Array( posAttr.count ), 1, false ) );\n\t\t\tnewGeometry.setIndex( originalGeometry.index );\n\t\t\tnewGeometry.applyMatrix4( originalMesh.matrixWorld ).center();\n\t\t\tnewGeometry.computeBoundingBox();\n\n\t\t\tconst mesh = new THREE.Mesh( newGeometry, new THREE.MeshStandardMaterial() );\n\t\t\tconst generator = new GenerateMeshBVHWorker();\n\t\t\tgenerator\n\t\t\t\t.generate( newGeometry, { maxLeafTris: 1, strategy: CENTER } )\n\t\t\t\t.then( bvh => {\n\n\t\t\t\t\tmodels[ 'Engine' ] = {\n\t\t\t\t\t\tmesh,\n\t\t\t\t\t\tmaterials: [ new THREE.MeshStandardMaterial() ],\n\t\t\t\t\t\tfloorHeight: newGeometry.boundingBox.min.y,\n\t\t\t\t\t};\n\t\t\t\t\tnewGeometry.boundsTree = bvh;\n\t\t\t\t\tgenerator.dispose();\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t} );\n\n\tsamples = 0;\n\tclock = new THREE.Clock();\n\n\tconst gui = new GUI();\n\tgui.add( params, 'model', Object.keys( models ) ).onChange( resetImage );\n\n\tconst resolutionFolder = gui.addFolder( 'resolution' );\n\tresolutionFolder.add( params.resolution, 'resolutionScale', 0.1, 1, 0.01 ).onChange( onResize );\n\tresolutionFolder.add( params.resolution, 'smoothImageScaling' ).onChange( onResize );\n\tresolutionFolder.add( params.resolution, 'stretchImage' ).onChange( onResize );\n\tresolutionFolder.open();\n\n\tconst pathTracingFolder = gui.addFolder( 'path tracing' );\n\tpathTracingFolder.add( params.pathTracing, 'pause' );\n\tpathTracingFolder.add( params.pathTracing, 'displayScanLine' ).onChange( v => {\n\n\t\tscanLineElement.style.visibility = v ? 'visible' : 'hidden';\n\n\t} );\n\tpathTracingFolder.add( params.pathTracing, 'antialiasing' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'directLightSampling' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'smoothNormals' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'bounces', 1, 50, 1 ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'filterGlossyFactor', 0, 1, 0.001 ).onChange( resetImage );\n\tpathTracingFolder.open();\n\n\tconst materialFolder = gui.addFolder( 'model' );\n\tmaterialFolder.addColor( params.material, 'color' ).onChange( resetImage );\n\tmaterialFolder.addColor( params.material, 'emissive' ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'emissiveIntensity', 0, 5, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'roughness', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'metalness', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'transmission', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'ior', 1.0, 2.5, 0.001 ).onChange( resetImage );\n\tmaterialFolder.open();\n\n\tconst floorFolder = gui.addFolder( 'floor' );\n\tfloorFolder.add( params.floor, 'enable' ).onChange( resetImage );\n\tfloorFolder.addColor( params.floor, 'color' ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'roughness', 0, 1, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'metalness', 0, 1, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'width', 3, 20, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'height', 3, 20, 0.001 ).onChange( resetImage );\n\n\tconst lightFolder = gui.addFolder( 'light' );\n\tlightFolder.add( params.light, 'enable' ).onChange( resetImage );\n\tlightFolder.addColor( params.light, 'color' ).onChange( resetImage );\n\tlightFolder.add( params.light, 'intensity', 0, 100, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'width', 0, 5, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'height', 0, 5, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'position', [ 'Diagonal', 'Above', 'Below' ] ).onChange( resetImage );\n\n\tconst envFolder = gui.addFolder( 'environment' );\n\tenvFolder.add( params.environment, 'skyMode', [ 'sky', 'sun', 'checkerboard' ] ).onChange( resetImage );\n\tenvFolder.add( params.environment, 'skyIntensity', 0, 5, 0.001 ).onChange( resetImage );\n\n\tonResize();\n\n}\n\n// Merges meshes into a single geometry, returns a series of materials and geometry with a vertex attribute buffer\n// containing information about the material index to use\nfunction mergeMeshes( meshes, cloneGeometry = true ) {\n\n\tconst transformedGeometry = [];\n\tconst materials = [];\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\tconst mesh = meshes[ i ];\n\t\tconst originalGeometry = meshes[ i ].geometry;\n\t\tconst geom = cloneGeometry ? originalGeometry.clone() : cloneGeometry;\n\t\tmesh.updateMatrixWorld();\n\t\tgeom.applyMatrix4( mesh.matrixWorld );\n\n\t\tconst vertexCount = geom.attributes.position.count;\n\t\tconst materialIndexArray = new Uint8Array( vertexCount ).fill( i );\n\t\tgeom.setAttribute( 'materialIndex', new THREE.BufferAttribute( materialIndexArray, 1, false ) );\n\n\t\ttransformedGeometry.push( geom );\n\t\tmaterials.push( mesh.material );\n\n\t}\n\n\tconst geometry = BufferGeometryUtils.mergeBufferGeometries( transformedGeometry, false );\n\treturn { geometry, materials };\n\n}\n\nfunction onResize() {\n\n\tfunction resizeDataTexture( w, h ) {\n\n\t\tif ( ! dataTexture || dataTexture.image.width !== w || dataTexture.image.height !== h ) {\n\n\t\t\tif ( dataTexture ) {\n\n\t\t\t\tdataTexture.dispose();\n\n\t\t\t}\n\n\t\t\tdataTexture = new THREE.DataTexture( new Float32Array( w * h * 4 ), w, h, THREE.RGBAFormat, THREE.FloatType );\n\t\t\tresetImage();\n\n\t\t}\n\n\t}\n\n\tcamera.aspect = window.innerWidth / window.innerHeight;\n\tcamera.updateProjectionMatrix();\n\n\t// compute the new resolution based on the use parameters\n\tconst dpr = window.devicePixelRatio;\n\tconst resolutionScale = params.resolution.resolutionScale;\n\tif ( params.resolution.stretchImage ) {\n\n\t\tcontainerElement.style.width = `${ window.innerWidth }px`;\n\t\tcontainerElement.style.height = `${ window.innerHeight }px`;\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\trenderer.setPixelRatio( dpr * resolutionScale );\n\t\tresizeDataTexture(\n\t\t\tMath.floor( window.innerWidth * dpr * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * dpr * resolutionScale ),\n\t\t);\n\n\t} else {\n\n\t\tcontainerElement.style.width = `${ window.innerWidth * resolutionScale }px`;\n\t\tcontainerElement.style.height = `${ window.innerHeight * resolutionScale }px`;\n\t\trenderer.setSize(\n\t\t\tMath.floor( window.innerWidth * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * resolutionScale )\n\t\t);\n\t\trenderer.setPixelRatio( dpr );\n\t\tresizeDataTexture(\n\t\t\tMath.floor( window.innerWidth * dpr * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * dpr * resolutionScale ),\n\t\t);\n\n\t}\n\n\trenderer.domElement.style.imageRendering = params.resolution.smoothImageScaling ? 'auto' : 'pixelated';\n\n}\n\nfunction resetImage() {\n\n\t// clear the draw buffer and restart the path tracing loop\n\tdataTexture.image.data.fill( 0 );\n\tdataTexture.needsUpdate = true;\n\tsamples = 0;\n\ttask = runPathTracingLoop();\n\tdelay = 0;\n\tscanLineElement.style.visibility = 'hidden';\n\tscanLinePercent = 100;\n\n\tlightMesh.scale.set( params.light.width, params.light.height, 1 );\n\tlightMesh.material.color.set( params.light.color ).multiplyScalar( params.light.intensity );\n\tlightMesh.visible = params.light.enable;\n\n\tfloorMesh.scale.set( params.floor.width, params.floor.height, 1 );\n\tfloorMesh.material.color.set( params.floor.color );\n\tfloorMesh.material.roughness = Math.pow( params.floor.roughness, 2.0 ); // perceptual roughness\n\tfloorMesh.material.metalness = params.floor.metalness;\n\tfloorMesh.visible = params.floor.enable;\n\n}\n\nfunction* runPathTracingLoop() {\n\n\t// extract options\n\tconst { width, height, data } = dataTexture.image;\n\tconst bounces = parseInt( params.pathTracing.bounces );\n\tconst skyIntensity = parseFloat( params.environment.skyIntensity );\n\tconst skyMode = params.environment.skyMode;\n\tconst smoothNormals = params.pathTracing.smoothNormals;\n\n\t// reusable variables\n\tconst radianceColor = new THREE.Color();\n\tconst throughputColor = new THREE.Color();\n\tconst halfVector = new THREE.Vector3();\n\tconst normal = new THREE.Vector3();\n\tconst ssPoint = new THREE.Vector2();\n\tconst rayStack = new Array( bounces ).fill().map( () => new THREE.Ray() );\n\tconst lightForward = new THREE.Vector3( 0, 0, 1 ).transformDirection( lightMesh.matrixWorld );\n\tconst lightWidth = lightMesh.scale.x;\n\tconst lightHeight = lightMesh.scale.y;\n\tconst raycaster = new THREE.Raycaster();\n\traycaster.firstHitOnly = true;\n\n\tconst seedRay = new THREE.Ray();\n\tconst sampleInfo = {\n\t\tpdf: 0,\n\t\tcolor: new THREE.Color(),\n\t\tdirection: new THREE.Vector3(),\n\t};\n\n\t// initialization of progress variables\n\tlet lastStartTime = performance.now();\n\trenderStartTime = performance.now();\n\tcomputationTime = 0;\n\tscanLinePercent = 100;\n\tscanLineElement.style.visibility = params.pathTracing.displayScanLine ? 'visible' : 'hidden';\n\n\t// ensure the materials are all set to double side for transmissive rendering\n\tmesh.material.side = THREE.DoubleSide;\n\tmaterials.forEach( material => {\n\n\t\tmaterial.side = THREE.DoubleSide;\n\n\t} );\n\n\twhile ( true ) {\n\n\t\tlet randomOffsetX = 0;\n\t\tlet randomOffsetY = 0;\n\t\tif ( params.pathTracing.antialiasing ) {\n\n\t\t\tconst antiAliasIndex = ( samples ) % ANTIALIAS_OFFSETS.length;\n\t\t\t[ randomOffsetX, randomOffsetY ] = ANTIALIAS_OFFSETS[ antiAliasIndex ];\n\t\t\trandomOffsetX = ( randomOffsetX / ANTIALIAS_WIDTH ) / width;\n\t\t\trandomOffsetY = ( randomOffsetY / ANTIALIAS_WIDTH ) / height;\n\n\t\t}\n\n\t\tfor ( let y = height - 1; y >= 0; y -- ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t// get the camera ray\n\t\t\t\tssPoint.set( randomOffsetX + x / ( width - 1 ), randomOffsetY + y / ( height - 1 ) );\n\t\t\t\traycaster.setFromCamera( { x: ssPoint.x * 2 - 1, y: ssPoint.y * 2 - 1 }, camera );\n\n\t\t\t\t// get the camera look direction\n\t\t\t\ttempVector.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t\t// copy the ray to the starting ray to pass into the pathTrace function and adjust it\n\t\t\t\t// so ti starts at the camera near clip plane\n\t\t\t\tseedRay.direction.copy( raycaster.ray.direction );\n\t\t\t\tseedRay.origin\n\t\t\t\t\t.copy( raycaster.ray.origin )\n\t\t\t\t\t.addScaledVector( raycaster.ray.direction, camera.near / raycaster.ray.direction.dot( tempVector ) );\n\n\t\t\t\t// run the path trace\n\t\t\t\tradianceColor.set( 0 );\n\t\t\t\tpathTrace( seedRay, radianceColor );\n\n\t\t\t\t// accumulate a rolling average color into the data texture\n\t\t\t\tconst index = ( y * width + x ) * 4;\n\t\t\t\tconst r = data[ index + 0 ];\n\t\t\t\tconst g = data[ index + 1 ];\n\t\t\t\tconst b = data[ index + 2 ];\n\t\t\t\tdata[ index + 0 ] += ( radianceColor.r - r ) / ( samples + 1 );\n\t\t\t\tdata[ index + 1 ] += ( radianceColor.g - g ) / ( samples + 1 );\n\t\t\t\tdata[ index + 2 ] += ( radianceColor.b - b ) / ( samples + 1 );\n\t\t\t\tdata[ index + 3 ] = 1.0;\n\n\t\t\t\t// if we've rendered for ~16ms then wait for the next tick\n\t\t\t\tconst delta = performance.now() - lastStartTime;\n\t\t\t\tif ( delta > 16 ) {\n\n\t\t\t\t\tcomputationTime += delta;\n\t\t\t\t\tscanLinePercent = 100 * y / height;\n\n\t\t\t\t\tyield;\n\t\t\t\t\tlastStartTime = performance.now();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tsamples ++;\n\n\t}\n\n\t// extract other necessary information from the hit\n\tfunction expandHitInformation( hit, ray, accumulatedRoughness ) {\n\n\t\tconst object = hit.object;\n\t\tconst posAttr = object.geometry.attributes.position;\n\t\tconst normalAttr = object.geometry.attributes.normal;\n\t\tconst materialAttr = object.geometry.attributes.materialIndex;\n\n\t\tconst face = hit.face;\n\t\tconst geometryNormal = hit.face.normal;\n\t\tif ( smoothNormals ) {\n\n\t\t\tconst point = hit.point;\n\t\t\ttriangle.a.fromBufferAttribute( posAttr, face.a );\n\t\t\ttriangle.b.fromBufferAttribute( posAttr, face.b );\n\t\t\ttriangle.c.fromBufferAttribute( posAttr, face.c );\n\n\t\t\tnormal0.fromBufferAttribute( normalAttr, face.a );\n\t\t\tnormal1.fromBufferAttribute( normalAttr, face.b );\n\t\t\tnormal2.fromBufferAttribute( normalAttr, face.c );\n\n\t\t\ttriangle.getBarycoord( point, barycoord );\n\n\t\t\tnormal\n\t\t\t\t.setScalar( 0 )\n\t\t\t\t.addScaledVector( normal0, barycoord.x )\n\t\t\t\t.addScaledVector( normal1, barycoord.y )\n\t\t\t\t.addScaledVector( normal2, barycoord.z )\n\t\t\t\t.normalize();\n\n\t\t} else {\n\n\t\t\tnormal.copy( geometryNormal );\n\n\t\t}\n\n\t\tgeometryNormal.transformDirection( object.matrixWorld );\n\t\tnormal.transformDirection( object.matrixWorld );\n\n\t\tconst hitFrontFace = geometryNormal.dot( ray.direction ) < 0;\n\t\tif ( ! hitFrontFace ) {\n\n\t\t\tnormal.multiplyScalar( - 1 );\n\t\t\tgeometryNormal.multiplyScalar( - 1 );\n\n\t\t}\n\n\t\tlet material = object.material;\n\t\tif ( materialAttr ) {\n\n\t\t\tconst materialIndex = materialAttr.getX( face.a );\n\t\t\tmaterial = materials[ materialIndex ];\n\n\t\t}\n\n\t\thit.material = material;\n\t\thit.normal = normal;\n\t\thit.geometryNormal = geometryNormal;\n\t\thit.frontFace = hitFrontFace;\n\n\t\t// compute the filtered roughness value to use during specular reflection computations. A minimum\n\t\t// value of 1e-6 is needed because the GGX functions do not work with a roughness value of 0 and\n\t\t// the accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\thit.filteredSurfaceRoughness = Math.min(\n\t\t\tMath.max(\n\t\t\t\t1e-6,\n\t\t\t\tmaterial.roughness,\n\t\t\t\taccumulatedRoughness * params.pathTracing.filterGlossyFactor * 5.0,\n\t\t\t),\n\t\t\t1.0,\n\t\t);\n\n\n\t}\n\n\t// trace a path starting at the given ray\n\tfunction pathTrace( ray, targetColor ) {\n\n\t\tlet currentRay = ray;\n\t\tlet lastPdf = 0;\n\t\tlet accumulatedRoughness = 0;\n\t\tthroughputColor.set( 0xffffff );\n\t\tfor ( let i = 0; i < bounces; i ++ ) {\n\n\t\t\t// get the ray intersection\n\t\t\tlet hit = null;\n\t\t\traycaster.ray.copy( currentRay );\n\n\t\t\tconst objects = [ mesh ];\n\t\t\tif ( params.light.enable ) {\n\n\t\t\t\tobjects.push( lightMesh );\n\n\t\t\t}\n\n\t\t\tif ( params.floor.enable ) {\n\n\t\t\t\tobjects.push( floorMesh );\n\n\t\t\t}\n\n\t\t\thit = raycaster.intersectObjects( objects, true )[ 0 ];\n\n\t\t\t// check if we hit the light or the model\n\t\t\tif ( hit ) {\n\n\t\t\t\tif ( hit.object === lightMesh ) {\n\n\t\t\t\t\t// only add light on one side\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tconst lightColor = lightMesh.material.color;\n\t\t\t\t\t\ttargetColor.r = Math.min( lightColor.r, 1.0 );\n\t\t\t\t\t\ttargetColor.g = Math.min( lightColor.g, 1.0 );\n\t\t\t\t\t\ttargetColor.b = Math.min( lightColor.b, 1.0 );\n\n\t\t\t\t\t} else if ( currentRay.direction.dot( lightForward ) < 0 ) {\n\n\t\t\t\t\t\t// only add light on one side\n\t\t\t\t\t\tconst lightDistSq = hit.distance * hit.distance;\n\t\t\t\t\t\tconst lightArea = lightWidth * lightHeight;\n\t\t\t\t\t\tconst lightPdf = lightDistSq / ( lightArea * - currentRay.direction.dot( lightForward ) );\n\n\t\t\t\t\t\tconst weight = lastPdf / ( lastPdf + lightPdf );\n\t\t\t\t\t\ttargetColor.r += weight * throughputColor.r * lightMesh.material.color.r;\n\t\t\t\t\t\ttargetColor.g += weight * throughputColor.g * lightMesh.material.color.g;\n\t\t\t\t\t\ttargetColor.b += weight * throughputColor.b * lightMesh.material.color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\n\t\t\t\t\texpandHitInformation( hit, currentRay, accumulatedRoughness );\n\t\t\t\t\tconst { material } = hit;\n\t\t\t\t\tconst nextRay = rayStack[ i ];\n\n\t\t\t\t\t// get the local normal frame\n\t\t\t\t\tgetBasisFromNormal( hit.normal, normalBasis );\n\t\t\t\t\tinvBasis.copy( normalBasis ).invert();\n\n\t\t\t\t\t/* Direct Light Sampling */\n\t\t\t\t\tif ( params.light.enable ) {\n\n\t\t\t\t\t\t// get a random point on the surface of the light\n\t\t\t\t\t\ttempVector\n\t\t\t\t\t\t\t.set( Math.random() - 0.5, Math.random() - 0.5, 0 )\n\t\t\t\t\t\t\t.applyMatrix4( lightMesh.matrixWorld );\n\n\t\t\t\t\t\t// get a ray to the light point\n\t\t\t\t\t\t// note that the ray always starts on the front side of the face implying that transmissive\n\t\t\t\t\t\t// contributions are not included here.\n\t\t\t\t\t\tnextRay.origin.copy( hit.point ).addScaledVector( hit.geometryNormal, EPSILON );\n\t\t\t\t\t\tnextRay.direction.subVectors( tempVector, nextRay.origin ).normalize();\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnextRay.direction.dot( lightForward ) < 0\n\t\t\t\t\t\t\t&& isDirectionValid( nextRay.direction, hit.normal, hit.geometryNormal )\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// compute the probability of hitting the light on the hemisphere\n\t\t\t\t\t\t\tconst lightArea = lightWidth * lightHeight;\n\t\t\t\t\t\t\tconst lightDistSq = nextRay.origin.distanceToSquared( tempVector );\n\t\t\t\t\t\t\tconst lightPdf = lightDistSq / ( lightArea * - nextRay.direction.dot( lightForward ) );\n\n\t\t\t\t\t\t\traycaster.ray.copy( nextRay );\n\t\t\t\t\t\t\tconst shadowHit = raycaster.intersectObjects( objects, true )[ 0 ];\n\t\t\t\t\t\t\tif ( shadowHit && shadowHit.object === lightMesh ) {\n\n\t\t\t\t\t\t\t\t// get the incoming and outgoing directions in the normal frame\n\t\t\t\t\t\t\t\tlocalDirection.copy( currentRay.direction ).applyMatrix4( invBasis ).multiplyScalar( - 1 ).normalize();\n\t\t\t\t\t\t\t\ttempVector.copy( nextRay.direction ).applyMatrix4( invBasis ).normalize();\n\t\t\t\t\t\t\t\tlocalDirection.normalize();\n\n\t\t\t\t\t\t\t\t// get the material color and pdf\n\t\t\t\t\t\t\t\tbsdfColor( localDirection, tempVector, material, hit, tempColor );\n\n\t\t\t\t\t\t\t\t// add light contribution to the final color\n\t\t\t\t\t\t\t\tconst materialPdf = bsdfPdf( localDirection, tempVector, material, hit );\n\t\t\t\t\t\t\t\tconst misWeight = lightPdf / ( materialPdf + lightPdf );\n\t\t\t\t\t\t\t\ttargetColor.r += lightMesh.material.color.r * throughputColor.r * tempColor.r * misWeight / lightPdf;\n\t\t\t\t\t\t\t\ttargetColor.g += lightMesh.material.color.g * throughputColor.g * tempColor.g * misWeight / lightPdf;\n\t\t\t\t\t\t\t\ttargetColor.b += lightMesh.material.color.b * throughputColor.b * tempColor.b * misWeight / lightPdf;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* BSDF Sampling */\n\t\t\t\t\t// compute the outgoing vector (towards the camera) to feed into the bsdf to get the\n\t\t\t\t\t// incident light vector.\n\t\t\t\t\tlocalDirection.copy( currentRay.direction ).applyMatrix4( invBasis )\n\t\t\t\t\t\t.multiplyScalar( - 1 ).normalize();\n\n\t\t\t\t\t// sample the surface to get the pdf, reflected color, and direction\n\t\t\t\t\tbsdfSample( localDirection, hit, material, sampleInfo );\n\n\t\t\t\t\t// accumulate a roughness based on the sin of the half vector with the surface normal which\n\t\t\t\t\t// can be used with subsequent ray bounces to avoid fireflies similar to Blender functionality\n\t\t\t\t\thalfVector.addVectors( localDirection, sampleInfo.direction ).normalize();\n\t\t\t\t\taccumulatedRoughness += Math.sin( Math.acos( halfVector.z ) );\n\n\t\t\t\t\t// transform ray back to world frame and offset from surface\n\t\t\t\t\tnextRay.direction.copy( sampleInfo.direction ).applyMatrix4( normalBasis ).normalize();\n\n\t\t\t\t\tconst isBelowSurface = nextRay.direction.dot( hit.geometryNormal ) < 0;\n\t\t\t\t\tnextRay.origin.copy( hit.point )\n\t\t\t\t\t\t.addScaledVector( hit.geometryNormal, isBelowSurface ? - EPSILON : EPSILON );\n\n\t\t\t\t\t// emission contribution\n\t\t\t\t\tconst { emissive, emissiveIntensity } = material;\n\t\t\t\t\ttargetColor.r += ( emissiveIntensity * emissive.r * throughputColor.r );\n\t\t\t\t\ttargetColor.g += ( emissiveIntensity * emissive.g * throughputColor.g );\n\t\t\t\t\ttargetColor.b += ( emissiveIntensity * emissive.b * throughputColor.b );\n\n\t\t\t\t\t// If our PDF indicates there's a less than 0 probability of sampling this new direction then\n\t\t\t\t\t// don't include it in our sampling and terminate the ray modeling that the ray has been absorbed.\n\t\t\t\t\tif (\n\t\t\t\t\t\tsampleInfo.pdf <= 0\n\t\t\t\t\t\t|| ! isDirectionValid( nextRay.direction, hit.normal, hit.geometryNormal )\n\t\t\t\t\t) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsampleInfo.color.multiplyScalar( 1 / sampleInfo.pdf );\n\t\t\t\t\tthroughputColor.multiply( sampleInfo.color );\n\t\t\t\t\tcurrentRay = nextRay;\n\t\t\t\t\tlastPdf = sampleInfo.pdf;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: is this contribution supposed to be weighted with multiple importance sampling, as well?\n\t\t\t\tsampleSkyBox( currentRay.direction, tempColor );\n\t\t\t\ttempColor.multiply( throughputColor );\n\t\t\t\ttargetColor.add( tempColor );\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// sample the skybox in the given direction and put the sampled color into \"target\"\n\tfunction sampleSkyBox( direction, target ) {\n\n\t\tif ( skyMode === 'checkerboard' ) {\n\n\t\t\tspherical.setFromVector3( direction );\n\n\t\t\tconst angleStep = Math.PI / 10;\n\t\t\tconst thetaEven = Math.floor( spherical.theta / angleStep ) % 2 === 0;\n\t\t\tconst phiEven = Math.floor( spherical.phi / angleStep ) % 2 === 0;\n\t\t\tconst isBlack = thetaEven === phiEven;\n\t\t\ttarget.set( isBlack ? 0 : 0xffffff ).multiplyScalar( 1.5 );\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t} else if ( skyMode === 'sun' ) {\n\n\t\t\tnormal0.setScalar( 1 ).normalize();\n\n\t\t\tlet value = Math.max( 0.0, direction.dot( normal0 ) + 1.0 ) / 2.0;\n\t\t\tvalue *= value;\n\t\t\ttarget.r = THREE.MathUtils.lerp( 0.01, 0.5, value );\n\t\t\ttarget.g = THREE.MathUtils.lerp( 0.01, 0.7, value );\n\t\t\ttarget.b = THREE.MathUtils.lerp( 0.01, 1.0, value );\n\n\t\t\tif ( value > 0.95 ) {\n\n\t\t\t\tlet value2 = ( value - 0.95 ) / 0.05;\n\t\t\t\tvalue2 *= value2;\n\t\t\t\ttarget.r = THREE.MathUtils.lerp( 0.5, 10.0, value2 );\n\t\t\t\ttarget.g = THREE.MathUtils.lerp( 0.7, 10.0, value2 );\n\t\t\t\ttarget.b = THREE.MathUtils.lerp( 1.0, 10.0, value2 );\n\n\t\t\t}\n\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t} else {\n\n\t\t\tconst value = ( direction.y + 0.5 ) / 2.0;\n\t\t\ttarget.r = THREE.MathUtils.lerp( 1.0, 0.5, value );\n\t\t\ttarget.g = THREE.MathUtils.lerp( 1.0, 0.7, value );\n\t\t\ttarget.b = THREE.MathUtils.lerp( 1.0, 1.0, value );\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t}\n\n\t}\n\n}\n\nfunction toHumanReadableTime( ms ) {\n\n\tms = ms || 0;\n\n\tlet seconds = ms * 1e-3;\n\tconst minutes = Math.floor( seconds / 60 );\n\tseconds = seconds - minutes * 60;\n\n\tconst minutesString = ( minutes < 10 ? '0' : '' ) + minutes;\n\tconst secondsString = ( seconds < 10 ? '0' : '' ) + seconds.toFixed( 3 );\n\n\treturn `${ minutesString }m ${ secondsString }s`;\n\n}\n\nfunction render() {\n\n\trequestAnimationFrame( render );\n\n\tfor ( const key in models ) {\n\n\t\tif ( models[ key ] ) {\n\n\t\t\tmodels[ key ].mesh.visible = false;\n\n\t\t}\n\n\t}\n\n\t// select the model and initialize set the 0 material with the user settings\n\tif ( models[ params.model ] ) {\n\n\t\tconst model = models[ params.model ];\n\t\tmodel.mesh.visible = true;\n\t\tmesh = model.mesh;\n\t\tmaterials = model.materials;\n\t\tfloorMesh.position.y = model.floorHeight;\n\n\t\t// initialize ior and transmission not present on materials already\n\t\tmaterials.forEach( m => {\n\n\t\t\tif ( m.ior === undefined ) m.ior = 1;\n\t\t\tif ( m.transmission === undefined ) m.transmission = 0.0;\n\n\t\t} );\n\n\t\tconst material = materials[ 0 ];\n\t\tmaterial.color.set( params.material.color ).convertSRGBToLinear();\n\t\tmaterial.emissive.set( params.material.emissive ).convertSRGBToLinear();\n\t\tmaterial.emissiveIntensity = parseFloat( params.material.emissiveIntensity );\n\t\tmaterial.ior = parseFloat( params.material.ior );\n\t\tmaterial.metalness = parseFloat( params.material.metalness );\n\t\tmaterial.transmission = parseFloat( params.material.transmission );\n\n\t\t// use a \"perceptualRoughness\" concept when interpreting user input\n\t\t// https://google.github.io/filament/Filament.html#materialsystem/standardmodelsummary\n\t\tmaterial.roughness = Math.pow( parseFloat( params.material.roughness ), 2.0 );\n\n\t\t// adjust the position of the area light before rendering\n\t\tswitch ( params.light.position ) {\n\n\t\t\tcase 'Below':\n\t\t\t\tlightMesh.rotation.set( - Math.PI / 2, 0, 0 );\n\t\t\t\tlightMesh.position.set( 0, model.floorHeight + 1e-3, 0 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'Above':\n\t\t\t\tlightMesh.rotation.set( Math.PI / 2, 0, 0 );\n\t\t\t\tlightMesh.position.set( 0, 2 - 1e-3, 0 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlightMesh.position.set( 2, 2, 2 );\n\t\t\t\tlightMesh.lookAt( 0, 0, 0 );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else {\n\n\t\tmesh = null;\n\t\tmaterials = null;\n\t\tfloorMesh.position.y = 0;\n\n\t}\n\n\t// Fade the path traced image in after the user stops moving the camera\n\tlet fade = 0;\n\tif ( delay > FADE_DELAY ) {\n\n\t\tfade = Math.min( ( delay - FADE_DELAY ) / ( DELAY_TIME - FADE_DELAY ), 1.0 );\n\n\t}\n\n\t// update the scan line\n\tscanLineElement.style.bottom = `${ scanLinePercent }%`;\n\tif ( params.resolution.stretchImage ) {\n\n\t\tscanLineElement.style.borderBottomWidth = `${ Math.ceil( 1 / params.resolution.resolutionScale ) }px`;\n\n\t} else {\n\n\t\tscanLineElement.style.borderBottomWidth = '1px';\n\n\t}\n\n\t// render the scene\n\trenderer.render( scene, camera );\n\trenderer.autoClear = false;\n\n\t// overlay the path traced image\n\tfsQuad.material.map = dataTexture;\n\tfsQuad.material.opacity = fade;\n\tfsQuad.render( renderer );\n\trenderer.autoClear = true;\n\n\t// run the path tracing\n\t// world matrices are up to date because of the above render\n\tif ( mesh && ! params.pathTracing.pause ) {\n\n\t\ttask.next();\n\n\t}\n\n\t// force the data texture to upload now that it's changed but do it after render so the\n\t// upload happens asynchronously and will be ready next frame.\n\tdataTexture.needsUpdate = true;\n\trenderer.compile( fsQuad._mesh );\n\n\t// count down the fade\n\tif ( delay < DELAY_TIME ) {\n\n\t\tdelay += clock.getDelta() * 1e3;\n\n\t}\n\n\toutputContainer.innerText =\n\t\t`completed samples : ${ samples }\\n` +\n\t\t`computation time  : ${ toHumanReadableTime( computationTime ) }\\n` +\n\t\t`elapsed time      : ${ toHumanReadableTime( performance.now() - renderStartTime ) }`;\n\n}\n\n","import { schlickFresnelFromIor, refract, getHalfVector } from './utils.js';\nimport { ggxDirection, ggxPDF, ggxShadowMaskG2, ggxDistribution } from './ggxSampling.js';\nimport { MathUtils, Vector3, Color } from 'three';\n\n// Technically this value should be based on the index of refraction of the given dielectric.\nconst tempDir = new Vector3();\nconst halfVector = new Vector3();\nconst tempColor = new Color();\nconst whiteColor = new Color( 0xffffff );\n\n// diffuse\nfunction diffusePDF( wo, wi, material, hit ) {\n\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n\tconst cosValue = wi.z;\n\treturn cosValue / Math.PI;\n\n}\n\nfunction diffuseDirection( wo, hit, material, lightDirection ) {\n\n\tlightDirection.randomDirection();\n\tlightDirection.z += 1;\n\tlightDirection.normalize();\n\n}\n\nfunction diffuseColor( wo, wi, material, hit, colorTarget ) {\n\n\t// TODO: scale by 1 - F here\n\t// note on division by PI\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wi.z / Math.PI / Math.PI )\n\t\t.multiplyScalar( 1.0 - transmission );\n\n}\n\n// specular\nfunction specularPDF( wo, wi, material, hit ) {\n\n\t// See equation (17) in http://jcgt.org/published/0003/02/03/\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\tgetHalfVector( wi, wo, halfVector );\n\treturn ggxPDF( wi, halfVector, filteredRoughness ) / ( 4 * wi.dot( halfVector ) );\n\n}\n\nfunction specularDirection( wo, hit, material, lightDirection ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\tggxDirection(\n\t\two,\n\t\tfilteredRoughness,\n\t\tfilteredRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\tlightDirection.copy( wo ).reflect( halfVector ).multiplyScalar( - 1 );\n\n}\n\nfunction specularColor( wo, wi, material, hit, colorTarget ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tconst { metalness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\n\tgetHalfVector( wo, wi, halfVector );\n\tconst iorRatio = frontFace ? 1 / ior : ior;\n\tconst G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tconst D = ggxDistribution( halfVector, filteredRoughness );\n\n\tlet F = schlickFresnelFromIor( wi.dot( halfVector ), iorRatio );\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tconst cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1;\n\n\t}\n\n\tcolorTarget\n\t\t.lerpColors( whiteColor, material.color, metalness )\n\t\t.multiplyScalar( G * D / ( 4 * Math.abs( wi.z * wo.z ) ) )\n\t\t.multiplyScalar( MathUtils.lerp( F, 1.0, metalness ) )\n\t\t.multiplyScalar( wi.z ); // scale the light by the direction the light is coming in from\n\n}\n\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, hit ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfunction transmissionPDF( wo, wi, material, hit ) {\n\n\tconst { ior } = material;\n\tconst { frontFace } = hit;\n\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tlet reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tconst cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 1.0 - reflectance );\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, new Vector3( 0, 0, 1 ), ratio, lightDirection );\n\ttempDir.randomDirection().multiplyScalar( roughness );\n\tlightDirection.add( tempDir );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( 1.0 - metalness )\n\t\t.multiplyScalar( transmission );\n\n}\n\nexport function bsdfPdf( wo, wi, material, hit ) {\n\n\tconst { ior, metalness, transmission } = material;\n\tconst { frontFace } = hit;\n\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tlet reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tconst cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1;\n\n\t}\n\n\tlet spdf = 0;\n\tlet dpdf = 0;\n\tlet tpdf = 0;\n\n\tif ( wi.z < 0 ) {\n\n\t\ttpdf = transmissionPDF( wo, wi, material, hit );\n\n\t} else {\n\n\t\tspdf = specularPDF( wo, wi, material, hit );\n\t\tdpdf = diffusePDF( wo, wi, material, hit );\n\n\t}\n\n\tconst transSpecularProb = MathUtils.lerp( reflectance, 1.0, metalness );\n\tconst diffSpecularProb = 0.5 + 0.5 * metalness;\n\tconst pdf =\n\t\tspdf * transmission * transSpecularProb\n\t\t+ tpdf * transmission * ( 1.0 - transSpecularProb )\n\t\t+ spdf * ( 1.0 - transmission ) * diffSpecularProb\n\t\t+ dpdf * ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\n\treturn pdf;\n\n}\n\nexport function bsdfColor( wo, wi, material, hit, targetColor ) {\n\n\tif ( wi.z < 0 ) {\n\n\t\ttransmissionColor( wo, wi, material, hit, targetColor );\n\n\t} else {\n\n\t\tdiffuseColor( wo, wi, material, hit, targetColor );\n\t\ttargetColor.multiplyScalar( 1.0 - material.transmission );\n\n\t\tspecularColor( wo, wi, material, hit, tempColor );\n\t\ttargetColor.add( tempColor );\n\n\t}\n\n}\n\nexport function bsdfSample( wo, hit, material, sampleInfo ) {\n\n\tconst lightDirection = sampleInfo.direction;\n\tconst { ior, metalness, transmission } = material;\n\tconst { frontFace } = hit;\n\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tlet reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tconst cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1;\n\n\t}\n\n\tif ( Math.random() < transmission ) {\n\n\t\tconst specularProb = MathUtils.lerp( reflectance, 1.0, metalness );\n\t\tif ( Math.random() < specularProb ) {\n\n\t\t\tspecularDirection( wo, hit, material, lightDirection );\n\n\t\t} else {\n\n\t\t\ttransmissionDirection( wo, hit, material, lightDirection );\n\n\t\t}\n\n\t} else {\n\n\t\tconst specularProb = 0.5 + 0.5 * metalness;\n\t\tif ( Math.random() < specularProb ) {\n\n\t\t\tspecularDirection( wo, hit, material, lightDirection );\n\n\t\t} else {\n\n\t\t\tdiffuseDirection( wo, hit, material, lightDirection );\n\n\t\t}\n\n\t}\n\n\tsampleInfo.pdf = bsdfPdf( wo, lightDirection, material, hit );\n\tbsdfColor( wo, lightDirection, material, hit, sampleInfo.color );\n\n}\n\n","import { Vector3 } from 'three';\n\nconst tempVector = new Vector3();\nconst tempVector1 = new Vector3();\nconst tempVector2 = new Vector3();\n\nexport const EPSILON = 1e-7;\n\n// https://docs.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels\nexport const ANTIALIAS_WIDTH = 16;\nexport const ANTIALIAS_OFFSETS = [\n\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ],\n];\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\nexport function schlickFresnel( cosine, f0 ) {\n\n\treturn f0 + ( 1.0 - f0 ) * Math.pow( 1.0 - cosine, 5.0 );\n\n}\n\n// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\nexport function schlickFresnelFromIor( cosine, iorRatio ) {\n\n\t// Schlick approximation\n\tconst r0 = Math.pow( ( 1 - iorRatio ) / ( 1 + iorRatio ), 2 );\n\treturn schlickFresnel( cosine, r0 );\n\n}\n\nexport function refract( dir, norm, iorRatio, target ) {\n\n\t// snell's law\n\t// ior1 * sin( t1 ) = ior2 * sin( t2 )\n\tlet cosTheta = Math.min( - dir.dot( norm ), 1.0 );\n\n\ttempVector\n\t\t.copy( dir )\n\t\t.addScaledVector( norm, cosTheta )\n\t\t.multiplyScalar( iorRatio );\n\n\ttarget\n\t\t.copy( norm )\n\t\t.multiplyScalar( - Math.sqrt( Math.abs( 1.0 - tempVector.lengthSq() ) ) )\n\t\t.add( tempVector );\n\n}\n\n// forms a basis with the normal vector as Z\nexport function getBasisFromNormal( normal, targetMatrix ) {\n\n\tif ( Math.abs( normal.x ) > 0.5 ) {\n\n\t\ttempVector.set( 0, 1, 0 );\n\n\t} else {\n\n\t\ttempVector.set( 1, 0, 0 );\n\n\t}\n\n\ttempVector1.crossVectors( normal, tempVector ).normalize();\n\ttempVector2.crossVectors( normal, tempVector1 ).normalize();\n\ttargetMatrix.makeBasis( tempVector2, tempVector1, normal );\n\n}\n\nexport function getHalfVector( a, b, target ) {\n\n\treturn target.addVectors( a, b ).normalize();\n\n}\n\n// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n// we find a ray like that we ignore it to avoid artifacts.\n// This function returns if the direction is on the same side of both planes.\nexport function isDirectionValid( direction, surfaceNormal, geometryNormal ) {\n\n\tconst aboveSurfaceNormal = direction.dot( surfaceNormal ) > 0;\n\tconst aboveGeometryNormal = direction.dot( geometryNormal ) > 0;\n\treturn aboveSurfaceNormal === aboveGeometryNormal;\n\n}\n","import { Vector3 } from 'three';\n\nconst _V = new Vector3();\nconst _T1 = new Vector3();\nconst _T2 = new Vector3();\nconst _N = new Vector3();\nconst _Z_VECTOR = new Vector3( 0, 0, 1 );\nconst M_PI = Math.PI;\n\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\nexport function ggxDirection( incidentDir, roughnessX, roughnessY, random1, random2, target ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tconst V = _V.set( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ).normalize();\n\n\t// orthonormal basis\n\tconst T1 = ( V.z < 0.9999 ) ? _T1.crossVectors( V, _Z_VECTOR ).normalize() : _T1.set( 1, 0, 0 );\n\tconst T2 = _T2.crossVectors( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tconst a = 1.0 / ( 1.0 + V.z );\n\tconst r = Math.sqrt( random1 );\n\tconst phi = ( random2 < a ) ? random2 / a * M_PI : M_PI + ( random2 - a ) / ( 1.0 - a ) * M_PI;\n\tconst P1 = r * Math.cos( phi );\n\tconst P2 = r * Math.sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tT1.multiplyScalar( P1 );\n\tT2.multiplyScalar( P2 );\n\tconst N = _N.addVectors( T1, T2 ).addScaledVector( V, Math.sqrt( Math.max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) ) );\n\n\t// unstretch\n\tN.x *= roughnessX;\n\tN.y *= roughnessY;\n\tN.z = Math.max( 0.0, N.z );\n\tN.normalize();\n\n\ttarget.copy( N );\n\n\treturn target;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfunction ggxLamda( theta, roughness ) {\n\n\tconst tanTheta = Math.tan( theta );\n\tconst tanTheta2 = tanTheta * tanTheta;\n\tconst alpha2 = roughness * roughness;\n\n\tconst numerator = - 1 + Math.sqrt( 1 + alpha2 * tanTheta2 );\n\treturn numerator / 2;\n\n}\n\n// See equation (2) from reference [2]\nexport function ggxShadowMaskG1( theta, roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nexport function ggxShadowMaskG2( wi, wo, roughness ) {\n\n\tconst incidentTheta = Math.acos( wi.z );\n\tconst scatterTheta = Math.acos( wo.z );\n\treturn 1.0 / ( 1 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\nexport function ggxDistribution( halfVector, roughness ) {\n\n\t// See equation (33) from reference [0]\n\tconst a2 = roughness * roughness;\n\tconst cosTheta = halfVector.z;\n\tconst cosTheta4 = Math.pow( cosTheta, 4 );\n\n\tif ( cosTheta === 0 ) return 0;\n\n\tconst theta = Math.acos( halfVector.z );\n\tconst tanTheta = Math.tan( theta );\n\tconst tanTheta2 = Math.pow( tanTheta, 2 );\n\n\tconst denom = Math.PI * cosTheta4 * Math.pow( a2 + tanTheta2, 2 );\n\treturn a2 / denom;\n\n\t// See equation (1) from reference [2]\n\t// const { x, y, z } = halfVector;\n\t// const a2 = roughness * roughness;\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\n\t// const mult2 = mult * mult;\n\n\t// return 1.0 / Math.PI * a2 * mult2;\n\n}\n\n// See equation (3) from reference [2]\nexport function ggxPDF( wi, halfVector, roughness ) {\n\n\tconst incidentTheta = Math.acos( wi.z );\n\tconst D = ggxDistribution( halfVector, roughness );\n\tconst G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * Math.max( 0.0, wi.dot( halfVector ) ) / wi.z;\n\n}\n"],"names":["$3acf429b35a6b753$var$scene","$3acf429b35a6b753$var$camera","$3acf429b35a6b753$var$renderer","$3acf429b35a6b753$var$light","$3acf429b35a6b753$var$clock","$3acf429b35a6b753$var$fsQuad","$3acf429b35a6b753$var$dataTexture","$3acf429b35a6b753$var$samples","$3acf429b35a6b753$var$task","$3acf429b35a6b753$var$delay","$3acf429b35a6b753$var$scanLinePercent","$3acf429b35a6b753$var$scanLineElement","$3acf429b35a6b753$var$containerElement","$3acf429b35a6b753$var$outputContainer","$3acf429b35a6b753$var$renderStartTime","$3acf429b35a6b753$var$computationTime","$3acf429b35a6b753$var$mesh","$3acf429b35a6b753$var$materials","$3acf429b35a6b753$var$lightMesh","$3acf429b35a6b753$var$floorMesh","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$var$mapping","Map","baseUrl","manifest","i","length","path","$0a1d3a5a6a49de03$export$3983474c8e6e978b","$ilwiq","$0a1d3a5a6a49de03$var$_camera","OrthographicCamera","$0a1d3a5a6a49de03$var$_geometry","BufferGeometry","setAttribute","Float32BufferAttribute","constructor","material","_mesh","Mesh","dispose","geometry","render","renderer","value","$31ccd9a92979d6bb$export$a0dc2935489c814a","$31ccd9a92979d6bb$export$749bba8a65fa6d70","$31ccd9a92979d6bb$export$e0a981a7a32ddba4","$b4YKL","$ff8ed","$31ccd9a92979d6bb$var$ray","Ray","$31ccd9a92979d6bb$var$tmpInverseMatrix","Matrix4","$31ccd9a92979d6bb$var$origMeshRaycastFunc","prototype","raycast","raycaster","intersects","boundsTree","undefined","copy","matrixWorld","invert","ray","applyMatrix4","bvh","firstHitOnly","hit","convertRaycastIntersect","raycastFirst","push","hits","l","options","MeshBVH","$810f31c6ff4f494e$export$adb106eed99e8cd8","object","point","distance","distanceTo","origin","near","far","$62b3d05905f83386$export$426cc6213ad628cf","$77YCt","WorkerBase","Worker","name","runTask","worker","Promise","resolve","reject","getAttribute","isInterleavedBufferAttribute","index","onerror","message","onmessage","data","error","serialized","position","deserialize","setIndex","boundsOptions","assign","setBoundingBox","attributes","array","newIndex","BufferAttribute","boundingBox","getBoundingBox","Box3","onProgress","progress","transferable","postMessage","includedProgressCallback","Boolean","groups","map","arr","buffer","filter","SharedArrayBuffer","$5308359e4b33977a$export$8dbf7c43841b75b7","running","generate","args","promise","finally","terminate","$7ryUf","$8a4fc930af686efe$var$url","URL","url","toString","workerUrl","isESM","self","location","source","JSON","stringify","createObjectURL","Blob","type","parse","$5Rd1x","$7lx9d","$7ePFa","$RPVlj","$kp7Te","$c526280960e2adb4$var$tempVector","Vector3","$c526280960e2adb4$var$tempVector1","$c526280960e2adb4$var$tempVector2","$c526280960e2adb4$export$83cca5794a482c0","$c526280960e2adb4$export$ecd5dd9a6150ab1f","cosine","iorRatio","f0","Math","pow","$c526280960e2adb4$export$5fef809e32451cd0","a","b","target","addVectors","normalize","$c526280960e2adb4$export$c4618275c5af62bc","direction","surfaceNormal","geometryNormal","aboveSurfaceNormal","dot","$5d3bc9a671a608d4$var$_V","$5d3bc9a671a608d4$var$_T1","$5d3bc9a671a608d4$var$_T2","$5d3bc9a671a608d4$var$_N","$5d3bc9a671a608d4$var$_Z_VECTOR","$5d3bc9a671a608d4$var$M_PI","PI","$5d3bc9a671a608d4$var$ggxLamda","theta","roughness","tanTheta","tan","numerator","sqrt","alpha2","$5d3bc9a671a608d4$export$fea7bf0f85d89c60","halfVector","a2","cosTheta","z","acos","$1b31943f275a7345$var$tempDir","$1b31943f275a7345$var$halfVector","$1b31943f275a7345$var$tempColor","Color","$1b31943f275a7345$var$whiteColor","$1b31943f275a7345$var$specularDirection","wo","lightDirection","filteredRoughness","filteredSurfaceRoughness","incidentDir","roughnessX","roughnessY","random1","random2","V","x","y","T1","crossVectors","T2","r","phi","P1","cos","P2","sin","multiplyScalar","N","addScaledVector","max","random","reflect","$1b31943f275a7345$export$b238c09be3ebd1a7","wi","ior","metalness","transmission","frontFace","ratio","min","sinTheta","reflectance","spdf","dpdf","tpdf","$1b31943f275a7345$var$transmissionPDF","$1b31943f275a7345$var$specularPDF","incidentTheta","D","cosValue","transSpecularProb","MathUtils","lerp","diffSpecularProb","$1b31943f275a7345$export$f582f72c7e832743","targetColor","$1b31943f275a7345$var$transmissionColor","colorTarget","color","$1b31943f275a7345$var$diffuseColor","$1b31943f275a7345$var$specularColor","G","scatterTheta","F","lerpColors","abs","add","$jiuw3","$4h5hN","$Mleu6","$8todg","acceleratedRaycast","computeBoundsTree","disposeBoundsTree","$3acf429b35a6b753$var$triangle","Triangle","$3acf429b35a6b753$var$normal0","$3acf429b35a6b753$var$normal1","$3acf429b35a6b753$var$normal2","$3acf429b35a6b753$var$barycoord","$3acf429b35a6b753$var$spherical","Spherical","$3acf429b35a6b753$var$normalBasis","$3acf429b35a6b753$var$invBasis","$3acf429b35a6b753$var$localDirection","$3acf429b35a6b753$var$tempColor","$3acf429b35a6b753$var$tempVector","$3acf429b35a6b753$var$models","$3acf429b35a6b753$var$params","model","resolution","resolutionScale","smoothImageScaling","stretchImage","pathTracing","pause","displayScanLine","antialiasing","bounces","filterGlossyFactor","smoothNormals","directLightSampling","emissive","emissiveIntensity","floor","enable","width","height","light","intensity","environment","skyMode","skyIntensity","$3acf429b35a6b753$var$mergeMeshes","meshes","cloneGeometry","transformedGeometry","materials","mesh","originalGeometry","geom","clone","updateMatrixWorld","vertexCount","count","materialIndexArray","Uint8Array","fill","mergeBufferGeometries","$3acf429b35a6b753$var$onResize","w","h","aspect","window","innerWidth","innerHeight","updateProjectionMatrix","dpr","devicePixelRatio","style","setSize","setPixelRatio","image","DataTexture","Float32Array","RGBAFormat","FloatType","$3acf429b35a6b753$var$resetImage","domElement","imageRendering","needsUpdate","$3acf429b35a6b753$var$runPathTracingLoop","parseInt","parseFloat","radianceColor","throughputColor","normal","ssPoint","Vector2","rayStack","Array","lightForward","transformDirection","lightWidth","scale","lightHeight","Raycaster","seedRay","sampleInfo","pdf","lastStartTime","performance","now","visibility","side","DoubleSide","forEach","randomOffsetX","randomOffsetY","antiAliasIndex","setFromCamera","pathTrace","currentRay","lastPdf","accumulatedRoughness","objects","intersectObjects","lightColor","g","weight","lightDistSq","lightArea","expandHitInformation","posAttr","normalAttr","materialAttr","materialIndex","face","fromBufferAttribute","c","getBarycoord","setScalar","hitFrontFace","getX","nextRay","targetMatrix","makeBasis","subVectors","lightPdf","distanceToSquared","shadowHit","misWeight","materialPdf","$1b31943f275a7345$var$transmissionDirection","norm","dir","lengthSq","randomDirection","isBelowSurface","multiply","sampleSkyBox","setFromVector3","angleStep","thetaEven","phiEven","isBlack","value2","delta","visible","$3acf429b35a6b753$var$toHumanReadableTime","ms","seconds","minutes","secondsString","toFixed","$3acf429b35a6b753$var$init","WebGLRenderer","antialias","setClearColor","outputEncoding","sRGBEncoding","document","createElement","inset","margin","zIndex","body","appendChild","borderBottom","getElementById","FullScreenQuad","MeshBasicMaterial","transparent","Scene","PerspectiveCamera","HemisphereLight","PlaneBufferGeometry","lookAt","MeshStandardMaterial","rotation","$3acf429b35a6b753$var$controls","OrbitControls","addEventListener","SphereGeometry","merged","strategy","SAH","maxLeafTris","floorHeight","planeGeom","leftWall","rightWall","backWall","ceiling","box","BoxGeometry","box2","GLTFLoader","load","gltf","scene","traverse","isMesh","center","rotateX","quaternion","identity","generator","GenerateMeshBVHWorker","then","setMeshoptDecoder","MeshoptDecoder","originalMesh","children","newGeometry","ogPosAttr","ogNormAttr","normAttr","vec","setXYZ","computeBoundingBox","CENTER","Clock","gui","GUI","keys","onChange","resolutionFolder","addFolder","open","pathTracingFolder","materialFolder","addColor","floorFolder","lightFolder","envFolder","$3acf429b35a6b753$var$render","key","requestAnimationFrame","m","convertSRGBToLinear","fade","$3acf429b35a6b753$var$DELAY_TIME","bottom","borderBottomWidth","ceil","autoClear","opacity","next","compile","getDelta","innerText"],"version":3,"file":"cpuPathTracing.40b582bc.js.map"}