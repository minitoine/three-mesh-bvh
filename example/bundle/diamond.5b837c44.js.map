{"mappings":"A,S,E,C,C,C,E,O,O,I,C,G,O,C,S,C,E,Y,G,A,e,G,O,S,C,c,C,I,C,E,I,O,c,C,E,E,C,W,C,E,I,W,O,C,C,E,A,C,E,G,C,C,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,O,C,G,E,E,O,C,G,E,E,O,C,G,E,E,O,C,E,G,E,Q,S,C,C,C,E,E,E,O,C,mB,I,GEAO,IAAM,EAA6B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkF3C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,yB,I,GCjFM,IAAM,EAAmC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiMjD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,GClMM,IAAM,EAA8B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoN5C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,yB,I,GCjNM,IAAM,EAAmC,CAAC;;;;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","sources":["<anon>","src/gpu/BVHShaderGLSL.js","src/gpu/glsl/common_functions.glsl.js","src/gpu/glsl/bvh_distance_functions.glsl.js","src/gpu/glsl/bvh_ray_functions.glsl.js","src/gpu/glsl/bvh_struct_definitions.glsl.js","src/gpu/MeshBVHUniformStruct.js","src/gpu/VertexAttributeTexture.js"],"sourcesContent":["\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"gcCUH\", function(module, exports) {\n\nvar $b3nr3 = parcelRequire(\"b3nr3\");\n\nvar $6zfry = parcelRequire(\"6zfry\");\n\nvar $h8ZmT = parcelRequire(\"h8ZmT\");\n\nvar $fw6HR = parcelRequire(\"fw6HR\");\n$parcel$exportWildcard(module.exports, $b3nr3);\n$parcel$exportWildcard(module.exports, $6zfry);\n$parcel$exportWildcard(module.exports, $h8ZmT);\n$parcel$exportWildcard(module.exports, $fw6HR);\n\n});\nparcelRegister(\"b3nr3\", function(module, exports) {\n\n$parcel$export(module.exports, \"common_functions\", () => $80c2275096d27f80$export$25a1e84cdffa9fe9);\nconst $80c2275096d27f80$export$25a1e84cdffa9fe9 = /* glsl */ `\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n\n});\n\nparcelRegister(\"6zfry\", function(module, exports) {\n\n$parcel$export(module.exports, \"bvh_distance_functions\", () => $4c81fdb1f89608c4$export$ae4e12e8c7af5f08);\n// Distance to Point\nconst $4c81fdb1f89608c4$export$ae4e12e8c7af5f08 = /* glsl */ `\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n\n});\n\nparcelRegister(\"h8ZmT\", function(module, exports) {\n\n$parcel$export(module.exports, \"bvh_ray_functions\", () => $c7b2c978f8b5f743$export$3c2bc5470251fe4a);\nconst $c7b2c978f8b5f743$export$3c2bc5470251fe4a = /* glsl */ `\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n\n});\n\nparcelRegister(\"fw6HR\", function(module, exports) {\n\n$parcel$export(module.exports, \"bvh_struct_definitions\", () => $b4bf0beee1e6abbf$export$5e276bbaa046dbad);\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nconst $b4bf0beee1e6abbf$export$5e276bbaa046dbad = /* glsl */ `\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n\n});\n\n\nparcelRegister(\"boAbX\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHUniformStruct\", () => $84be0288c3863b1d$export$4dc20da53fccce35);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $5LGag = parcelRequire(\"5LGag\");\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n\nvar $8kAF9 = parcelRequire(\"8kAF9\");\n\nvar $aBE3W = parcelRequire(\"aBE3W\");\nclass $84be0288c3863b1d$export$4dc20da53fccce35 {\n    constructor(){\n        this.index = new (0, $5LGag.UIntVertexAttributeTexture)();\n        this.position = new (0, $5LGag.FloatVertexAttributeTexture)();\n        this.bvhBounds = new (0, $ilwiq.DataTexture)();\n        this.bvhContents = new (0, $ilwiq.DataTexture)();\n        this._cachedIndexAttr = null;\n        this.index.overrideItemSize = 3;\n    }\n    updateFrom(bvh) {\n        const { geometry: geometry } = bvh;\n        $84be0288c3863b1d$var$bvhToTextures(bvh, this.bvhBounds, this.bvhContents);\n        this.position.updateFrom(geometry.attributes.position);\n        // dereference a new index attribute if we're using indirect storage\n        if (bvh.indirect) {\n            const indirectBuffer = bvh._indirectBuffer;\n            if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== indirectBuffer.length) {\n                if (geometry.index) this._cachedIndexAttr = geometry.index.clone();\n                else {\n                    const array = (0, $aBE3W.getIndexArray)((0, $aBE3W.getVertexCount)(geometry));\n                    this._cachedIndexAttr = new (0, $ilwiq.BufferAttribute)(array, 1, false);\n                }\n            }\n            $84be0288c3863b1d$var$dereferenceIndex(geometry, indirectBuffer, this._cachedIndexAttr);\n            this.index.updateFrom(this._cachedIndexAttr);\n        } else this.index.updateFrom(geometry.index);\n    }\n    dispose() {\n        const { index: index, position: position, bvhBounds: bvhBounds, bvhContents: bvhContents } = this;\n        if (index) index.dispose();\n        if (position) position.dispose();\n        if (bvhBounds) bvhBounds.dispose();\n        if (bvhContents) bvhContents.dispose();\n    }\n}\nfunction $84be0288c3863b1d$var$dereferenceIndex(geometry, indirectBuffer, target) {\n    const unpacked = target.array;\n    const indexArray = geometry.index ? geometry.index.array : null;\n    for(let i = 0, l = indirectBuffer.length; i < l; i++){\n        const i3 = 3 * i;\n        const v3 = 3 * indirectBuffer[i];\n        for(let c = 0; c < 3; c++)unpacked[i3 + c] = indexArray ? indexArray[v3 + c] : v3 + c;\n    }\n}\nfunction $84be0288c3863b1d$var$bvhToTextures(bvh, boundsTexture, contentsTexture) {\n    const roots = bvh._roots;\n    if (roots.length !== 1) throw new Error(\"MeshBVHUniformStruct: Multi-root BVHs not supported.\");\n    const root = roots[0];\n    const uint16Array = new Uint16Array(root);\n    const uint32Array = new Uint32Array(root);\n    const float32Array = new Float32Array(root);\n    // Both bounds need two elements per node so compute the height so it's twice as long as\n    // the width so we can expand the row by two and still have a square texture\n    const nodeCount = root.byteLength / (0, $Mleu6.BYTES_PER_NODE);\n    const boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));\n    const boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);\n    const contentsDimension = Math.ceil(Math.sqrt(nodeCount));\n    const contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);\n    for(let i = 0; i < nodeCount; i++){\n        const nodeIndex32 = i * (0, $Mleu6.BYTES_PER_NODE) / 4;\n        const nodeIndex16 = nodeIndex32 * 2;\n        const boundsIndex = (0, $8kAF9.BOUNDING_DATA_INDEX)(nodeIndex32);\n        for(let b = 0; b < 3; b++){\n            boundsArray[8 * i + 0 + b] = float32Array[boundsIndex + 0 + b];\n            boundsArray[8 * i + 4 + b] = float32Array[boundsIndex + 3 + b];\n        }\n        if ((0, $8kAF9.IS_LEAF)(nodeIndex16, uint16Array)) {\n            const count = (0, $8kAF9.COUNT)(nodeIndex16, uint16Array);\n            const offset = (0, $8kAF9.OFFSET)(nodeIndex32, uint32Array);\n            const mergedLeafCount = 0xffff0000 | count;\n            contentsArray[i * 2 + 0] = mergedLeafCount;\n            contentsArray[i * 2 + 1] = offset;\n        } else {\n            const rightIndex = 4 * (0, $8kAF9.RIGHT_NODE)(nodeIndex32, uint32Array) / (0, $Mleu6.BYTES_PER_NODE);\n            const splitAxis = (0, $8kAF9.SPLIT_AXIS)(nodeIndex32, uint32Array);\n            contentsArray[i * 2 + 0] = splitAxis;\n            contentsArray[i * 2 + 1] = rightIndex;\n        }\n    }\n    boundsTexture.image.data = boundsArray;\n    boundsTexture.image.width = boundsDimension;\n    boundsTexture.image.height = boundsDimension;\n    boundsTexture.format = (0, $ilwiq.RGBAFormat);\n    boundsTexture.type = (0, $ilwiq.FloatType);\n    boundsTexture.internalFormat = \"RGBA32F\";\n    boundsTexture.minFilter = (0, $ilwiq.NearestFilter);\n    boundsTexture.magFilter = (0, $ilwiq.NearestFilter);\n    boundsTexture.generateMipmaps = false;\n    boundsTexture.needsUpdate = true;\n    boundsTexture.dispose();\n    contentsTexture.image.data = contentsArray;\n    contentsTexture.image.width = contentsDimension;\n    contentsTexture.image.height = contentsDimension;\n    contentsTexture.format = (0, $ilwiq.RGIntegerFormat);\n    contentsTexture.type = (0, $ilwiq.UnsignedIntType);\n    contentsTexture.internalFormat = \"RG32UI\";\n    contentsTexture.minFilter = (0, $ilwiq.NearestFilter);\n    contentsTexture.magFilter = (0, $ilwiq.NearestFilter);\n    contentsTexture.generateMipmaps = false;\n    contentsTexture.needsUpdate = true;\n    contentsTexture.dispose();\n}\n\n});\nparcelRegister(\"5LGag\", function(module, exports) {\n\n$parcel$export(module.exports, \"UIntVertexAttributeTexture\", () => $43320c8ca317ae89$export$de036370a093ef);\n$parcel$export(module.exports, \"FloatVertexAttributeTexture\", () => $43320c8ca317ae89$export$5444fd0f1815741f);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $43320c8ca317ae89$var$countToStringFormat(count) {\n    switch(count){\n        case 1:\n            return \"R\";\n        case 2:\n            return \"RG\";\n        case 3:\n            return \"RGBA\";\n        case 4:\n            return \"RGBA\";\n    }\n    throw new Error();\n}\nfunction $43320c8ca317ae89$var$countToFormat(count) {\n    switch(count){\n        case 1:\n            return 0, $ilwiq.RedFormat;\n        case 2:\n            return 0, $ilwiq.RGFormat;\n        case 3:\n            return 0, $ilwiq.RGBAFormat;\n        case 4:\n            return 0, $ilwiq.RGBAFormat;\n    }\n}\nfunction $43320c8ca317ae89$var$countToIntFormat(count) {\n    switch(count){\n        case 1:\n            return 0, $ilwiq.RedIntegerFormat;\n        case 2:\n            return 0, $ilwiq.RGIntegerFormat;\n        case 3:\n            return 0, $ilwiq.RGBAIntegerFormat;\n        case 4:\n            return 0, $ilwiq.RGBAIntegerFormat;\n    }\n}\nclass $43320c8ca317ae89$export$2ba8de89bc26b001 extends (0, $ilwiq.DataTexture) {\n    constructor(){\n        super();\n        this.minFilter = (0, $ilwiq.NearestFilter);\n        this.magFilter = (0, $ilwiq.NearestFilter);\n        this.generateMipmaps = false;\n        this.overrideItemSize = null;\n        this._forcedType = null;\n    }\n    updateFrom(attr) {\n        const overrideItemSize = this.overrideItemSize;\n        const originalItemSize = attr.itemSize;\n        const originalCount = attr.count;\n        if (overrideItemSize !== null) {\n            if (originalItemSize * originalCount % overrideItemSize !== 0.0) throw new Error(\"VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.\");\n            attr.itemSize = overrideItemSize;\n            attr.count = originalCount * originalItemSize / overrideItemSize;\n        }\n        const itemSize = attr.itemSize;\n        const count = attr.count;\n        const normalized = attr.normalized;\n        const originalBufferCons = attr.array.constructor;\n        const byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n        let targetType = this._forcedType;\n        let finalStride = itemSize;\n        // derive the type of texture this should be in the shader\n        if (targetType === null) switch(originalBufferCons){\n            case Float32Array:\n                targetType = (0, $ilwiq.FloatType);\n                break;\n            case Uint8Array:\n            case Uint16Array:\n            case Uint32Array:\n                targetType = (0, $ilwiq.UnsignedIntType);\n                break;\n            case Int8Array:\n            case Int16Array:\n            case Int32Array:\n                targetType = (0, $ilwiq.IntType);\n                break;\n        }\n        // get the target format to store the texture as\n        let type, format, normalizeValue, targetBufferCons;\n        let internalFormat = $43320c8ca317ae89$var$countToStringFormat(itemSize);\n        switch(targetType){\n            case 0, $ilwiq.FloatType:\n                normalizeValue = 1.0;\n                format = $43320c8ca317ae89$var$countToFormat(itemSize);\n                if (normalized && byteCount === 1) {\n                    targetBufferCons = originalBufferCons;\n                    internalFormat += \"8\";\n                    if (originalBufferCons === Uint8Array) type = (0, $ilwiq.UnsignedByteType);\n                    else {\n                        type = (0, $ilwiq.ByteType);\n                        internalFormat += \"_SNORM\";\n                    }\n                } else {\n                    targetBufferCons = Float32Array;\n                    internalFormat += \"32F\";\n                    type = (0, $ilwiq.FloatType);\n                }\n                break;\n            case 0, $ilwiq.IntType:\n                internalFormat += byteCount * 8 + \"I\";\n                normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n                format = $43320c8ca317ae89$var$countToIntFormat(itemSize);\n                if (byteCount === 1) {\n                    targetBufferCons = Int8Array;\n                    type = (0, $ilwiq.ByteType);\n                } else if (byteCount === 2) {\n                    targetBufferCons = Int16Array;\n                    type = (0, $ilwiq.ShortType);\n                } else {\n                    targetBufferCons = Int32Array;\n                    type = (0, $ilwiq.IntType);\n                }\n                break;\n            case 0, $ilwiq.UnsignedIntType:\n                internalFormat += byteCount * 8 + \"UI\";\n                normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n                format = $43320c8ca317ae89$var$countToIntFormat(itemSize);\n                if (byteCount === 1) {\n                    targetBufferCons = Uint8Array;\n                    type = (0, $ilwiq.UnsignedByteType);\n                } else if (byteCount === 2) {\n                    targetBufferCons = Uint16Array;\n                    type = (0, $ilwiq.UnsignedShortType);\n                } else {\n                    targetBufferCons = Uint32Array;\n                    type = (0, $ilwiq.UnsignedIntType);\n                }\n                break;\n        }\n        // there will be a mismatch between format length and final length because\n        // RGBFormat and RGBIntegerFormat was removed\n        if (finalStride === 3 && (format === (0, $ilwiq.RGBAFormat) || format === (0, $ilwiq.RGBAIntegerFormat))) finalStride = 4;\n        // copy the data over to the new texture array\n        const dimension = Math.ceil(Math.sqrt(count)) || 1;\n        const length = finalStride * dimension * dimension;\n        const dataArray = new targetBufferCons(length);\n        // temporarily set the normalized state to false since we have custom normalization logic\n        const originalNormalized = attr.normalized;\n        attr.normalized = false;\n        for(let i = 0; i < count; i++){\n            const ii = finalStride * i;\n            dataArray[ii] = attr.getX(i) / normalizeValue;\n            if (itemSize >= 2) dataArray[ii + 1] = attr.getY(i) / normalizeValue;\n            if (itemSize >= 3) {\n                dataArray[ii + 2] = attr.getZ(i) / normalizeValue;\n                if (finalStride === 4) dataArray[ii + 3] = 1.0;\n            }\n            if (itemSize >= 4) dataArray[ii + 3] = attr.getW(i) / normalizeValue;\n        }\n        attr.normalized = originalNormalized;\n        this.internalFormat = internalFormat;\n        this.format = format;\n        this.type = type;\n        this.image.width = dimension;\n        this.image.height = dimension;\n        this.image.data = dataArray;\n        this.needsUpdate = true;\n        this.dispose();\n        attr.itemSize = originalItemSize;\n        attr.count = originalCount;\n    }\n}\nclass $43320c8ca317ae89$export$de036370a093ef extends $43320c8ca317ae89$export$2ba8de89bc26b001 {\n    constructor(){\n        super();\n        this._forcedType = (0, $ilwiq.UnsignedIntType);\n    }\n}\nclass $43320c8ca317ae89$export$7a0619b1bafd353c extends $43320c8ca317ae89$export$2ba8de89bc26b001 {\n    constructor(){\n        super();\n        this._forcedType = (0, $ilwiq.IntType);\n    }\n}\nclass $43320c8ca317ae89$export$5444fd0f1815741f extends $43320c8ca317ae89$export$2ba8de89bc26b001 {\n    constructor(){\n        super();\n        this._forcedType = (0, $ilwiq.FloatType);\n    }\n}\n\n});\n\n\n\n//# sourceMappingURL=diamond.5b837c44.js.map\n","export * from './glsl/common_functions.glsl.js';\nexport * from './glsl/bvh_distance_functions.glsl.js';\nexport * from './glsl/bvh_ray_functions.glsl.js';\nexport * from './glsl/bvh_struct_definitions.glsl.js';\n","export const common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n","// Distance to Point\nexport const bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n","export const bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n","// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n","import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tRIGHT_NODE,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\t\tthis._cachedIndexAttr = null;\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t// dereference a new index attribute if we're using indirect storage\n\t\tif ( bvh.indirect ) {\n\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tif (\n\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t) {\n\n\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t} else {\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\tconst unpacked = target.array;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t}\n\n\t}\n\n}\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n"],"names":["$parcel$exportWildcard","dest","source","Object","keys","forEach","key","prototype","hasOwnProperty","call","defineProperty","enumerable","get","$parcel$export","e","n","v","s","set","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","err","Error","code","register","parcelRegister","$b3nr3","$6zfry","$h8ZmT","$fw6HR","$80c2275096d27f80$export$25a1e84cdffa9fe9","$4c81fdb1f89608c4$export$ae4e12e8c7af5f08","$c7b2c978f8b5f743$export$3c2bc5470251fe4a","$b4bf0beee1e6abbf$export$5e276bbaa046dbad","$84be0288c3863b1d$export$4dc20da53fccce35","$ilwiq","$5LGag","$Mleu6","$8kAF9","$aBE3W","constructor","index","UIntVertexAttributeTexture","position","FloatVertexAttributeTexture","bvhBounds","DataTexture","bvhContents","_cachedIndexAttr","overrideItemSize","updateFrom","bvh","geometry","$84be0288c3863b1d$var$bvhToTextures","boundsTexture","contentsTexture","roots","_roots","length","root","uint16Array","Uint16Array","uint32Array","Uint32Array","float32Array","Float32Array","nodeCount","byteLength","BYTES_PER_NODE","boundsDimension","Math","ceil","sqrt","boundsArray","contentsDimension","contentsArray","i","nodeIndex32","nodeIndex16","boundsIndex","BOUNDING_DATA_INDEX","b","IS_LEAF","count","COUNT","offset","OFFSET","mergedLeafCount","rightIndex","RIGHT_NODE","splitAxis","SPLIT_AXIS","image","data","width","height","format","RGBAFormat","type","FloatType","internalFormat","minFilter","NearestFilter","magFilter","generateMipmaps","needsUpdate","dispose","RGIntegerFormat","UnsignedIntType","attributes","indirect","indirectBuffer","_indirectBuffer","clone","array","getIndexArray","getVertexCount","BufferAttribute","$84be0288c3863b1d$var$dereferenceIndex","target","unpacked","indexArray","l","i3","v3","c","$43320c8ca317ae89$export$de036370a093ef","$43320c8ca317ae89$export$5444fd0f1815741f","$43320c8ca317ae89$var$countToIntFormat","RedIntegerFormat","RGBAIntegerFormat","$43320c8ca317ae89$export$2ba8de89bc26b001","_forcedType","attr","normalizeValue","targetBufferCons","originalItemSize","itemSize","originalCount","normalized","originalBufferCons","byteCount","BYTES_PER_ELEMENT","targetType","finalStride","Uint8Array","Int8Array","Int16Array","Int32Array","IntType","$43320c8ca317ae89$var$countToStringFormat","$43320c8ca317ae89$var$countToFormat","RedFormat","RGFormat","UnsignedByteType","ByteType","pow","ShortType","UnsignedShortType","dimension","dataArray","originalNormalized","ii","getX","getY","getZ","getW"],"version":3,"file":"diamond.5b837c44.js.map"}