{"mappings":"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","sources":["<anon>","example/diamond.js","node_modules/three/examples/jsm/loaders/RGBELoader.js","node_modules/three/examples/jsm/libs/stats.module.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\nclass $5ee05658f4b0e3bf$export$d076a711b55c758a extends (0, $ilwiq.DataTextureLoader) {\n    constructor(manager){\n        super(manager);\n        this.type = (0, $ilwiq.HalfFloatType);\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const /* return codes for rgbe routines */ //RGBE_RETURN_SUCCESS = 0,\n        RGBE_RETURN_FAILURE = -1, /* default error routine.  change this to change error handling */ rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    console.error(\"THREE.RGBELoader Read Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_write_error:\n                    console.error(\"THREE.RGBELoader Write Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_format_error:\n                    console.error(\"THREE.RGBELoader Bad File Format: \" + (msg || \"\"));\n                    break;\n                default:\n                case rgbe_memory_error:\n                    console.error(\"THREE.RGBELoader: Error: \" + (msg || \"\"));\n            }\n            return RGBE_RETURN_FAILURE;\n        }, /* offsets to red, green, and blue components in a data (float) pixel */ //RGBE_DATA_RED = 0,\n        //RGBE_DATA_GREEN = 1,\n        //RGBE_DATA_BLUE = 2,\n        /* number of floats per pixel, use 4 since stored in rgba image format */ //RGBE_DATA_SIZE = 4,\n        /* flags indicating which fields in an rgbe_header_info are valid */ RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/ if (false !== consume) buffer.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, /* minimal header reading.  modify if you want to parse more information */ RGBE_ReadHeader = function(buffer) {\n            // regexes to parse header info fields\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, // RGBE format header struct\n            header = {\n                valid: 0,\n                /* indicate which fields are valid */ string: \"\",\n                /* the actual header string */ comments: \"\",\n                /* comments found in header */ programtype: \"RGBE\",\n                /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */ format: \"\",\n                /* RGBE format, default 32-bit_rle_rgbe */ gamma: 1.0,\n                /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */ exposure: 1.0,\n                /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */ width: 0,\n                height: 0 /* image dimensions, width/height */ \n            };\n            let line, match;\n            if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) return rgbe_error(rgbe_read_error, \"no header found\");\n            /* if you want to require the magic token then uncomment the next line */ if (!(match = line.match(magic_token_re))) return rgbe_error(rgbe_format_error, \"bad initial token\");\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue; // comment line\n                }\n                if (match = line.match(gamma_re)) header.gamma = parseFloat(match[1]);\n                if (match = line.match(exposure_re)) header.exposure = parseFloat(match[1]);\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1]; //'32-bit_rle_rgbe';\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) return rgbe_error(rgbe_format_error, \"missing format specifier\");\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) return rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer, w, h) {\n            const scanline_width = w;\n            if (scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n            2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) // return the flat buffer\n            return new Uint8Array(buffer);\n            if (scanline_width !== (buffer[2] << 8 | buffer[3])) return rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) return rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            // read in each successive scanline\n            while(num_scanlines > 0 && pos < buffer.byteLength){\n                if (pos + 4 > buffer.byteLength) return rgbe_error(rgbe_read_error);\n                rgbeStart[0] = buffer[pos++];\n                rgbeStart[1] = buffer[pos++];\n                rgbeStart[2] = buffer[pos++];\n                rgbeStart[3] = buffer[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) return rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                // read each of the four channels for the scanline into the buffer\n                // first red, then green, then blue, then exponent\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer.byteLength){\n                    count = buffer[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) return rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    if (isEncodedRun) {\n                        // a (encoded) run of the same value\n                        const byteValue = buffer[pos++];\n                        for(let i = 0; i < count; i++)scanline_buffer[ptr++] = byteValue;\n                    //ptr += count;\n                    } else {\n                        // a literal-run\n                        scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                // now convert data from buffer into rgba\n                // first red, then green, then blue, then exponent (alpha)\n                const l = scanline_width; //scanline_buffer.byteLength;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            // clamping to 65504, the maximum representable value in float16\n            destArray[destOffset + 0] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = (0, $ilwiq.DataUtils).toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n            const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n            if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n                let data, type;\n                let numElements;\n                switch(this.type){\n                    case 0, $ilwiq.FloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const floatArray = new Float32Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++)RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                        data = floatArray;\n                        type = (0, $ilwiq.FloatType);\n                        break;\n                    case 0, $ilwiq.HalfFloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const halfArray = new Uint16Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++)RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                        data = halfArray;\n                        type = (0, $ilwiq.HalfFloatType);\n                        break;\n                    default:\n                        console.error(\"THREE.RGBELoader: unsupported type: \", this.type);\n                        break;\n                }\n                return {\n                    width: w,\n                    height: h,\n                    data: data,\n                    header: rgbe_header_info.string,\n                    gamma: rgbe_header_info.gamma,\n                    exposure: rgbe_header_info.exposure,\n                    type: type\n                };\n            }\n        }\n        return null;\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case 0, $ilwiq.FloatType:\n                case 0, $ilwiq.HalfFloatType:\n                    texture.encoding = (0, $ilwiq.LinearEncoding);\n                    texture.minFilter = (0, $ilwiq.LinearFilter);\n                    texture.magFilter = (0, $ilwiq.LinearFilter);\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n\n\nvar $5aae44c9b1864d53$var$Stats = function() {\n    var mode = 0;\n    var container = document.createElement(\"div\");\n    container.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n    container.addEventListener(\"click\", function(event) {\n        event.preventDefault();\n        showPanel(++mode % container.children.length);\n    }, false);\n    //\n    function addPanel(panel) {\n        container.appendChild(panel.dom);\n        return panel;\n    }\n    function showPanel(id) {\n        for(var i = 0; i < container.children.length; i++)container.children[i].style.display = i === id ? \"block\" : \"none\";\n        mode = id;\n    }\n    //\n    var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;\n    var fpsPanel = addPanel(new $5aae44c9b1864d53$var$Stats.Panel(\"FPS\", \"#0ff\", \"#002\"));\n    var msPanel = addPanel(new $5aae44c9b1864d53$var$Stats.Panel(\"MS\", \"#0f0\", \"#020\"));\n    if (self.performance && self.performance.memory) var memPanel = addPanel(new $5aae44c9b1864d53$var$Stats.Panel(\"MB\", \"#f08\", \"#201\"));\n    showPanel(0);\n    return {\n        REVISION: 16,\n        dom: container,\n        addPanel: addPanel,\n        showPanel: showPanel,\n        begin: function() {\n            beginTime = (performance || Date).now();\n        },\n        end: function() {\n            frames++;\n            var time = (performance || Date).now();\n            msPanel.update(time - beginTime, 200);\n            if (time >= prevTime + 1000) {\n                fpsPanel.update(frames * 1000 / (time - prevTime), 100);\n                prevTime = time;\n                frames = 0;\n                if (memPanel) {\n                    var memory = performance.memory;\n                    memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);\n                }\n            }\n            return time;\n        },\n        update: function() {\n            beginTime = this.end();\n        },\n        // Backwards Compatibility\n        domElement: container,\n        setMode: showPanel\n    };\n};\n$5aae44c9b1864d53$var$Stats.Panel = function(name, fg, bg) {\n    var min = Infinity, max = 0, round = Math.round;\n    var PR = round(window.devicePixelRatio || 1);\n    var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = WIDTH;\n    canvas.height = HEIGHT;\n    canvas.style.cssText = \"width:80px;height:48px\";\n    var context = canvas.getContext(\"2d\");\n    context.font = \"bold \" + 9 * PR + \"px Helvetica,Arial,sans-serif\";\n    context.textBaseline = \"top\";\n    context.fillStyle = bg;\n    context.fillRect(0, 0, WIDTH, HEIGHT);\n    context.fillStyle = fg;\n    context.fillText(name, TEXT_X, TEXT_Y);\n    context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n    context.fillStyle = bg;\n    context.globalAlpha = 0.9;\n    context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n    return {\n        dom: canvas,\n        update: function(value, maxValue) {\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n            context.fillStyle = bg;\n            context.globalAlpha = 1;\n            context.fillRect(0, 0, WIDTH, GRAPH_Y);\n            context.fillStyle = fg;\n            context.fillText(round(value) + \" \" + name + \" (\" + round(min) + \"-\" + round(max) + \")\", TEXT_X, TEXT_Y);\n            context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);\n            context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);\n            context.fillStyle = bg;\n            context.globalAlpha = 0.9;\n            context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));\n        }\n    };\n};\nvar $5aae44c9b1864d53$export$2e2bcd8739ae039 = $5aae44c9b1864d53$var$Stats;\n\n\n\nvar $gcCUH = parcelRequire(\"gcCUH\");\nvar $ff8ed = parcelRequire(\"ff8ed\");\nvar $boAbX = parcelRequire(\"boAbX\");\nvar $Mleu6 = parcelRequire(\"Mleu6\");\nlet $e7bc8b365f81c957$var$scene, $e7bc8b365f81c957$var$camera, $e7bc8b365f81c957$var$renderer, $e7bc8b365f81c957$var$environment, $e7bc8b365f81c957$var$controls, $e7bc8b365f81c957$var$diamond, $e7bc8b365f81c957$var$gui, $e7bc8b365f81c957$var$stats, $e7bc8b365f81c957$var$clock;\nconst $e7bc8b365f81c957$var$params = {\n    color: \"#ffffff\",\n    bounces: 3.0,\n    ior: 2.4,\n    aberrationStrength: 0.01,\n    fastChroma: false,\n    animate: true\n};\n$e7bc8b365f81c957$var$init();\nasync function $e7bc8b365f81c957$var$init() {\n    // renderer, scene, camera setup\n    $e7bc8b365f81c957$var$scene = new $ilwiq.Scene();\n    $e7bc8b365f81c957$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    $e7bc8b365f81c957$var$camera.position.set(28, 15, 7);\n    // NOTE: antialiasing is disabled because the interpolation at face edges results in numeric issues\n    // causing the raycast to intersect the front faces. An adjusted bvh cast function that affords filtering by\n    // front / back faces would help this.\n    $e7bc8b365f81c957$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: false\n    });\n    $e7bc8b365f81c957$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $e7bc8b365f81c957$var$renderer.outputEncoding = $ilwiq.sRGBEncoding;\n    $e7bc8b365f81c957$var$renderer.toneMapping = $ilwiq.ACESFilmicToneMapping;\n    document.body.appendChild($e7bc8b365f81c957$var$renderer.domElement);\n    $e7bc8b365f81c957$var$controls = new (0, $5Rd1x.OrbitControls)($e7bc8b365f81c957$var$camera, $e7bc8b365f81c957$var$renderer.domElement);\n    $e7bc8b365f81c957$var$clock = new $ilwiq.Clock();\n    // load the environment and model\n    const environmentPromise = new (0, $5ee05658f4b0e3bf$export$d076a711b55c758a)().loadAsync(\"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr\");\n    const gltfPromise = new (0, $7lx9d.GLTFLoader)().loadAsync(\"../models/diamond.glb\");\n    let gltf;\n    [$e7bc8b365f81c957$var$environment, gltf] = await Promise.all([\n        environmentPromise,\n        gltfPromise\n    ]);\n    // initialize the background\n    $e7bc8b365f81c957$var$environment.mapping = $ilwiq.EquirectangularReflectionMapping;\n    $e7bc8b365f81c957$var$environment.generateMipmaps = true;\n    $e7bc8b365f81c957$var$environment.minFilter = $ilwiq.LinearMipmapLinearFilter;\n    $e7bc8b365f81c957$var$environment.magFilter = $ilwiq.LinearFilter;\n    $e7bc8b365f81c957$var$scene.background = $e7bc8b365f81c957$var$environment;\n    // initialize the diamond material\n    const diamondMaterial = new $ilwiq.ShaderMaterial({\n        uniforms: {\n            // scene / geometry information\n            envMap: {\n                value: $e7bc8b365f81c957$var$environment\n            },\n            bvh: {\n                value: new (0, $boAbX.MeshBVHUniformStruct)()\n            },\n            projectionMatrixInv: {\n                value: $e7bc8b365f81c957$var$camera.projectionMatrixInverse\n            },\n            viewMatrixInv: {\n                value: $e7bc8b365f81c957$var$camera.matrixWorld\n            },\n            resolution: {\n                value: new $ilwiq.Vector2()\n            },\n            // internal reflection settings\n            bounces: {\n                value: 3\n            },\n            ior: {\n                value: 2.4\n            },\n            // chroma and color settings\n            color: {\n                value: new $ilwiq.Color(1, 1, 1)\n            },\n            fastChroma: {\n                value: false\n            },\n            aberrationStrength: {\n                value: 0.01\n            }\n        },\n        vertexShader: /*glsl*/ `\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tvarying vec3 vNormal;\n\t\t\tuniform mat4 viewMatrixInv;\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldPosition = ( modelMatrix * vec4( position, 1.0 ) ).xyz;\n\t\t\t\tvNormal = ( viewMatrixInv * vec4( normalMatrix * normal, 0.0 ) ).xyz;\n\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position , 1.0 );\n\n\t\t\t}\n\t\t`,\n        fragmentShader: /*glsl*/ `\n\t\t\t#define RAY_OFFSET 0.001\n\n\t\t\t#include <common>\n\t\t\tprecision highp isampler2D;\n\t\t\tprecision highp usampler2D;\n\n\t\t\t${(0, $gcCUH).common_functions}\n\t\t\t${(0, $gcCUH).bvh_struct_definitions}\n\t\t\t${(0, $gcCUH).bvh_ray_functions}\n\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tvarying vec3 vNormal;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform float bounces;\n\t\t\tuniform BVH bvh;\n\t\t\tuniform float ior;\n\t\t\tuniform vec3 color;\n\t\t\tuniform bool fastChroma;\n\t\t\tuniform mat4 projectionMatrixInv;\n\t\t\tuniform mat4 viewMatrixInv;\n\t\t\tuniform mat4 modelMatrix;\n\t\t\tuniform vec2 resolution;\n\t\t\tuniform float aberrationStrength;\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t// performs an iterative bounce lookup modeling internal reflection and returns\n\t\t\t// a final ray direction.\n\t\t\tvec3 totalInternalReflection( vec3 incomingOrigin, vec3 incomingDirection, vec3 normal, float ior, mat4 modelMatrixInverse ) {\n\n\t\t\t\tvec3 rayOrigin = incomingOrigin;\n\t\t\t\tvec3 rayDirection = incomingDirection;\n\n\t\t\t\t// refract the ray direction on the way into the diamond and adjust offset from\n\t\t\t\t// the diamond surface for raytracing\n\t\t\t\trayDirection = refract( rayDirection, normal, 1.0 / ior );\n\t\t\t\trayOrigin = vWorldPosition + rayDirection * RAY_OFFSET;\n\n\t\t\t\t// transform the ray into the local coordinates of the model\n\t\t\t\trayOrigin = ( modelMatrixInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\trayDirection = normalize( ( modelMatrixInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t// perform multiple ray casts\n\t\t\t\tfor( float i = 0.0; i < bounces; i ++ ) {\n\n\t\t\t\t\t// results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// perform the raycast\n\t\t\t\t\t// the diamond is a water tight model so we assume we always hit a surface\n\t\t\t\t\tbvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\n\t\t\t\t\t// derive the new ray origin from the hit results\n\t\t\t\t\tvec3 hitPos = rayOrigin + rayDirection * dist;\n\n\t\t\t\t\t// if we don't internally reflect then end the ray tracing and sample\n\t\t\t\t\tvec3 refractedDirection = refract( rayDirection, faceNormal, ior );\n\t\t\t\t\tbool totalInternalReflection = length( refract( rayDirection, faceNormal, ior ) ) == 0.0;\n\t\t\t\t\tif ( ! totalInternalReflection ) {\n\n\t\t\t\t\t\trayDirection = refractedDirection;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise reflect off the surface internally for another hit\n\t\t\t\t\trayDirection = reflect( rayDirection, faceNormal );\n\t\t\t\t\trayOrigin = hitPos + rayDirection * RAY_OFFSET;\n\n\t\t\t\t}\n\n\t\t\t\t// return the final ray direction in world space\n\t\t\t\treturn normalize( ( modelMatrix * vec4( rayDirection, 0.0 ) ).xyz );\n\t\t\t}\n\n\t\t\tvec4 envSample( sampler2D envMap, vec3 rayDirection ) {\n\n\t\t\t\tvec2 uvv = equirectUv( rayDirection );\n\t\t\t\treturn texture( envMap, uvv );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tmat4 modelMatrixInverse = inverse( modelMatrix );\n\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution;\n\n\t\t\t\tvec3 normal = vNormal;\n\t\t\t\tvec3 rayOrigin = cameraPosition;\n\t\t\t\tvec3 rayDirection = normalize( vWorldPosition - cameraPosition );\n\n\t\t\t\tif ( aberrationStrength != 0.0 ) {\n\n\t\t\t\t\t// perform chromatic aberration lookups\n\t\t\t\t\tvec3 rayDirectionG = totalInternalReflection( rayOrigin, rayDirection, normal, max( ior, 1.0 ), modelMatrixInverse );\n\t\t\t\t\tvec3 rayDirectionR, rayDirectionB;\n\n\t\t\t\t\tif ( fastChroma ) {\n\n\t\t\t\t\t\t// fast chroma does a quick uv offset on lookup\n\t\t\t\t\t\trayDirectionR = normalize( rayDirectionG + 1.0 * vec3( aberrationStrength / 2.0 ) );\n\t\t\t\t\t\trayDirectionB = normalize( rayDirectionG - 1.0 * vec3( aberrationStrength / 2.0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// compared to a proper ray trace of diffracted rays\n\t\t\t\t\t\tfloat iorR = max( ior * ( 1.0 - aberrationStrength ), 1.0 );\n\t\t\t\t\t\tfloat iorB = max( ior * ( 1.0 + aberrationStrength ), 1.0 );\n\t\t\t\t\t\trayDirectionR = totalInternalReflection(\n\t\t\t\t\t\t\trayOrigin, rayDirection, normal,\n\t\t\t\t\t\t\tiorR, modelMatrixInverse\n\t\t\t\t\t\t);\n\t\t\t\t\t\trayDirectionB = totalInternalReflection(\n\t\t\t\t\t\t\trayOrigin, rayDirection, normal,\n\t\t\t\t\t\t\tiorB, modelMatrixInverse\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// get the color lookup\n\t\t\t\t\tfloat r = envSample( envMap, rayDirectionR ).r;\n\t\t\t\t\tfloat g = envSample( envMap, rayDirectionG ).g;\n\t\t\t\t\tfloat b = envSample( envMap, rayDirectionB ).b;\n\t\t\t\t\tgl_FragColor.rgb = vec3( r, g, b ) * color;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// no chromatic aberration lookups\n\t\t\t\t\trayDirection = totalInternalReflection( rayOrigin, rayDirection, normal, max( ior, 1.0 ), modelMatrixInverse );\n\t\t\t\t\tgl_FragColor.rgb = envSample( envMap, rayDirection ).rgb * color;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t}\n\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\n\t\t\t}\n\t\t`\n    });\n    // initialize the diamond geometry and material uniforms\n    const diamondGeo = gltf.scene.children[0].children[0].children[0].children[0].children[0].geometry;\n    diamondGeo.scale(10, 10, 10);\n    const bvh = new (0, $ff8ed.MeshBVH)(diamondGeo, {\n        strategy: (0, $Mleu6.SAH),\n        maxLeafTris: 1\n    });\n    diamondMaterial.uniforms.bvh.value.updateFrom(bvh);\n    $e7bc8b365f81c957$var$diamond = new $ilwiq.Mesh(diamondGeo, diamondMaterial);\n    $e7bc8b365f81c957$var$scene.add($e7bc8b365f81c957$var$diamond);\n    // gui setup\n    $e7bc8b365f81c957$var$gui = new (0, $jiuw3.GUI)();\n    $e7bc8b365f81c957$var$gui.add($e7bc8b365f81c957$var$params, \"animate\");\n    $e7bc8b365f81c957$var$gui.addColor($e7bc8b365f81c957$var$params, \"color\").name(\"Color\").onChange((v)=>{\n        $e7bc8b365f81c957$var$diamond.material.uniforms.color.value.set(v);\n    });\n    $e7bc8b365f81c957$var$gui.add($e7bc8b365f81c957$var$params, \"bounces\", 1.0, 10.0, 1.0).name(\"Bounces\").onChange((v)=>{\n        $e7bc8b365f81c957$var$diamond.material.uniforms.bounces.value = v;\n    });\n    $e7bc8b365f81c957$var$gui.add($e7bc8b365f81c957$var$params, \"ior\", 1.0, 5.0, 0.01).name(\"IOR\").onChange((v)=>{\n        $e7bc8b365f81c957$var$diamond.material.uniforms.ior.value = v;\n    });\n    $e7bc8b365f81c957$var$gui.add($e7bc8b365f81c957$var$params, \"fastChroma\").onChange((v)=>{\n        $e7bc8b365f81c957$var$diamond.material.uniforms.fastChroma.value = v;\n    });\n    $e7bc8b365f81c957$var$gui.add($e7bc8b365f81c957$var$params, \"aberrationStrength\", 0.0, 0.1, 0.0001).onChange((v)=>{\n        $e7bc8b365f81c957$var$diamond.material.uniforms.aberrationStrength.value = v;\n    });\n    $e7bc8b365f81c957$var$stats = new (0, $5aae44c9b1864d53$export$2e2bcd8739ae039)();\n    $e7bc8b365f81c957$var$stats.showPanel(0);\n    document.body.appendChild($e7bc8b365f81c957$var$stats.dom);\n    $e7bc8b365f81c957$var$render();\n    window.addEventListener(\"resize\", function() {\n        $e7bc8b365f81c957$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $e7bc8b365f81c957$var$camera.updateProjectionMatrix();\n        $e7bc8b365f81c957$var$diamond.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);\n        $e7bc8b365f81c957$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    }, false);\n}\nfunction $e7bc8b365f81c957$var$render() {\n    if ($e7bc8b365f81c957$var$params.animate) $e7bc8b365f81c957$var$diamond.rotation.y += $e7bc8b365f81c957$var$clock.getDelta() * 0.25;\n    $e7bc8b365f81c957$var$stats.update();\n    $e7bc8b365f81c957$var$controls.update();\n    $e7bc8b365f81c957$var$renderer.render($e7bc8b365f81c957$var$scene, $e7bc8b365f81c957$var$camera);\n    requestAnimationFrame($e7bc8b365f81c957$var$render);\n}\n\n\n//# sourceMappingURL=diamond.7afaf405.js.map\n","import * as THREE from 'three';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport Stats from 'three/examples/jsm/libs/stats.module.js';\nimport {\n\tMeshBVH,\n\tMeshBVHUniformStruct,\n\tBVHShaderGLSL,\n\tSAH\n} from '../src/index.js';\n\nlet scene, camera, renderer, environment, controls, diamond, gui, stats, clock;\n\nconst params = {\n\n\tcolor: '#ffffff',\n\tbounces: 3.0,\n\tior: 2.4,\n\taberrationStrength: 0.01,\n\tfastChroma: false,\n\tanimate: true,\n\n};\n\ninit();\n\nasync function init() {\n\n\t// renderer, scene, camera setup\n\tscene = new THREE.Scene();\n\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\tcamera.position.set( 28, 15, 7 );\n\n\t// NOTE: antialiasing is disabled because the interpolation at face edges results in numeric issues\n\t// causing the raycast to intersect the front faces. An adjusted bvh cast function that affords filtering by\n\t// front / back faces would help this.\n\trenderer = new THREE.WebGLRenderer( { antialias: false } );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\tdocument.body.appendChild( renderer.domElement );\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\tclock = new THREE.Clock();\n\n\t// load the environment and model\n\tconst environmentPromise = new RGBELoader()\n\t\t.loadAsync( 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr' );\n\n\tconst gltfPromise = new GLTFLoader().loadAsync( '../models/diamond.glb' );\n\n\tlet gltf;\n\t[ environment, gltf ] = await Promise.all( [ environmentPromise, gltfPromise ] );\n\n\t// initialize the background\n\tenvironment.mapping = THREE.EquirectangularReflectionMapping;\n\tenvironment.generateMipmaps = true;\n\tenvironment.minFilter = THREE.LinearMipmapLinearFilter;\n\tenvironment.magFilter = THREE.LinearFilter;\n\tscene.background = environment;\n\n\t// initialize the diamond material\n\tconst diamondMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: {\n\n\t\t\t// scene / geometry information\n\t\t\tenvMap: { value: environment },\n\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\tprojectionMatrixInv: { value: camera.projectionMatrixInverse },\n\t\t\tviewMatrixInv: { value: camera.matrixWorld },\n\t\t\tresolution: { value: new THREE.Vector2() },\n\n\t\t\t// internal reflection settings\n\t\t\tbounces: { value: 3 },\n\t\t\tior: { value: 2.4 },\n\n\t\t\t// chroma and color settings\n\t\t\tcolor: { value: new THREE.Color( 1, 1, 1 ) },\n\t\t\tfastChroma: { value: false },\n\t\t\taberrationStrength: { value: 0.01 },\n\n\t\t},\n\t\tvertexShader: /*glsl*/ `\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tvarying vec3 vNormal;\n\t\t\tuniform mat4 viewMatrixInv;\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldPosition = ( modelMatrix * vec4( position, 1.0 ) ).xyz;\n\t\t\t\tvNormal = ( viewMatrixInv * vec4( normalMatrix * normal, 0.0 ) ).xyz;\n\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position , 1.0 );\n\n\t\t\t}\n\t\t`,\n\t\tfragmentShader: /*glsl*/ `\n\t\t\t#define RAY_OFFSET 0.001\n\n\t\t\t#include <common>\n\t\t\tprecision highp isampler2D;\n\t\t\tprecision highp usampler2D;\n\n\t\t\t${ BVHShaderGLSL.common_functions }\n\t\t\t${ BVHShaderGLSL.bvh_struct_definitions }\n\t\t\t${ BVHShaderGLSL.bvh_ray_functions }\n\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tvarying vec3 vNormal;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform float bounces;\n\t\t\tuniform BVH bvh;\n\t\t\tuniform float ior;\n\t\t\tuniform vec3 color;\n\t\t\tuniform bool fastChroma;\n\t\t\tuniform mat4 projectionMatrixInv;\n\t\t\tuniform mat4 viewMatrixInv;\n\t\t\tuniform mat4 modelMatrix;\n\t\t\tuniform vec2 resolution;\n\t\t\tuniform float aberrationStrength;\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t// performs an iterative bounce lookup modeling internal reflection and returns\n\t\t\t// a final ray direction.\n\t\t\tvec3 totalInternalReflection( vec3 incomingOrigin, vec3 incomingDirection, vec3 normal, float ior, mat4 modelMatrixInverse ) {\n\n\t\t\t\tvec3 rayOrigin = incomingOrigin;\n\t\t\t\tvec3 rayDirection = incomingDirection;\n\n\t\t\t\t// refract the ray direction on the way into the diamond and adjust offset from\n\t\t\t\t// the diamond surface for raytracing\n\t\t\t\trayDirection = refract( rayDirection, normal, 1.0 / ior );\n\t\t\t\trayOrigin = vWorldPosition + rayDirection * RAY_OFFSET;\n\n\t\t\t\t// transform the ray into the local coordinates of the model\n\t\t\t\trayOrigin = ( modelMatrixInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\trayDirection = normalize( ( modelMatrixInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t// perform multiple ray casts\n\t\t\t\tfor( float i = 0.0; i < bounces; i ++ ) {\n\n\t\t\t\t\t// results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// perform the raycast\n\t\t\t\t\t// the diamond is a water tight model so we assume we always hit a surface\n\t\t\t\t\tbvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\n\t\t\t\t\t// derive the new ray origin from the hit results\n\t\t\t\t\tvec3 hitPos = rayOrigin + rayDirection * dist;\n\n\t\t\t\t\t// if we don't internally reflect then end the ray tracing and sample\n\t\t\t\t\tvec3 refractedDirection = refract( rayDirection, faceNormal, ior );\n\t\t\t\t\tbool totalInternalReflection = length( refract( rayDirection, faceNormal, ior ) ) == 0.0;\n\t\t\t\t\tif ( ! totalInternalReflection ) {\n\n\t\t\t\t\t\trayDirection = refractedDirection;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise reflect off the surface internally for another hit\n\t\t\t\t\trayDirection = reflect( rayDirection, faceNormal );\n\t\t\t\t\trayOrigin = hitPos + rayDirection * RAY_OFFSET;\n\n\t\t\t\t}\n\n\t\t\t\t// return the final ray direction in world space\n\t\t\t\treturn normalize( ( modelMatrix * vec4( rayDirection, 0.0 ) ).xyz );\n\t\t\t}\n\n\t\t\tvec4 envSample( sampler2D envMap, vec3 rayDirection ) {\n\n\t\t\t\tvec2 uvv = equirectUv( rayDirection );\n\t\t\t\treturn texture( envMap, uvv );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tmat4 modelMatrixInverse = inverse( modelMatrix );\n\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution;\n\n\t\t\t\tvec3 normal = vNormal;\n\t\t\t\tvec3 rayOrigin = cameraPosition;\n\t\t\t\tvec3 rayDirection = normalize( vWorldPosition - cameraPosition );\n\n\t\t\t\tif ( aberrationStrength != 0.0 ) {\n\n\t\t\t\t\t// perform chromatic aberration lookups\n\t\t\t\t\tvec3 rayDirectionG = totalInternalReflection( rayOrigin, rayDirection, normal, max( ior, 1.0 ), modelMatrixInverse );\n\t\t\t\t\tvec3 rayDirectionR, rayDirectionB;\n\n\t\t\t\t\tif ( fastChroma ) {\n\n\t\t\t\t\t\t// fast chroma does a quick uv offset on lookup\n\t\t\t\t\t\trayDirectionR = normalize( rayDirectionG + 1.0 * vec3( aberrationStrength / 2.0 ) );\n\t\t\t\t\t\trayDirectionB = normalize( rayDirectionG - 1.0 * vec3( aberrationStrength / 2.0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// compared to a proper ray trace of diffracted rays\n\t\t\t\t\t\tfloat iorR = max( ior * ( 1.0 - aberrationStrength ), 1.0 );\n\t\t\t\t\t\tfloat iorB = max( ior * ( 1.0 + aberrationStrength ), 1.0 );\n\t\t\t\t\t\trayDirectionR = totalInternalReflection(\n\t\t\t\t\t\t\trayOrigin, rayDirection, normal,\n\t\t\t\t\t\t\tiorR, modelMatrixInverse\n\t\t\t\t\t\t);\n\t\t\t\t\t\trayDirectionB = totalInternalReflection(\n\t\t\t\t\t\t\trayOrigin, rayDirection, normal,\n\t\t\t\t\t\t\tiorB, modelMatrixInverse\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// get the color lookup\n\t\t\t\t\tfloat r = envSample( envMap, rayDirectionR ).r;\n\t\t\t\t\tfloat g = envSample( envMap, rayDirectionG ).g;\n\t\t\t\t\tfloat b = envSample( envMap, rayDirectionB ).b;\n\t\t\t\t\tgl_FragColor.rgb = vec3( r, g, b ) * color;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// no chromatic aberration lookups\n\t\t\t\t\trayDirection = totalInternalReflection( rayOrigin, rayDirection, normal, max( ior, 1.0 ), modelMatrixInverse );\n\t\t\t\t\tgl_FragColor.rgb = envSample( envMap, rayDirection ).rgb * color;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t}\n\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\n\t\t\t}\n\t\t`\n\t} );\n\n\t// initialize the diamond geometry and material uniforms\n\tconst diamondGeo = gltf.scene.children[ 0 ].children[ 0 ].children[ 0 ].children[ 0 ].children[ 0 ].geometry;\n\tdiamondGeo.scale( 10, 10, 10 );\n\n\tconst bvh = new MeshBVH( diamondGeo, { strategy: SAH, maxLeafTris: 1 } );\n\tdiamondMaterial.uniforms.bvh.value.updateFrom( bvh );\n\tdiamond = new THREE.Mesh( diamondGeo, diamondMaterial );\n\tscene.add( diamond );\n\n\t// gui setup\n\tgui = new GUI();\n\tgui.add( params, 'animate' );\n\tgui.addColor( params, 'color' ).name( 'Color' ).onChange( v => {\n\n\t\tdiamond.material.uniforms.color.value.set( v );\n\n\t} );\n\tgui.add( params, 'bounces', 1.0, 10.0, 1.0 ).name( 'Bounces' ).onChange( v => {\n\n\t\tdiamond.material.uniforms.bounces.value = v;\n\n\t} );\n\tgui.add( params, 'ior', 1.0, 5.0, 0.01 ).name( 'IOR' ).onChange( v => {\n\n\t\tdiamond.material.uniforms.ior.value = v;\n\n\t} );\n\tgui.add( params, 'fastChroma' ).onChange( v => {\n\n\t\tdiamond.material.uniforms.fastChroma.value = v;\n\n\t} );\n\tgui.add( params, 'aberrationStrength', 0.0, 0.1, 0.0001 ).onChange( v => {\n\n\t\tdiamond.material.uniforms.aberrationStrength.value = v;\n\n\t} );\n\n\tstats = new Stats();\n\tstats.showPanel( 0 );\n\tdocument.body.appendChild( stats.dom );\n\trender();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\t\tdiamond.material.uniforms.resolution.value.set( window.innerWidth, window.innerHeight );\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n}\n\nfunction render() {\n\n\tif ( params.animate ) {\n\n\t\tdiamond.rotation.y += clock.getDelta() * 0.25;\n\n\t}\n\n\tstats.update();\n\tcontrols.update();\n\trenderer.render( scene, camera );\n\trequestAnimationFrame( render );\n\n}\n","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearEncoding,\n\tLinearFilter\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* return codes for rgbe routines */\n\t\t\t//RGBE_RETURN_SUCCESS = 0,\n\t\t\tRGBE_RETURN_FAILURE = - 1,\n\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn RGBE_RETURN_FAILURE;\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\n\n\t\t\tconst w = rgbe_header_info.width,\n\t\t\t\th = rgbe_header_info.height,\n\t\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\t\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\n\n\t\t\t\tlet data, type;\n\t\t\t\tlet numElements;\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = floatArray;\n\t\t\t\t\t\ttype = FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = halfArray;\n\t\t\t\t\t\ttype = HalfFloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.error( 'THREE.RGBELoader: unsupported type: ', this.type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: w, height: h,\n\t\t\t\t\tdata: data,\n\t\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\t\ttype: type\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","var Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time >= prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport default Stats;\n"],"names":["$e7bc8b365f81c957$var$scene","$e7bc8b365f81c957$var$camera","$e7bc8b365f81c957$var$renderer","$e7bc8b365f81c957$var$environment","$e7bc8b365f81c957$var$controls","$e7bc8b365f81c957$var$diamond","$e7bc8b365f81c957$var$gui","$e7bc8b365f81c957$var$stats","$e7bc8b365f81c957$var$clock","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$ilwiq","$jiuw3","$5Rd1x","$7lx9d","$5ee05658f4b0e3bf$export$d076a711b55c758a","DataTextureLoader","constructor","manager","type","HalfFloatType","parse","buffer","rgbe_error","rgbe_error_code","msg","console","error","fgets","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","byteArray","Uint8Array","rgbe_header_info","RGBE_ReadHeader","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_RETURN_FAILURE","w","h","image_rgba_data","RGBE_ReadPixels_RLE","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","set","off","data","numElements","FloatType","floatArray","Float32Array","j","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","scale","Math","pow","e","halfArray","RGBEByteToRGBHalf","DataUtils","toHalfFloat","min","setDataType","value","load","url","onLoad","onProgress","onError","texture","texData","encoding","LinearEncoding","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","$5aae44c9b1864d53$var$Stats","mode","container","document","createElement","addPanel","panel","appendChild","dom","showPanel","children","style","display","cssText","addEventListener","event","preventDefault","beginTime","performance","Date","now","prevTime","frames","fpsPanel","Panel","msPanel","self","memory","memPanel","REVISION","begin","end","time","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","name","fg","bg","Infinity","max","round","PR","window","devicePixelRatio","WIDTH","HEIGHT","TEXT_X","TEXT_Y","GRAPH_X","GRAPH_Y","GRAPH_WIDTH","GRAPH_HEIGHT","canvas","context","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","maxValue","drawImage","$gcCUH","$ff8ed","$boAbX","$Mleu6","$e7bc8b365f81c957$var$params","color","bounces","ior","aberrationStrength","fastChroma","animate","$e7bc8b365f81c957$var$init","gltf","Scene","PerspectiveCamera","innerWidth","innerHeight","position","WebGLRenderer","antialias","setSize","outputEncoding","sRGBEncoding","toneMapping","ACESFilmicToneMapping","body","OrbitControls","Clock","environmentPromise","loadAsync","gltfPromise","GLTFLoader","Promise","all","mapping","EquirectangularReflectionMapping","LinearMipmapLinearFilter","background","diamondMaterial","ShaderMaterial","uniforms","envMap","bvh","MeshBVHUniformStruct","projectionMatrixInv","projectionMatrixInverse","viewMatrixInv","matrixWorld","resolution","Vector2","Color","vertexShader","fragmentShader","common_functions","bvh_struct_definitions","bvh_ray_functions","diamondGeo","scene","geometry","MeshBVH","strategy","SAH","maxLeafTris","updateFrom","Mesh","add","GUI","addColor","onChange","v","material","$e7bc8b365f81c957$var$render","rotation","y","getDelta","render","requestAnimationFrame","aspect","updateProjectionMatrix"],"version":3,"file":"diamond.7afaf405.js.map"}