{"mappings":"IMeI,EAAO,EAAQ,EAAU,EAAQ,EAAM,EAAiB,EACxD,EAAc,EAAc,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,iB,I,G,I,E,E,SLyBhC,IAAM,EAAU,IAAI,EAAA,kBAAiB,CAAG,GAAK,EAAG,EAAG,GAAK,EAAG,GAIrD,EAAY,IAAI,EAAA,cAAa,CACnC,EAAU,YAAY,CAAE,WAAY,IAAI,EAAA,sBAAqB,CAAG,CAAE,GAAK,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,EAAG,CAAE,IACvG,EAAU,YAAY,CAAE,KAAM,IAAI,EAAA,sBAAqB,CAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAE,GAEhF,OAAM,EAEL,YAAa,CAAQ,CAAG,CAEvB,IAAI,CAAC,KAAK,CAAG,IAAI,EAAA,IAAG,CAAG,EAAW,EAEnC,CAEA,SAAU,CAET,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,EAE5B,CAEA,OAAQ,CAAQ,CAAG,CAElB,EAAS,MAAM,CAAE,IAAI,CAAC,KAAK,CAAE,EAE9B,CAEA,IAAI,UAAW,CAEd,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,AAE3B,CAEA,IAAI,SAAU,CAAK,CAAG,CAErB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAG,CAEvB,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,qB,I,G,E,E,O,C,oB,I,G,E,E,O,C,oB,I,G,I,E,E,S,E,E,S,E,E,SC7EA,IAAM,EAAsB,IAAI,EAAA,GAAE,CAC5B,EAAmC,IAAI,EAAA,OAAM,CAC7C,EAAsB,AAAA,EAAA,IAAG,CAAE,SAAS,CAAC,OAAO,CAE3C,SAAS,EAAoB,CAA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","sources":["<anon>","node_modules/three/examples/jsm/postprocessing/Pass.js","src/utils/ExtensionUtilities.js","src/utils/GeometryRayIntersectUtilities.js","src/debug/Debug.js","src/objects/MeshBVHHelper.js","example/inspector.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"RPVlj\", function(module, exports) {\n\n$parcel$export(module.exports, \"FullScreenQuad\", () => $0a1d3a5a6a49de03$export$3983474c8e6e978b);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $0a1d3a5a6a49de03$export$802bc10488da99c7 {\n    constructor(){\n        this.isPass = true;\n        // if set to true, the pass is processed by the composer\n        this.enabled = true;\n        // if set to true, the pass indicates to swap read and write buffer after rendering\n        this.needsSwap = true;\n        // if set to true, the pass clears its buffer before rendering\n        this.clear = false;\n        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n        this.renderToScreen = false;\n    }\n    setSize() {}\n    render() {\n        console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n    }\n    dispose() {}\n}\n// Helper for passes that need to fill the viewport with a single quad.\nconst $0a1d3a5a6a49de03$var$_camera = new (0, $ilwiq.OrthographicCamera)(-1, 1, 1, -1, 0, 1);\n// https://github.com/mrdoob/three.js/pull/21358\nconst $0a1d3a5a6a49de03$var$_geometry = new (0, $ilwiq.BufferGeometry)();\n$0a1d3a5a6a49de03$var$_geometry.setAttribute(\"position\", new (0, $ilwiq.Float32BufferAttribute)([\n    -1,\n    3,\n    0,\n    -1,\n    -1,\n    0,\n    3,\n    -1,\n    0\n], 3));\n$0a1d3a5a6a49de03$var$_geometry.setAttribute(\"uv\", new (0, $ilwiq.Float32BufferAttribute)([\n    0,\n    2,\n    0,\n    0,\n    2,\n    0\n], 2));\nclass $0a1d3a5a6a49de03$export$3983474c8e6e978b {\n    constructor(material){\n        this._mesh = new (0, $ilwiq.Mesh)($0a1d3a5a6a49de03$var$_geometry, material);\n    }\n    dispose() {\n        this._mesh.geometry.dispose();\n    }\n    render(renderer) {\n        renderer.render(this._mesh, $0a1d3a5a6a49de03$var$_camera);\n    }\n    get material() {\n        return this._mesh.material;\n    }\n    set material(value) {\n        this._mesh.material = value;\n    }\n}\n\n});\n\nparcelRegister(\"4h5hN\", function(module, exports) {\n\n$parcel$export(module.exports, \"acceleratedRaycast\", () => $31ccd9a92979d6bb$export$a0dc2935489c814a);\n$parcel$export(module.exports, \"computeBoundsTree\", () => $31ccd9a92979d6bb$export$749bba8a65fa6d70);\n$parcel$export(module.exports, \"disposeBoundsTree\", () => $31ccd9a92979d6bb$export$e0a981a7a32ddba4);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $b4YKL = parcelRequire(\"b4YKL\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $31ccd9a92979d6bb$var$ray = /* @__PURE__ */ new (0, $ilwiq.Ray)();\nconst $31ccd9a92979d6bb$var$tmpInverseMatrix = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $31ccd9a92979d6bb$var$origMeshRaycastFunc = (0, $ilwiq.Mesh).prototype.raycast;\nfunction $31ccd9a92979d6bb$export$a0dc2935489c814a(raycaster, intersects) {\n    if (this.geometry.boundsTree) {\n        if (this.material === undefined) return;\n        $31ccd9a92979d6bb$var$tmpInverseMatrix.copy(this.matrixWorld).invert();\n        $31ccd9a92979d6bb$var$ray.copy(raycaster.ray).applyMatrix4($31ccd9a92979d6bb$var$tmpInverseMatrix);\n        const bvh = this.geometry.boundsTree;\n        if (raycaster.firstHitOnly === true) {\n            const hit = (0, $b4YKL.convertRaycastIntersect)(bvh.raycastFirst($31ccd9a92979d6bb$var$ray, this.material), this, raycaster);\n            if (hit) intersects.push(hit);\n        } else {\n            const hits = bvh.raycast($31ccd9a92979d6bb$var$ray, this.material);\n            for(let i = 0, l = hits.length; i < l; i++){\n                const hit = (0, $b4YKL.convertRaycastIntersect)(hits[i], this, raycaster);\n                if (hit) intersects.push(hit);\n            }\n        }\n    } else $31ccd9a92979d6bb$var$origMeshRaycastFunc.call(this, raycaster, intersects);\n}\nfunction $31ccd9a92979d6bb$export$749bba8a65fa6d70(options) {\n    this.boundsTree = new (0, $ff8ed.MeshBVH)(this, options);\n    return this.boundsTree;\n}\nfunction $31ccd9a92979d6bb$export$e0a981a7a32ddba4() {\n    this.boundsTree = null;\n}\n\n});\nparcelRegister(\"b4YKL\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertRaycastIntersect\", () => $810f31c6ff4f494e$export$adb106eed99e8cd8);\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nfunction $810f31c6ff4f494e$export$adb106eed99e8cd8(hit, object, raycaster) {\n    if (hit === null) return null;\n    hit.point.applyMatrix4(object.matrixWorld);\n    hit.distance = hit.point.distanceTo(raycaster.ray.origin);\n    hit.object = object;\n    if (hit.distance < raycaster.near || hit.distance > raycaster.far) return null;\n    else return hit;\n}\n\n});\n\n\nparcelRegister(\"38WKP\", function(module, exports) {\n\n$parcel$export(module.exports, \"getBVHExtremes\", () => $249fb1d4ac2bb894$export$de5f6c317656a6ce);\n$parcel$export(module.exports, \"estimateMemoryInBytes\", () => $249fb1d4ac2bb894$export$d677314be3f8df27);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $2zRsl = parcelRequire(\"2zRsl\");\nconst $249fb1d4ac2bb894$var$_box1 = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nconst $249fb1d4ac2bb894$var$_box2 = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nconst $249fb1d4ac2bb894$var$_vec = /* @__PURE__ */ new (0, $ilwiq.Vector3)();\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction $249fb1d4ac2bb894$var$getPrimitiveSize(el) {\n    switch(typeof el){\n        case \"number\":\n            return 8;\n        case \"string\":\n            return el.length * 2;\n        case \"boolean\":\n            return 4;\n        default:\n            return 0;\n    }\n}\nfunction $249fb1d4ac2bb894$var$isTypedArray(arr) {\n    const regex = /(Uint|Int|Float)(8|16|32)Array/;\n    return regex.test(arr.constructor.name);\n}\nfunction $249fb1d4ac2bb894$var$getRootExtremes(bvh, group) {\n    const result = {\n        nodeCount: 0,\n        leafNodeCount: 0,\n        depth: {\n            min: Infinity,\n            max: -Infinity\n        },\n        tris: {\n            min: Infinity,\n            max: -Infinity\n        },\n        splits: [\n            0,\n            0,\n            0\n        ],\n        surfaceAreaScore: 0\n    };\n    bvh.traverse((depth, isLeaf, boundingData, offsetOrSplit, count)=>{\n        const l0 = boundingData[3] - boundingData[0];\n        const l1 = boundingData[4] - boundingData[1];\n        const l2 = boundingData[5] - boundingData[2];\n        const surfaceArea = 2 * (l0 * l1 + l1 * l2 + l2 * l0);\n        result.nodeCount++;\n        if (isLeaf) {\n            result.leafNodeCount++;\n            result.depth.min = Math.min(depth, result.depth.min);\n            result.depth.max = Math.max(depth, result.depth.max);\n            result.tris.min = Math.min(count, result.tris.min);\n            result.tris.max = Math.max(count, result.tris.max);\n            result.surfaceAreaScore += surfaceArea * (0, $Mleu6.TRIANGLE_INTERSECT_COST) * count;\n        } else {\n            result.splits[offsetOrSplit]++;\n            result.surfaceAreaScore += surfaceArea * (0, $Mleu6.TRAVERSAL_COST);\n        }\n    }, group);\n    // If there are no leaf nodes because the tree hasn't finished generating yet.\n    if (result.tris.min === Infinity) {\n        result.tris.min = 0;\n        result.tris.max = 0;\n    }\n    if (result.depth.min === Infinity) {\n        result.depth.min = 0;\n        result.depth.max = 0;\n    }\n    return result;\n}\nfunction $249fb1d4ac2bb894$export$de5f6c317656a6ce(bvh) {\n    return bvh._roots.map((root, i)=>$249fb1d4ac2bb894$var$getRootExtremes(bvh, i));\n}\nfunction $249fb1d4ac2bb894$export$d677314be3f8df27(obj) {\n    const traversed = new Set();\n    const stack = [\n        obj\n    ];\n    let bytes = 0;\n    while(stack.length){\n        const curr = stack.pop();\n        if (traversed.has(curr)) continue;\n        traversed.add(curr);\n        for(let key in curr){\n            if (!curr.hasOwnProperty(key)) continue;\n            bytes += $249fb1d4ac2bb894$var$getPrimitiveSize(key);\n            const value = curr[key];\n            if (value && (typeof value === \"object\" || typeof value === \"function\")) {\n                if ($249fb1d4ac2bb894$var$isTypedArray(value)) bytes += value.byteLength;\n                else if ((0, $2zRsl.isSharedArrayBufferSupported)() && value instanceof SharedArrayBuffer) bytes += value.byteLength;\n                else if (value instanceof ArrayBuffer) bytes += value.byteLength;\n                else stack.push(value);\n            } else bytes += $249fb1d4ac2bb894$var$getPrimitiveSize(value);\n        }\n    }\n    return bytes;\n}\nfunction $249fb1d4ac2bb894$export$51e58a02740fe411(bvh) {\n    const geometry = bvh.geometry;\n    const depthStack = [];\n    const index = geometry.index;\n    const position = geometry.getAttribute(\"position\");\n    let passes = true;\n    bvh.traverse((depth, isLeaf, boundingData, offset, count)=>{\n        const info = {\n            depth: depth,\n            isLeaf: isLeaf,\n            boundingData: boundingData,\n            offset: offset,\n            count: count\n        };\n        depthStack[depth] = info;\n        (0, $aw71y.arrayToBox)(0, boundingData, $249fb1d4ac2bb894$var$_box1);\n        const parent = depthStack[depth - 1];\n        if (isLeaf) // check triangles\n        for(let i = offset, l = offset + count; i < l; i++){\n            const triIndex = bvh.resolveTriangleIndex(i);\n            let i0 = 3 * triIndex;\n            let i1 = 3 * triIndex + 1;\n            let i2 = 3 * triIndex + 2;\n            if (index) {\n                i0 = index.getX(i0);\n                i1 = index.getX(i1);\n                i2 = index.getX(i2);\n            }\n            let isContained;\n            $249fb1d4ac2bb894$var$_vec.fromBufferAttribute(position, i0);\n            isContained = $249fb1d4ac2bb894$var$_box1.containsPoint($249fb1d4ac2bb894$var$_vec);\n            $249fb1d4ac2bb894$var$_vec.fromBufferAttribute(position, i1);\n            isContained = isContained && $249fb1d4ac2bb894$var$_box1.containsPoint($249fb1d4ac2bb894$var$_vec);\n            $249fb1d4ac2bb894$var$_vec.fromBufferAttribute(position, i2);\n            isContained = isContained && $249fb1d4ac2bb894$var$_box1.containsPoint($249fb1d4ac2bb894$var$_vec);\n            console.assert(isContained, \"Leaf bounds does not fully contain triangle.\");\n            passes = passes && isContained;\n        }\n        if (parent) {\n            // check if my bounds fit in my parents\n            (0, $aw71y.arrayToBox)(0, boundingData, $249fb1d4ac2bb894$var$_box2);\n            const isContained = $249fb1d4ac2bb894$var$_box2.containsBox($249fb1d4ac2bb894$var$_box1);\n            console.assert(isContained, \"Parent bounds does not fully contain child.\");\n            passes = passes && isContained;\n        }\n    });\n    return passes;\n}\n// Returns a simple, human readable object that represents the BVH.\nfunction $249fb1d4ac2bb894$export$b16a0ec7b99c6f74(bvh) {\n    const depthStack = [];\n    bvh.traverse((depth, isLeaf, boundingData, offset, count)=>{\n        const info = {\n            bounds: (0, $aw71y.arrayToBox)(0, boundingData, new (0, $ilwiq.Box3)())\n        };\n        if (isLeaf) {\n            info.count = count;\n            info.offset = offset;\n        } else {\n            info.left = null;\n            info.right = null;\n        }\n        depthStack[depth] = info;\n        // traversal hits the left then right node\n        const parent = depthStack[depth - 1];\n        if (parent) {\n            if (parent.left === null) parent.left = info;\n            else parent.right = info;\n        }\n    });\n    return depthStack[0];\n}\n\n});\n\nparcelRegister(\"5ca9G\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHHelper\", () => $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $3c85f35a8c29fa9b$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nclass $3c85f35a8c29fa9b$var$MeshBVHRootHelper extends (0, $ilwiq.Object3D) {\n    get isMesh() {\n        return !this.displayEdges;\n    }\n    get isLineSegments() {\n        return this.displayEdges;\n    }\n    get isLine() {\n        return this.displayEdges;\n    }\n    constructor(bvh, material, depth = 10, group = 0){\n        super();\n        this.material = material;\n        this.geometry = new (0, $ilwiq.BufferGeometry)();\n        this.name = \"MeshBVHRootHelper\";\n        this.depth = depth;\n        this.displayParents = false;\n        this.bvh = bvh;\n        this.displayEdges = true;\n        this._group = group;\n    }\n    raycast() {}\n    update() {\n        const geometry = this.geometry;\n        const boundsTree = this.bvh;\n        const group = this._group;\n        geometry.dispose();\n        this.visible = false;\n        if (boundsTree) {\n            // count the number of bounds required\n            const targetDepth = this.depth - 1;\n            const displayParents = this.displayParents;\n            let boundsCount = 0;\n            boundsTree.traverse((depth, isLeaf)=>{\n                if (depth >= targetDepth || isLeaf) {\n                    boundsCount++;\n                    return true;\n                } else if (displayParents) boundsCount++;\n            }, group);\n            // fill in the position buffer with the bounds corners\n            let posIndex = 0;\n            const positionArray = new Float32Array(24 * boundsCount);\n            boundsTree.traverse((depth, isLeaf, boundingData)=>{\n                const terminate = depth >= targetDepth || isLeaf;\n                if (terminate || displayParents) {\n                    (0, $aw71y.arrayToBox)(0, boundingData, $3c85f35a8c29fa9b$var$boundingBox);\n                    const { min: min, max: max } = $3c85f35a8c29fa9b$var$boundingBox;\n                    for(let x = -1; x <= 1; x += 2){\n                        const xVal = x < 0 ? min.x : max.x;\n                        for(let y = -1; y <= 1; y += 2){\n                            const yVal = y < 0 ? min.y : max.y;\n                            for(let z = -1; z <= 1; z += 2){\n                                const zVal = z < 0 ? min.z : max.z;\n                                positionArray[posIndex + 0] = xVal;\n                                positionArray[posIndex + 1] = yVal;\n                                positionArray[posIndex + 2] = zVal;\n                                posIndex += 3;\n                            }\n                        }\n                    }\n                    return terminate;\n                }\n            }, group);\n            let indexArray;\n            let indices;\n            if (this.displayEdges) // fill in the index buffer to point to the corner points\n            indices = new Uint8Array([\n                // x axis\n                0,\n                4,\n                1,\n                5,\n                2,\n                6,\n                3,\n                7,\n                // y axis\n                0,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                7,\n                // z axis\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7\n            ]);\n            else indices = new Uint8Array([\n                // X-, X+\n                0,\n                1,\n                2,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                6,\n                7,\n                5,\n                // Y-, Y+\n                1,\n                4,\n                5,\n                0,\n                4,\n                1,\n                2,\n                3,\n                6,\n                3,\n                7,\n                6,\n                // Z-, Z+\n                0,\n                2,\n                4,\n                2,\n                6,\n                4,\n                1,\n                5,\n                3,\n                3,\n                5,\n                7\n            ]);\n            if (positionArray.length > 65535) indexArray = new Uint32Array(indices.length * boundsCount);\n            else indexArray = new Uint16Array(indices.length * boundsCount);\n            const indexLength = indices.length;\n            for(let i = 0; i < boundsCount; i++){\n                const posOffset = i * 8;\n                const indexOffset = i * indexLength;\n                for(let j = 0; j < indexLength; j++)indexArray[indexOffset + j] = posOffset + indices[j];\n            }\n            // update the geometry\n            geometry.setIndex(new (0, $ilwiq.BufferAttribute)(indexArray, 1, false));\n            geometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(positionArray, 3, false));\n            this.visible = true;\n        }\n    }\n}\nclass $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 extends (0, $ilwiq.Group) {\n    get color() {\n        return this.edgeMaterial.color;\n    }\n    get opacity() {\n        return this.edgeMaterial.opacity;\n    }\n    set opacity(v) {\n        this.edgeMaterial.opacity = v;\n        this.meshMaterial.opacity = v;\n    }\n    constructor(mesh = null, bvh = null, depth = 10){\n        // handle bvh, depth signature\n        if (mesh instanceof (0, $ff8ed.MeshBVH)) {\n            depth = bvh || 10;\n            bvh = mesh;\n            mesh = null;\n        }\n        // handle mesh, depth signature\n        if (typeof bvh === \"number\") {\n            depth = bvh;\n            bvh = null;\n        }\n        super();\n        this.name = \"MeshBVHHelper\";\n        this.depth = depth;\n        this.mesh = mesh;\n        this.bvh = bvh;\n        this.displayParents = false;\n        this.displayEdges = true;\n        this._roots = [];\n        const edgeMaterial = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        const meshMaterial = new (0, $ilwiq.MeshBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        meshMaterial.color = edgeMaterial.color;\n        this.edgeMaterial = edgeMaterial;\n        this.meshMaterial = meshMaterial;\n        this.update();\n    }\n    update() {\n        const bvh = this.bvh || this.mesh.geometry.boundsTree;\n        const totalRoots = bvh ? bvh._roots.length : 0;\n        while(this._roots.length > totalRoots){\n            const root = this._roots.pop();\n            root.geometry.dispose();\n            this.remove(root);\n        }\n        for(let i = 0; i < totalRoots; i++){\n            const { depth: depth, edgeMaterial: edgeMaterial, meshMaterial: meshMaterial, displayParents: displayParents, displayEdges: displayEdges } = this;\n            if (i >= this._roots.length) {\n                const root = new $3c85f35a8c29fa9b$var$MeshBVHRootHelper(bvh, edgeMaterial, depth, i);\n                this.add(root);\n                this._roots.push(root);\n            }\n            const root = this._roots[i];\n            root.bvh = bvh;\n            root.depth = depth;\n            root.displayParents = displayParents;\n            root.displayEdges = displayEdges;\n            root.material = displayEdges ? edgeMaterial : meshMaterial;\n            root.update();\n        }\n    }\n    updateMatrixWorld(...args) {\n        const mesh = this.mesh;\n        const parent = this.parent;\n        if (mesh !== null) {\n            mesh.updateWorldMatrix(true, false);\n            if (parent) this.matrix.copy(parent.matrixWorld).invert().multiply(mesh.matrixWorld);\n            else this.matrix.copy(mesh.matrixWorld);\n            this.matrix.decompose(this.position, this.quaternion, this.scale);\n        }\n        super.updateMatrixWorld(...args);\n    }\n    copy(source) {\n        this.depth = source.depth;\n        this.mesh = source.mesh;\n        this.bvh = source.bvh;\n        this.opacity = source.opacity;\n        this.color.copy(source.color);\n    }\n    clone() {\n        return new $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5(this.mesh, this.bvh, this.depth);\n    }\n    dispose() {\n        this.edgeMaterial.dispose();\n        this.meshMaterial.dispose();\n        const children = this.children;\n        for(let i = 0, l = children.length; i < l; i++)children[i].geometry.dispose();\n    }\n}\nclass $3c85f35a8c29fa9b$export$5ead38ed5c75a1c8 extends $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 {\n    constructor(...args){\n        super(...args);\n        console.warn(\"MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.\");\n    }\n}\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $4h5hN = parcelRequire(\"4h5hN\");\nvar $Mleu6 = parcelRequire(\"Mleu6\");\nvar $38WKP = parcelRequire(\"38WKP\");\nvar $5ca9G = parcelRequire(\"5ca9G\");\n$ilwiq.Mesh.prototype.raycast = (0, $4h5hN.acceleratedRaycast);\n$ilwiq.BufferGeometry.prototype.computeBoundsTree = (0, $4h5hN.computeBoundsTree);\n$ilwiq.BufferGeometry.prototype.disposeBoundsTree = (0, $4h5hN.disposeBoundsTree);\nlet $ccdf29cef1be036a$var$scene, $ccdf29cef1be036a$var$camera, $ccdf29cef1be036a$var$renderer, $ccdf29cef1be036a$var$helper, $ccdf29cef1be036a$var$mesh, $ccdf29cef1be036a$var$outputContainer, $ccdf29cef1be036a$var$benchmarkContainer;\nlet $ccdf29cef1be036a$var$benchmarkViz, $ccdf29cef1be036a$var$renderTarget, $ccdf29cef1be036a$var$fsQuad;\nlet $ccdf29cef1be036a$var$mouse = new $ilwiq.Vector2();\nconst $ccdf29cef1be036a$var$readBuffer = new Float32Array(1);\nconst $ccdf29cef1be036a$var$modelPath = \"../models/DragonAttenuation.glb\";\nconst $ccdf29cef1be036a$var$params = {\n    options: {\n        strategy: (0, $Mleu6.SAH),\n        maxLeafTris: 10,\n        maxDepth: 40,\n        rebuild: function() {\n            $ccdf29cef1be036a$var$updateBVH();\n        }\n    },\n    visualization: {\n        displayMesh: true,\n        simpleColors: false,\n        outline: true,\n        traversalThreshold: 50\n    },\n    benchmark: {\n        displayRays: false,\n        firstHitOnly: true,\n        rotations: 10,\n        castCount: 1000\n    }\n};\nconst $ccdf29cef1be036a$var$BOUNDS_COLOR = 0xffca28;\nconst $ccdf29cef1be036a$var$BG_COLOR = 0x002027;\nconst $ccdf29cef1be036a$var$THRESHOLD_COLOR = 0xe91e63;\nclass $ccdf29cef1be036a$var$TraverseMaterial extends $ilwiq.ShaderMaterial {\n    constructor(params){\n        super({\n            uniforms: {\n                map: {\n                    value: null\n                },\n                threshold: {\n                    value: 35\n                },\n                boundsColor: {\n                    value: new $ilwiq.Color(0xffffff)\n                },\n                backgroundColor: {\n                    value: new $ilwiq.Color(0x000000)\n                },\n                thresholdColor: {\n                    value: new $ilwiq.Color(0xff0000)\n                },\n                resolution: {\n                    value: new $ilwiq.Vector2()\n                },\n                outlineAlpha: {\n                    value: 0.5\n                }\n            },\n            vertexShader: /* glsl */ `\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float threshold;\n\n\t\t\t\tuniform vec3 thresholdColor;\n\t\t\t\tuniform vec3 boundsColor;\n\t\t\t\tuniform vec3 backgroundColor;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float outlineAlpha;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat count = texture2D( map, vUv ).r;\n\n\t\t\t\t\tif ( count == 0.0 ) {\n\n\t\t\t\t\t\tvec2 offset = 1.0 / resolution;\n\t\t\t\t\t\tfloat c1 = texture2D( map, vUv + offset * vec2( 1.0, 0.0 ) ).r;\n\t\t\t\t\t\tfloat c2 = texture2D( map, vUv + offset * vec2( - 1.0, 0.0 ) ).r;\n\t\t\t\t\t\tfloat c3 = texture2D( map, vUv + offset * vec2( 0.0, 1.0 ) ).r;\n\t\t\t\t\t\tfloat c4 = texture2D( map, vUv + offset * vec2( 0.0, - 1.0 ) ).r;\n\n\t\t\t\t\t\tfloat maxC = max( c1, max( c2, max( c3, c4 ) ) );\n\t\t\t\t\t\tif ( maxC != 0.0 ) {\n\n\t\t\t\t\t\t\tgl_FragColor.rgb = mix( backgroundColor, mix( boundsColor, vec3( 1.0 ), 0.5 ), outlineAlpha );\n\t\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( count > threshold ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = thresholdColor.rgb;\n\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfloat alpha = count / threshold;\n\t\t\t\t\t\tvec3 color = mix( boundsColor, vec3( 1.0 ), pow( alpha, 1.75 ) );\n\n\t\t\t\t\t\tgl_FragColor.rgb = mix( backgroundColor, color, alpha ).rgb ;\n\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t`\n        });\n        const uniforms = this.uniforms;\n        for(const key in uniforms)Object.defineProperty(this, key, {\n            get () {\n                return this.uniforms[key].value;\n            },\n            set (v) {\n                this.uniforms[key].value = v;\n            }\n        });\n        this.setValues(params);\n    }\n}\nfunction $ccdf29cef1be036a$var$init() {\n    $ccdf29cef1be036a$var$outputContainer = document.getElementById(\"output\");\n    $ccdf29cef1be036a$var$benchmarkContainer = document.getElementById(\"benchmark\");\n    // renderer setup\n    $ccdf29cef1be036a$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $ccdf29cef1be036a$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $ccdf29cef1be036a$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $ccdf29cef1be036a$var$renderer.setClearColor(0, 1);\n    document.body.appendChild($ccdf29cef1be036a$var$renderer.domElement);\n    // render target\n    $ccdf29cef1be036a$var$renderTarget = new $ilwiq.WebGLRenderTarget(1, 1, {\n        format: $ilwiq.RedFormat,\n        type: $ilwiq.FloatType\n    });\n    $ccdf29cef1be036a$var$fsQuad = new (0, $RPVlj.FullScreenQuad)(new $ccdf29cef1be036a$var$TraverseMaterial({\n        map: $ccdf29cef1be036a$var$renderTarget.texture,\n        depthWrite: false\n    }));\n    // scene setup\n    $ccdf29cef1be036a$var$scene = new $ilwiq.Scene();\n    // camera setup\n    $ccdf29cef1be036a$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);\n    $ccdf29cef1be036a$var$camera.position.set(-2.5, 1.5, 2.5);\n    $ccdf29cef1be036a$var$camera.far = 100;\n    $ccdf29cef1be036a$var$camera.updateProjectionMatrix();\n    new (0, $5Rd1x.OrbitControls)($ccdf29cef1be036a$var$camera, $ccdf29cef1be036a$var$renderer.domElement);\n    window.addEventListener(\"resize\", $ccdf29cef1be036a$var$onResize, false);\n    $ccdf29cef1be036a$var$onResize();\n    // Load dragon\n    const loader = new (0, $7lx9d.GLTFLoader)();\n    loader.load($ccdf29cef1be036a$var$modelPath, (gltf)=>{\n        gltf.scene.traverse((c)=>{\n            if (c.isMesh && c.name === \"Dragon\") $ccdf29cef1be036a$var$mesh = c;\n        });\n        $ccdf29cef1be036a$var$mesh.material = new $ilwiq.MeshBasicMaterial({\n            colorWrite: false\n        });\n        $ccdf29cef1be036a$var$mesh.geometry.center();\n        $ccdf29cef1be036a$var$mesh.position.set(0, 0, 0);\n        $ccdf29cef1be036a$var$scene.add($ccdf29cef1be036a$var$mesh);\n        $ccdf29cef1be036a$var$helper = new (0, $5ca9G.MeshBVHHelper)($ccdf29cef1be036a$var$mesh, 40);\n        $ccdf29cef1be036a$var$helper.displayEdges = false;\n        $ccdf29cef1be036a$var$helper.displayParents = true;\n        $ccdf29cef1be036a$var$helper.color.set(0xffffff);\n        $ccdf29cef1be036a$var$helper.opacity = 1;\n        $ccdf29cef1be036a$var$helper.depth = 40;\n        const material = $ccdf29cef1be036a$var$helper.meshMaterial;\n        material.blending = $ilwiq.CustomBlending;\n        material.blendDst = $ilwiq.OneFactor;\n        $ccdf29cef1be036a$var$scene.add($ccdf29cef1be036a$var$helper);\n        $ccdf29cef1be036a$var$updateBVH();\n        $ccdf29cef1be036a$var$runBenchmark(true);\n    });\n    $ccdf29cef1be036a$var$benchmarkViz = new $ilwiq.LineSegments();\n    $ccdf29cef1be036a$var$benchmarkViz.material.opacity = 0.1;\n    $ccdf29cef1be036a$var$benchmarkViz.material.transparent = true;\n    $ccdf29cef1be036a$var$benchmarkViz.material.depthWrite = false;\n    $ccdf29cef1be036a$var$benchmarkViz.frustumCulled = false;\n    $ccdf29cef1be036a$var$scene.add($ccdf29cef1be036a$var$benchmarkViz);\n    const gui = new (0, $jiuw3.GUI)();\n    const bvhFolder = gui.addFolder(\"BVH\");\n    bvhFolder.add($ccdf29cef1be036a$var$params.options, \"strategy\", {\n        CENTER: $Mleu6.CENTER,\n        AVERAGE: $Mleu6.AVERAGE,\n        SAH: $Mleu6.SAH\n    });\n    bvhFolder.add($ccdf29cef1be036a$var$params.options, \"maxLeafTris\", 1, 30, 1);\n    bvhFolder.add($ccdf29cef1be036a$var$params.options, \"maxDepth\", 1, 40, 1);\n    bvhFolder.add($ccdf29cef1be036a$var$params.options, \"rebuild\");\n    bvhFolder.open();\n    const vizFolder = gui.addFolder(\"Visualization\");\n    vizFolder.add($ccdf29cef1be036a$var$params.visualization, \"displayMesh\");\n    vizFolder.add($ccdf29cef1be036a$var$params.visualization, \"simpleColors\");\n    vizFolder.add($ccdf29cef1be036a$var$params.visualization, \"outline\");\n    vizFolder.add($ccdf29cef1be036a$var$params.visualization, \"traversalThreshold\", 1, 300, 1);\n    vizFolder.open();\n    const benchmarkFolder = gui.addFolder(\"Benchmark\");\n    benchmarkFolder.add($ccdf29cef1be036a$var$params.benchmark, \"displayRays\");\n    benchmarkFolder.add($ccdf29cef1be036a$var$params.benchmark, \"firstHitOnly\").onChange($ccdf29cef1be036a$var$resetBenchmark);\n    benchmarkFolder.add($ccdf29cef1be036a$var$params.benchmark, \"castCount\", 100, 5000, 1).onChange(()=>{\n        $ccdf29cef1be036a$var$resetBenchmark();\n        $ccdf29cef1be036a$var$runBenchmark(true);\n    });\n    benchmarkFolder.add($ccdf29cef1be036a$var$params.benchmark, \"rotations\", 1, 20, 1).onChange(()=>{\n        $ccdf29cef1be036a$var$resetBenchmark();\n        $ccdf29cef1be036a$var$runBenchmark(true);\n    });\n    benchmarkFolder.open();\n    window.addEventListener(\"pointermove\", (e)=>{\n        $ccdf29cef1be036a$var$mouse.set(e.clientX, window.innerHeight - e.clientY);\n    });\n}\nfunction $ccdf29cef1be036a$var$onResize() {\n    $ccdf29cef1be036a$var$camera.aspect = window.innerWidth / window.innerHeight;\n    $ccdf29cef1be036a$var$camera.updateProjectionMatrix();\n    $ccdf29cef1be036a$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $ccdf29cef1be036a$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $ccdf29cef1be036a$var$renderTarget.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);\n}\nfunction $ccdf29cef1be036a$var$updateBVH() {\n    const startTime = performance.now();\n    $ccdf29cef1be036a$var$mesh.geometry.computeBoundsTree({\n        strategy: parseInt($ccdf29cef1be036a$var$params.options.strategy),\n        maxLeafTris: $ccdf29cef1be036a$var$params.options.maxLeafTris,\n        maxDepth: $ccdf29cef1be036a$var$params.options.maxDepth\n    });\n    const deltaTime = performance.now() - startTime;\n    $ccdf29cef1be036a$var$helper.update();\n    $ccdf29cef1be036a$var$resetBenchmark();\n    const info = (0, $38WKP.getBVHExtremes)($ccdf29cef1be036a$var$mesh.geometry.boundsTree)[0];\n    $ccdf29cef1be036a$var$outputContainer.innerText = `construction time        : ${deltaTime.toFixed(2)}ms\\n` + `surface area score       : ${info.surfaceAreaScore.toFixed(2)}\\n` + `total nodes              : ${info.nodeCount}\\n` + `total leaf nodes         : ${info.leafNodeCount}\\n` + `min / max tris per leaf  : ${info.tris.min} / ${info.tris.max}\\n` + `min / max depth          : ${info.depth.min} / ${info.depth.max}\\n` + `memory (incl. geometry)  : ${((0, $38WKP.estimateMemoryInBytes)($ccdf29cef1be036a$var$mesh.geometry.boundsTree) * 1e-6).toFixed(3)} mb \\n` + `memory (excl. geometry)  : ${((0, $38WKP.estimateMemoryInBytes)($ccdf29cef1be036a$var$mesh.geometry.boundsTree._roots) * 1e-6).toFixed(3)} mb`;\n}\nfunction $ccdf29cef1be036a$var$runBenchmark(updateGeom = false) {\n    let points = null;\n    let newGeometry = null;\n    if (updateGeom) {\n        $ccdf29cef1be036a$var$mesh.updateMatrixWorld();\n        newGeometry = new $ilwiq.BufferGeometry();\n        $ccdf29cef1be036a$var$benchmarkViz.geometry.dispose();\n        points = [];\n    }\n    const raycaster = new $ilwiq.Raycaster();\n    raycaster.firstHitOnly = $ccdf29cef1be036a$var$params.benchmark.firstHitOnly;\n    const rayCount = $ccdf29cef1be036a$var$params.benchmark.castCount;\n    const rotations = $ccdf29cef1be036a$var$params.benchmark.rotations;\n    const { ray: ray } = raycaster;\n    const { origin: origin, direction: direction } = ray;\n    const startTime = performance.now();\n    for(let i = 0; i < rayCount; i++){\n        const step = i / rayCount;\n        const y = step - 0.5;\n        origin.set(Math.cos(0.75 * Math.PI * y) * Math.sin(rotations * 2 * Math.PI * i / rayCount), 2 * y, Math.cos(0.75 * Math.PI * y) * Math.cos(rotations * 2 * Math.PI * i / rayCount)).multiplyScalar(2.5);\n        direction.set(Math.cos(rotations * 5 * y), Math.sin(rotations * 10 * y), Math.sin(rotations * 5 * y)).sub(origin).normalize();\n        raycaster.intersectObject($ccdf29cef1be036a$var$mesh);\n        if (updateGeom) {\n            const hit = raycaster.intersectObject($ccdf29cef1be036a$var$mesh)[0];\n            points.push(origin.clone());\n            if (hit) points.push(hit.point.clone());\n            else {\n                const v = new $ilwiq.Vector3();\n                ray.at(5, v);\n                points.push(v);\n            }\n        }\n    }\n    const deltaTime = performance.now() - startTime;\n    if (updateGeom) {\n        newGeometry.setFromPoints(points);\n        $ccdf29cef1be036a$var$benchmarkViz.geometry = newGeometry;\n    }\n    return deltaTime;\n}\nlet $ccdf29cef1be036a$var$sampleCount = 0;\nlet $ccdf29cef1be036a$var$currTime = 0;\nfunction $ccdf29cef1be036a$var$resetBenchmark() {\n    $ccdf29cef1be036a$var$sampleCount = 0;\n    $ccdf29cef1be036a$var$currTime = 0;\n}\nfunction $ccdf29cef1be036a$var$render() {\n    requestAnimationFrame($ccdf29cef1be036a$var$render);\n    // read the buffer from the last frame of rendering so we don't block\n    // waiting for this frame to finish.\n    const pixelRatio = $ccdf29cef1be036a$var$renderer.getPixelRatio();\n    $ccdf29cef1be036a$var$renderer.readRenderTargetPixels($ccdf29cef1be036a$var$renderTarget, $ccdf29cef1be036a$var$mouse.x * pixelRatio, $ccdf29cef1be036a$var$mouse.y * pixelRatio, 1, 1, $ccdf29cef1be036a$var$readBuffer);\n    if ($ccdf29cef1be036a$var$mesh) {\n        $ccdf29cef1be036a$var$sampleCount = Math.min($ccdf29cef1be036a$var$sampleCount + 1, 50);\n        $ccdf29cef1be036a$var$currTime += ($ccdf29cef1be036a$var$runBenchmark() - $ccdf29cef1be036a$var$currTime) / $ccdf29cef1be036a$var$sampleCount;\n        $ccdf29cef1be036a$var$benchmarkContainer.innerText = `\\ntraversal depth at mouse : ${Math.round($ccdf29cef1be036a$var$readBuffer[0])}\\n` + `benchmark rolling avg    : ${$ccdf29cef1be036a$var$currTime.toFixed(3)} ms`;\n    }\n    if ($ccdf29cef1be036a$var$params.visualization.simpleColors) {\n        $ccdf29cef1be036a$var$fsQuad.material.boundsColor.set(0xffffff);\n        $ccdf29cef1be036a$var$fsQuad.material.thresholdColor.set(0xff0000);\n        $ccdf29cef1be036a$var$fsQuad.material.backgroundColor.set(0x000000);\n    } else {\n        $ccdf29cef1be036a$var$fsQuad.material.boundsColor.set($ccdf29cef1be036a$var$BOUNDS_COLOR);\n        $ccdf29cef1be036a$var$fsQuad.material.thresholdColor.set($ccdf29cef1be036a$var$THRESHOLD_COLOR);\n        $ccdf29cef1be036a$var$fsQuad.material.backgroundColor.set($ccdf29cef1be036a$var$BG_COLOR);\n    }\n    $ccdf29cef1be036a$var$fsQuad.material.threshold = $ccdf29cef1be036a$var$params.visualization.traversalThreshold;\n    $ccdf29cef1be036a$var$fsQuad.material.outlineAlpha = $ccdf29cef1be036a$var$params.visualization.outline ? 0.5 : 0.0;\n    $ccdf29cef1be036a$var$fsQuad.material.resolution.set($ccdf29cef1be036a$var$renderTarget.width, $ccdf29cef1be036a$var$renderTarget.height);\n    // render bvh\n    $ccdf29cef1be036a$var$benchmarkViz.visible = false;\n    $ccdf29cef1be036a$var$renderer.autoClear = true;\n    if ($ccdf29cef1be036a$var$mesh) $ccdf29cef1be036a$var$mesh.visible = $ccdf29cef1be036a$var$params.visualization.displayMesh;\n    $ccdf29cef1be036a$var$renderer.setRenderTarget($ccdf29cef1be036a$var$renderTarget);\n    $ccdf29cef1be036a$var$renderer.render($ccdf29cef1be036a$var$scene, $ccdf29cef1be036a$var$camera);\n    $ccdf29cef1be036a$var$renderer.setRenderTarget(null);\n    $ccdf29cef1be036a$var$fsQuad.render($ccdf29cef1be036a$var$renderer);\n    // render rays\n    $ccdf29cef1be036a$var$renderer.autoClear = false;\n    $ccdf29cef1be036a$var$benchmarkViz.visible = $ccdf29cef1be036a$var$params.benchmark.displayRays;\n    if ($ccdf29cef1be036a$var$mesh) $ccdf29cef1be036a$var$renderer.render($ccdf29cef1be036a$var$mesh, $ccdf29cef1be036a$var$camera);\n    $ccdf29cef1be036a$var$renderer.render($ccdf29cef1be036a$var$benchmarkViz, $ccdf29cef1be036a$var$camera);\n}\n$ccdf29cef1be036a$var$init();\n$ccdf29cef1be036a$var$render();\n\n\n//# sourceMappingURL=inspector.e2ab9340.js.map\n","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\tthis.isPass = true;\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nconst _geometry = new BufferGeometry();\n_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n","import { Box3, Vector3 } from 'three';\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\n\nconst _box1 = /* @__PURE__ */ new Box3();\nconst _box2 = /* @__PURE__ */ new Box3();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction getPrimitiveSize( el ) {\n\n\tswitch ( typeof el ) {\n\n\t\tcase 'number':\n\t\t\treturn 8;\n\t\tcase 'string':\n\t\t\treturn el.length * 2;\n\t\tcase 'boolean':\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn 0;\n\n\t}\n\n}\n\nfunction isTypedArray( arr ) {\n\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\treturn regex.test( arr.constructor.name );\n\n}\n\nfunction getRootExtremes( bvh, group ) {\n\n\tconst result = {\n\t\tnodeCount: 0,\n\t\tleafNodeCount: 0,\n\n\t\tdepth: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\ttris: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\tsplits: [ 0, 0, 0 ],\n\t\tsurfaceAreaScore: 0,\n\t};\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\tresult.nodeCount ++;\n\t\tif ( isLeaf ) {\n\n\t\t\tresult.leafNodeCount ++;\n\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t} else {\n\n\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t}\n\n\t}, group );\n\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\tif ( result.tris.min === Infinity ) {\n\n\t\tresult.tris.min = 0;\n\t\tresult.tris.max = 0;\n\n\t}\n\n\tif ( result.depth.min === Infinity ) {\n\n\t\tresult.depth.min = 0;\n\t\tresult.depth.max = 0;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getBVHExtremes( bvh ) {\n\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n}\n\nfunction estimateMemoryInBytes( obj ) {\n\n\tconst traversed = new Set();\n\tconst stack = [ obj ];\n\tlet bytes = 0;\n\n\twhile ( stack.length ) {\n\n\t\tconst curr = stack.pop();\n\t\tif ( traversed.has( curr ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\ttraversed.add( curr );\n\n\t\tfor ( let key in curr ) {\n\n\t\t\tif ( ! curr.hasOwnProperty( key ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\tconst value = curr[ key ];\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\treturn bytes;\n\n}\n\nfunction validateBounds( bvh ) {\n\n\tconst geometry = bvh.geometry;\n\tconst depthStack = [];\n\tconst index = geometry.index;\n\tconst position = geometry.getAttribute( 'position' );\n\tlet passes = true;\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tdepth,\n\t\t\tisLeaf,\n\t\t\tboundingData,\n\t\t\toffset,\n\t\t\tcount,\n\t\t};\n\t\tdepthStack[ depth ] = info;\n\n\t\tarrayToBox( 0, boundingData, _box1 );\n\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\tif ( isLeaf ) {\n\n\t\t\t// check triangles\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst triIndex = bvh.resolveTriangleIndex( i );\n\t\t\t\tlet i0 = 3 * triIndex;\n\t\t\t\tlet i1 = 3 * triIndex + 1;\n\t\t\t\tlet i2 = 3 * triIndex + 2;\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t\t}\n\n\t\t\t\tlet isContained;\n\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parent ) {\n\n\t\t\t// check if my bounds fit in my parents\n\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\tpasses = passes && isContained;\n\n\t\t}\n\n\t} );\n\n\treturn passes;\n\n}\n\n// Returns a simple, human readable object that represents the BVH.\nfunction getJSONStructure( bvh ) {\n\n\tconst depthStack = [];\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\n\t\t};\n\n\t\tif ( isLeaf ) {\n\n\t\t\tinfo.count = count;\n\t\t\tinfo.offset = offset;\n\n\t\t} else {\n\n\t\t\tinfo.left = null;\n\t\t\tinfo.right = null;\n\n\t\t}\n\n\t\tdepthStack[ depth ] = info;\n\n\t\t// traversal hits the left then right node\n\t\tconst parent = depthStack[ depth - 1 ];\n\t\tif ( parent ) {\n\n\t\t\tif ( parent.left === null ) {\n\n\t\t\t\tparent.left = info;\n\n\t\t\t} else {\n\n\t\t\t\tparent.right = info;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn depthStack[ 0 ];\n\n}\n\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.bvh || this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\n\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport {\n\tacceleratedRaycast, computeBoundsTree, disposeBoundsTree, MeshBVHHelper,\n\tSAH, CENTER, AVERAGE, getBVHExtremes, estimateMemoryInBytes,\n} from '..';\n\nTHREE.Mesh.prototype.raycast = acceleratedRaycast;\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n\nlet scene, camera, renderer, helper, mesh, outputContainer, benchmarkContainer;\nlet benchmarkViz, renderTarget, fsQuad;\nlet mouse = new THREE.Vector2();\nconst readBuffer = new Float32Array( 1 );\n\nconst modelPath = '../models/DragonAttenuation.glb';\nconst params = {\n\n\toptions: {\n\t\tstrategy: SAH,\n\t\tmaxLeafTris: 10,\n\t\tmaxDepth: 40,\n\t\trebuild: function () {\n\n\t\t\tupdateBVH();\n\n\t\t},\n\t},\n\n\tvisualization: {\n\n\t\tdisplayMesh: true,\n\t\tsimpleColors: false,\n\t\toutline: true,\n\t\ttraversalThreshold: 50,\n\n\t},\n\n\tbenchmark: {\n\n\t\tdisplayRays: false,\n\t\tfirstHitOnly: true,\n\t\trotations: 10,\n\t\tcastCount: 1000,\n\n\t}\n\n};\n\nconst BOUNDS_COLOR = 0xffca28;\nconst BG_COLOR = 0x002027;\nconst THRESHOLD_COLOR = 0xe91e63;\n\nclass TraverseMaterial extends THREE.ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\t\t\t\tmap: { value: null },\n\t\t\t\tthreshold: { value: 35 },\n\n\t\t\t\tboundsColor: { value: new THREE.Color( 0xffffff ) },\n\t\t\t\tbackgroundColor: { value: new THREE.Color( 0x000000 ) },\n\t\t\t\tthresholdColor: { value: new THREE.Color( 0xff0000 ) },\n\t\t\t\tresolution: { value: new THREE.Vector2() },\n\t\t\t\toutlineAlpha: { value: 0.5 },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float threshold;\n\n\t\t\t\tuniform vec3 thresholdColor;\n\t\t\t\tuniform vec3 boundsColor;\n\t\t\t\tuniform vec3 backgroundColor;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float outlineAlpha;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat count = texture2D( map, vUv ).r;\n\n\t\t\t\t\tif ( count == 0.0 ) {\n\n\t\t\t\t\t\tvec2 offset = 1.0 / resolution;\n\t\t\t\t\t\tfloat c1 = texture2D( map, vUv + offset * vec2( 1.0, 0.0 ) ).r;\n\t\t\t\t\t\tfloat c2 = texture2D( map, vUv + offset * vec2( - 1.0, 0.0 ) ).r;\n\t\t\t\t\t\tfloat c3 = texture2D( map, vUv + offset * vec2( 0.0, 1.0 ) ).r;\n\t\t\t\t\t\tfloat c4 = texture2D( map, vUv + offset * vec2( 0.0, - 1.0 ) ).r;\n\n\t\t\t\t\t\tfloat maxC = max( c1, max( c2, max( c3, c4 ) ) );\n\t\t\t\t\t\tif ( maxC != 0.0 ) {\n\n\t\t\t\t\t\t\tgl_FragColor.rgb = mix( backgroundColor, mix( boundsColor, vec3( 1.0 ), 0.5 ), outlineAlpha );\n\t\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( count > threshold ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = thresholdColor.rgb;\n\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfloat alpha = count / threshold;\n\t\t\t\t\t\tvec3 color = mix( boundsColor, vec3( 1.0 ), pow( alpha, 1.75 ) );\n\n\t\t\t\t\t\tgl_FragColor.rgb = mix( backgroundColor, color, alpha ).rgb ;\n\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tconst uniforms = this.uniforms;\n\t\tfor ( const key in uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n\nfunction init() {\n\n\toutputContainer = document.getElementById( 'output' );\n\tbenchmarkContainer = document.getElementById( 'benchmark' );\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0, 1 );\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// render target\n\trenderTarget = new THREE.WebGLRenderTarget( 1, 1, {\n\t\tformat: THREE.RedFormat,\n\t\ttype: THREE.FloatType,\n\n\t\t// TODO: Use integer buffers once better supported in three.js\n\t\t// format: THREE.RedIntegerFormat,\n\t\t// type: THREE.UnsignedIntType,\n\t\t// internalFormat: 'R16UI'\n\t} );\n\n\tfsQuad = new FullScreenQuad( new TraverseMaterial( {\n\n\t\tmap: renderTarget.texture,\n\t\tdepthWrite: false,\n\n\t} ) );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( - 2.5, 1.5, 2.5 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\tnew OrbitControls( camera, renderer.domElement );\n\n\twindow.addEventListener( 'resize', onResize, false );\n\tonResize();\n\n\t// Load dragon\n\tconst loader = new GLTFLoader();\n\tloader\n\t\t.load( modelPath, gltf => {\n\n\t\t\tgltf.scene.traverse( c => {\n\n\t\t\t\tif ( c.isMesh && c.name === 'Dragon' ) {\n\n\t\t\t\t\tmesh = c;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tmesh.material = new THREE.MeshBasicMaterial( { colorWrite: false } );\n\t\t\tmesh.geometry.center();\n\t\t\tmesh.position.set( 0, 0, 0 );\n\t\t\tscene.add( mesh );\n\n\t\t\thelper = new MeshBVHHelper( mesh, 40 );\n\t\t\thelper.displayEdges = false;\n\t\t\thelper.displayParents = true;\n\t\t\thelper.color.set( 0xffffff );\n\t\t\thelper.opacity = 1;\n\t\t\thelper.depth = 40;\n\n\t\t\tconst material = helper.meshMaterial;\n\t\t\tmaterial.blending = THREE.CustomBlending;\n\t\t\tmaterial.blendDst = THREE.OneFactor;\n\n\t\t\tscene.add( helper );\n\n\t\t\tupdateBVH();\n\n\t\t\trunBenchmark( true );\n\n\t\t} );\n\n\tbenchmarkViz = new THREE.LineSegments();\n\tbenchmarkViz.material.opacity = 0.1;\n\tbenchmarkViz.material.transparent = true;\n\tbenchmarkViz.material.depthWrite = false;\n\tbenchmarkViz.frustumCulled = false;\n\tscene.add( benchmarkViz );\n\n\tconst gui = new GUI();\n\tconst bvhFolder = gui.addFolder( 'BVH' );\n\tbvhFolder.add( params.options, 'strategy', { CENTER, AVERAGE, SAH } );\n\tbvhFolder.add( params.options, 'maxLeafTris', 1, 30, 1 );\n\tbvhFolder.add( params.options, 'maxDepth', 1, 40, 1 );\n\tbvhFolder.add( params.options, 'rebuild' );\n\tbvhFolder.open();\n\n\tconst vizFolder = gui.addFolder( 'Visualization' );\n\tvizFolder.add( params.visualization, 'displayMesh' );\n\tvizFolder.add( params.visualization, 'simpleColors' );\n\tvizFolder.add( params.visualization, 'outline' );\n\tvizFolder.add( params.visualization, 'traversalThreshold', 1, 300, 1 );\n\tvizFolder.open();\n\n\tconst benchmarkFolder = gui.addFolder( 'Benchmark' );\n\tbenchmarkFolder.add( params.benchmark, 'displayRays' );\n\tbenchmarkFolder.add( params.benchmark, 'firstHitOnly' ).onChange( resetBenchmark );\n\tbenchmarkFolder.add( params.benchmark, 'castCount', 100, 5000, 1 ).onChange( () => {\n\n\t\tresetBenchmark();\n\t\trunBenchmark( true );\n\n\t} );\n\tbenchmarkFolder.add( params.benchmark, 'rotations', 1, 20, 1 ).onChange( () => {\n\n\t\tresetBenchmark();\n\t\trunBenchmark( true );\n\n\t} );\n\tbenchmarkFolder.open();\n\n\twindow.addEventListener( 'pointermove', e => {\n\n\t\tmouse.set( e.clientX, window.innerHeight - e.clientY );\n\n\t} );\n\n}\n\nfunction onResize() {\n\n\tcamera.aspect = window.innerWidth / window.innerHeight;\n\tcamera.updateProjectionMatrix();\n\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\n\trenderTarget.setSize(\n\t\twindow.innerWidth * window.devicePixelRatio,\n\t\twindow.innerHeight * window.devicePixelRatio,\n\t);\n\n}\n\nfunction updateBVH() {\n\n\tconst startTime = performance.now();\n\tmesh.geometry.computeBoundsTree( {\n\t\tstrategy: parseInt( params.options.strategy ),\n\t\tmaxLeafTris: params.options.maxLeafTris,\n\t\tmaxDepth: params.options.maxDepth,\n\t} );\n\tconst deltaTime = performance.now() - startTime;\n\thelper.update();\n\n\tresetBenchmark();\n\n\tconst info = getBVHExtremes( mesh.geometry.boundsTree )[ 0 ];\n\toutputContainer.innerText =\n\t\t`construction time        : ${ deltaTime.toFixed( 2 ) }ms\\n` +\n\t\t`surface area score       : ${ info.surfaceAreaScore.toFixed( 2 ) }\\n` +\n\t\t`total nodes              : ${ info.nodeCount }\\n` +\n\t\t`total leaf nodes         : ${ info.leafNodeCount }\\n` +\n\t\t`min / max tris per leaf  : ${ info.tris.min } / ${ info.tris.max }\\n` +\n\t\t`min / max depth          : ${ info.depth.min } / ${ info.depth.max }\\n` +\n\t\t`memory (incl. geometry)  : ${ ( estimateMemoryInBytes( mesh.geometry.boundsTree ) * 1e-6 ).toFixed( 3 ) } mb \\n` +\n\t\t`memory (excl. geometry)  : ${ ( estimateMemoryInBytes( mesh.geometry.boundsTree._roots ) * 1e-6 ).toFixed( 3 ) } mb`;\n\n}\n\nfunction runBenchmark( updateGeom = false ) {\n\n\tlet points = null;\n\tlet newGeometry = null;\n\tif ( updateGeom ) {\n\n\t\tmesh.updateMatrixWorld();\n\t\tnewGeometry = new THREE.BufferGeometry();\n\t\tbenchmarkViz.geometry.dispose();\n\t\tpoints = [];\n\n\t}\n\n\tconst raycaster = new THREE.Raycaster();\n\traycaster.firstHitOnly = params.benchmark.firstHitOnly;\n\n\tconst rayCount = params.benchmark.castCount;\n\tconst rotations = params.benchmark.rotations;\n\tconst { ray } = raycaster;\n\tconst { origin, direction } = ray;\n\n\tconst startTime = performance.now();\n\tfor ( let i = 0; i < rayCount; i ++ ) {\n\n\t\tconst step = i / rayCount;\n\t\tconst y = step - 0.5;\n\t\torigin.set(\n\t\t\tMath.cos( 0.75 * Math.PI * y ) * Math.sin( rotations * 2 * Math.PI * i / rayCount ),\n\t\t\t2 * y,\n\t\t\tMath.cos( 0.75 * Math.PI * y ) * Math.cos( rotations * 2 * Math.PI * i / rayCount ),\n\t\t).multiplyScalar( 2.5 );\n\n\t\tdirection.set(\n\t\t\tMath.cos( rotations * 5 * y ),\n\t\t\tMath.sin( rotations * 10 * y ),\n\t\t\tMath.sin( rotations * 5 * y ),\n\t\t).sub( origin ).normalize();\n\n\t\traycaster.intersectObject( mesh );\n\n\t\tif ( updateGeom ) {\n\n\t\t\tconst hit = raycaster.intersectObject( mesh )[ 0 ];\n\n\t\t\tpoints.push( origin.clone() );\n\t\t\tif ( hit ) {\n\n\t\t\t\tpoints.push( hit.point.clone() );\n\n\t\t\t} else {\n\n\t\t\t\tconst v = new THREE.Vector3();\n\t\t\t\tray.at( 5, v );\n\t\t\t\tpoints.push( v );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst deltaTime = performance.now() - startTime;\n\n\tif ( updateGeom ) {\n\n\t\tnewGeometry.setFromPoints( points );\n\t\tbenchmarkViz.geometry = newGeometry;\n\n\t}\n\n\treturn deltaTime;\n\n}\n\nlet sampleCount = 0;\nlet currTime = 0;\n\nfunction resetBenchmark() {\n\n\tsampleCount = 0;\n\tcurrTime = 0;\n\n}\n\nfunction render() {\n\n\trequestAnimationFrame( render );\n\n\t// read the buffer from the last frame of rendering so we don't block\n\t// waiting for this frame to finish.\n\tconst pixelRatio = renderer.getPixelRatio();\n\trenderer.readRenderTargetPixels(\n\t\trenderTarget,\n\t\tmouse.x * pixelRatio, mouse.y * pixelRatio, 1, 1,\n\t\treadBuffer,\n\t);\n\n\tif ( mesh ) {\n\n\t\tsampleCount = Math.min( sampleCount + 1, 50 );\n\t\tcurrTime += ( runBenchmark() - currTime ) / sampleCount;\n\t\tbenchmarkContainer.innerText =\n\t\t\t`\\ntraversal depth at mouse : ${ Math.round( readBuffer[ 0 ] ) }\\n` +\n\t\t\t`benchmark rolling avg    : ${ currTime.toFixed( 3 ) } ms`;\n\n\t}\n\n\tif ( params.visualization.simpleColors ) {\n\n\t\tfsQuad.material.boundsColor.set( 0xffffff );\n\t\tfsQuad.material.thresholdColor.set( 0xff0000 );\n\t\tfsQuad.material.backgroundColor.set( 0x000000 );\n\n\t} else {\n\n\t\tfsQuad.material.boundsColor.set( BOUNDS_COLOR );\n\t\tfsQuad.material.thresholdColor.set( THRESHOLD_COLOR );\n\t\tfsQuad.material.backgroundColor.set( BG_COLOR );\n\n\t}\n\n\tfsQuad.material.threshold = params.visualization.traversalThreshold;\n\tfsQuad.material.outlineAlpha = params.visualization.outline ? 0.5 : 0.0;\n\tfsQuad.material.resolution.set( renderTarget.width, renderTarget.height );\n\n\t// render bvh\n\tbenchmarkViz.visible = false;\n\trenderer.autoClear = true;\n\tif ( mesh ) mesh.visible = params.visualization.displayMesh;\n\trenderer.setRenderTarget( renderTarget );\n\trenderer.render( scene, camera );\n\n\trenderer.setRenderTarget( null );\n\tfsQuad.render( renderer );\n\n\t// render rays\n\trenderer.autoClear = false;\n\tbenchmarkViz.visible = params.benchmark.displayRays;\n\n\tif ( mesh ) renderer.render( mesh, camera );\n\trenderer.render( benchmarkViz, camera );\n\n}\n\n\ninit();\nrender();\n"],"names":["$ccdf29cef1be036a$var$scene","$ccdf29cef1be036a$var$camera","$ccdf29cef1be036a$var$renderer","$ccdf29cef1be036a$var$helper","$ccdf29cef1be036a$var$mesh","$ccdf29cef1be036a$var$outputContainer","$ccdf29cef1be036a$var$benchmarkContainer","$ccdf29cef1be036a$var$benchmarkViz","$ccdf29cef1be036a$var$renderTarget","$ccdf29cef1be036a$var$fsQuad","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$0a1d3a5a6a49de03$export$3983474c8e6e978b","$ilwiq","$0a1d3a5a6a49de03$var$_camera","OrthographicCamera","$0a1d3a5a6a49de03$var$_geometry","BufferGeometry","setAttribute","Float32BufferAttribute","constructor","material","_mesh","Mesh","dispose","geometry","render","renderer","value","$31ccd9a92979d6bb$export$a0dc2935489c814a","$31ccd9a92979d6bb$export$749bba8a65fa6d70","$31ccd9a92979d6bb$export$e0a981a7a32ddba4","$b4YKL","$ff8ed","$31ccd9a92979d6bb$var$ray","Ray","$31ccd9a92979d6bb$var$tmpInverseMatrix","Matrix4","$31ccd9a92979d6bb$var$origMeshRaycastFunc","prototype","raycast","raycaster","intersects","boundsTree","undefined","copy","matrixWorld","invert","ray","applyMatrix4","bvh","firstHitOnly","hit","convertRaycastIntersect","raycastFirst","push","hits","i","l","length","options","MeshBVH","$810f31c6ff4f494e$export$adb106eed99e8cd8","object","point","distance","distanceTo","origin","near","far","$249fb1d4ac2bb894$export$de5f6c317656a6ce","$249fb1d4ac2bb894$export$d677314be3f8df27","$Mleu6","$2zRsl","$249fb1d4ac2bb894$var$getPrimitiveSize","el","_roots","map","root","$249fb1d4ac2bb894$var$getRootExtremes","group","result","nodeCount","leafNodeCount","depth","min","Infinity","max","tris","splits","surfaceAreaScore","traverse","isLeaf","boundingData","offsetOrSplit","count","l0","l1","l2","surfaceArea","Math","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","obj","traversed","Set","stack","bytes","curr","pop","has","key","add","hasOwnProperty","regex","test","arr","name","byteLength","isSharedArrayBufferSupported","SharedArrayBuffer","ArrayBuffer","$3c85f35a8c29fa9b$export$e57d74bcb7e3bec5","$aw71y","$3c85f35a8c29fa9b$var$boundingBox","Box3","$3c85f35a8c29fa9b$var$MeshBVHRootHelper","Object3D","isMesh","displayEdges","isLineSegments","isLine","displayParents","_group","update","visible","indexArray","indices","targetDepth","boundsCount","posIndex","positionArray","Float32Array","terminate","arrayToBox","x","xVal","y","yVal","z","zVal","Uint8Array","Uint32Array","Uint16Array","indexLength","posOffset","indexOffset","j","setIndex","BufferAttribute","Group","color","edgeMaterial","opacity","meshMaterial","mesh","LineBasicMaterial","transparent","depthWrite","MeshBasicMaterial","totalRoots","remove","updateMatrixWorld","args","parent","updateWorldMatrix","matrix","multiply","decompose","position","quaternion","scale","source","clone","children","$5Rd1x","$7lx9d","$RPVlj","$jiuw3","$4h5hN","$38WKP","$5ca9G","acceleratedRaycast","computeBoundsTree","disposeBoundsTree","$ccdf29cef1be036a$var$mouse","Vector2","$ccdf29cef1be036a$var$readBuffer","$ccdf29cef1be036a$var$params","strategy","SAH","maxLeafTris","maxDepth","rebuild","$ccdf29cef1be036a$var$updateBVH","visualization","displayMesh","simpleColors","outline","traversalThreshold","benchmark","displayRays","rotations","castCount","$ccdf29cef1be036a$var$TraverseMaterial","ShaderMaterial","params","uniforms","threshold","boundsColor","Color","backgroundColor","thresholdColor","resolution","outlineAlpha","vertexShader","fragmentShader","setValues","$ccdf29cef1be036a$var$onResize","aspect","window","innerWidth","innerHeight","updateProjectionMatrix","setSize","setPixelRatio","devicePixelRatio","startTime","performance","now","parseInt","deltaTime","$ccdf29cef1be036a$var$resetBenchmark","info","getBVHExtremes","innerText","toFixed","estimateMemoryInBytes","$ccdf29cef1be036a$var$runBenchmark","updateGeom","points","newGeometry","Raycaster","rayCount","direction","step","cos","PI","sin","multiplyScalar","sub","normalize","intersectObject","Vector3","at","setFromPoints","$ccdf29cef1be036a$var$sampleCount","$ccdf29cef1be036a$var$currTime","$ccdf29cef1be036a$var$init","document","getElementById","WebGLRenderer","antialias","setClearColor","body","appendChild","domElement","WebGLRenderTarget","format","RedFormat","type","FloatType","FullScreenQuad","texture","Scene","PerspectiveCamera","OrbitControls","addEventListener","loader","GLTFLoader","load","gltf","scene","c","colorWrite","center","MeshBVHHelper","blending","CustomBlending","blendDst","OneFactor","LineSegments","frustumCulled","gui","GUI","bvhFolder","addFolder","CENTER","AVERAGE","open","vizFolder","benchmarkFolder","onChange","clientX","clientY","$ccdf29cef1be036a$var$render","requestAnimationFrame","pixelRatio","getPixelRatio","readRenderTargetPixels","round","width","height","autoClear","setRenderTarget"],"version":3,"file":"inspector.e2ab9340.js.map"}