(()=>{var e,r,t=globalThis,o={},n={},i=t.parcelRequire4485;null==i&&((i=function(e){if(e in o)return o[e].exports;if(e in n){var r=n[e];delete n[e];var t={id:e,exports:{}};return o[e]=t,r.call(t.exports,t,t.exports),t.exports}var i=Error("Cannot find module '"+e+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(e,r){n[e]=r},t.parcelRequire4485=i),i.register,importScripts("./generateMeshBVH.worker.aad48e6e.js");var s=i("e06gU"),a=i("cmdvV"),u=i("9ii9T"),l=i("4FzKT"),f=i("41HWY"),p=i("7EhZI"),c=i("kN5RC");let g=!1,h=0;var d={},B={};B=function(e,r,t){if(r===self.location.origin)return e;var o=t?"import "+JSON.stringify(e)+";":"importScripts("+JSON.stringify(e)+");";return URL.createObjectURL(new Blob([o],{type:"application/javascript"}))};var w={};let m=((r=w[e="8UXAC"])||(r=function(){try{throw Error()}catch(r){var e=(""+r.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);if(e)return(""+e[2]).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/,"$1")+"/"}return"/"}(),w[e]=r),r+"parallelMeshBVH.worker.03387c6a.js");d=B(m,function(e){var r=(""+e).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);if(!r)throw Error("Origin not found");return r[0]}(m),!1);let k=new class{get workerCount(){return this.workers.length}constructor(e){this.workers=[],this._getWorker=e}setWorkerCount(e){let r=this.workers;for(;r.length<e;)r.push(this._getWorker());for(;r.length>e;)r.pop().terminate()}runSubTask(e,r,t){return new Promise((o,n)=>{let i=this.workers[e];if(i.isRunning)throw Error(`${this.name}: Worker ${e} is already running.`);i.isRunning=!0,i.postMessage(r),i.onerror=e=>{i.isRunning=!1,n(e)},i.onmessage=e=>{"progress"===e.data.type?t&&t(e.data.progress):(t&&t(1),i.isRunning=!1,o(e.data))}})}}(()=>new Worker(d));function T(e){let r=0;return function(t){e(t-r),r=t}}function y(e){e=Math.min(e,1);let r=performance.now();r-h>=10&&1!==e&&(postMessage({error:null,progress:e,type:"progress"}),h=r)}function E(e,r){let t=new s.BufferGeometry;return e&&(t.index=new s.BufferAttribute(e,1,!1)),t.setAttribute("position",new s.BufferAttribute(r,3)),t}onmessage=async({data:e})=>{if(g)throw Error("Worker is already running a task.");let{operation:r}=e;if("BUILD_BVH"===r){g=!0;let{maxWorkerCount:r,index:t,position:o,options:n}=e;k.setWorkerCount((0,s.MathUtils).floorPowerOfTwo(r));let i=E(t,o),f=n.indirect?(0,p.getFullGeometryRange)(i):(0,p.getRootIndexRanges)(i),h=n.indirect?(0,u.generateIndirectBuffer)(i,!0):null,d=(0,p.getTriCount)(i),B=new Float32Array(new SharedArrayBuffer(24*d)),w=[];for(let e=0,r=k.workerCount;e<r;e++){let n=Math.ceil(d/r),i=e*n,s=Math.min(n,d-i);w.push(k.runSubTask(e,{operation:"BUILD_TRIANGLE_BOUNDS",offset:i,count:s,index:t,position:o,triangleBounds:B}))}await Promise.all(w);let m={_indirectBuffer:h,geometry:i},b=0,x={...c.DEFAULT_OPTIONS,...n,verbose:!1,maxDepth:Math.round(Math.log2(k.workerCount)),onProgress:n.includedProgressCallback?T(e=>{y(b+=.1*e)}):null},_=[];for(let e=0,r=f.length;e<r;e++){let r=[],i=f[e],s=(0,u.buildTree)(m,B,i.offset,i.count,x),p=function(e){let r=[];return function e(t,o=0){t.depth=o,r.push(t),t.count||(e(t.left,o+1),e(t.right,o+1))}(e),r}(s),g=0,d=0,w=0;for(let e=0,i=p.length;e<i;e++){let i=p[e];if(i.count){let e={...c.DEFAULT_OPTIONS,...n};e.maxDepth=e.maxDepth-i.depth;let s=k.runSubTask(w++,{operation:"BUILD_SUBTREE",offset:i.offset,count:i.count,indirectBuffer:h,index:t,position:o,triangleBounds:B,options:e},T(e=>{y(b+=.9*e/w)})).then(e=>{let r=e.buffer;i.buffer=r,g+=r.byteLength});r.push(s)}else d++}await Promise.all(r);let E=new(n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer)(g+d*a.BYTES_PER_NODE);(0,l.populateBuffer)(0,s,E),_.push(E)}postMessage({error:null,serialized:{roots:_,index:t,indirectBuffer:h},position:o,progress:1}),g=!1}else if("BUILD_SUBTREE"===r){let{offset:r,count:t,indirectBuffer:o,index:n,position:i,triangleBounds:s,options:f}=e,p={_indirectBuffer:o,geometry:E(n,i)},g={...c.DEFAULT_OPTIONS,...f,onProgress:f.includedProgressCallback?y:null},h=(0,u.buildTree)(p,s,r,t,g),d=(0,l.countNodes)(h),B=new ArrayBuffer(a.BYTES_PER_NODE*d);(0,l.populateBuffer)(0,h,B),postMessage({type:"result",buffer:B,progress:1},[B])}else if("BUILD_TRIANGLE_BOUNDS"===r){let{index:r,position:t,triangleBounds:o,offset:n,count:i}=e,s=E(r,t);(0,f.computeTriangleBounds)(s,o,n,i),postMessage({type:"result"})}}})();
//# sourceMappingURL=parallelMeshBVH.worker.03387c6a.js.map
