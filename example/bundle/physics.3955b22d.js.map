{"mappings":"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","sources":["<anon>","node_modules/stats.js/build/stats.min.js","src/objects/MeshBVHHelper.js","example/physics.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"c8CJQ\", function(module, exports) {\n// stats.js - http://github.com/mrdoob/stats.js\n(function(f, e) {\n    module.exports = e();\n})(module.exports, function() {\n    var f = function() {\n        function e(a) {\n            c.appendChild(a.dom);\n            return a;\n        }\n        function u(a) {\n            for(var d = 0; d < c.children.length; d++)c.children[d].style.display = d === a ? \"block\" : \"none\";\n            l = a;\n        }\n        var l = 0, c = document.createElement(\"div\");\n        c.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n        c.addEventListener(\"click\", function(a) {\n            a.preventDefault();\n            u(++l % c.children.length);\n        }, !1);\n        var k = (performance || Date).now(), g = k, a = 0, r = e(new f.Panel(\"FPS\", \"#0ff\", \"#002\")), h = e(new f.Panel(\"MS\", \"#0f0\", \"#020\"));\n        if (self.performance && self.performance.memory) var t = e(new f.Panel(\"MB\", \"#f08\", \"#201\"));\n        u(0);\n        return {\n            REVISION: 16,\n            dom: c,\n            addPanel: e,\n            showPanel: u,\n            begin: function() {\n                k = (performance || Date).now();\n            },\n            end: function() {\n                a++;\n                var c = (performance || Date).now();\n                h.update(c - k, 200);\n                if (c > g + 1E3 && (r.update(1E3 * a / (c - g), 100), g = c, a = 0, t)) {\n                    var d = performance.memory;\n                    t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);\n                }\n                return c;\n            },\n            update: function() {\n                k = this.end();\n            },\n            domElement: c,\n            setMode: u\n        };\n    };\n    f.Panel = function(e, f, l) {\n        var c = Infinity, k = 0, g = Math.round, a = g(window.devicePixelRatio || 1), r = 80 * a, h = 48 * a, t = 3 * a, v = 2 * a, d = 3 * a, m = 15 * a, n = 74 * a, p = 30 * a, q = document.createElement(\"canvas\");\n        q.width = r;\n        q.height = h;\n        q.style.cssText = \"width:80px;height:48px\";\n        var b = q.getContext(\"2d\");\n        b.font = \"bold \" + 9 * a + \"px Helvetica,Arial,sans-serif\";\n        b.textBaseline = \"top\";\n        b.fillStyle = l;\n        b.fillRect(0, 0, r, h);\n        b.fillStyle = f;\n        b.fillText(e, t, v);\n        b.fillRect(d, m, n, p);\n        b.fillStyle = l;\n        b.globalAlpha = .9;\n        b.fillRect(d, m, n, p);\n        return {\n            dom: q,\n            update: function(h, w) {\n                c = Math.min(c, h);\n                k = Math.max(k, h);\n                b.fillStyle = l;\n                b.globalAlpha = 1;\n                b.fillRect(0, 0, r, m);\n                b.fillStyle = f;\n                b.fillText(g(h) + \" \" + e + \" (\" + g(c) + \"-\" + g(k) + \")\", t, v);\n                b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);\n                b.fillRect(d + n - a, m, a, p);\n                b.fillStyle = l;\n                b.globalAlpha = .9;\n                b.fillRect(d + n - a, m, a, g((1 - h / w) * p));\n            }\n        };\n    };\n    return f;\n});\n\n});\n\nparcelRegister(\"5ca9G\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHHelper\", () => $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $3c85f35a8c29fa9b$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nclass $3c85f35a8c29fa9b$var$MeshBVHRootHelper extends (0, $ilwiq.Object3D) {\n    get isMesh() {\n        return !this.displayEdges;\n    }\n    get isLineSegments() {\n        return this.displayEdges;\n    }\n    get isLine() {\n        return this.displayEdges;\n    }\n    constructor(bvh, material, depth = 10, group = 0){\n        super();\n        this.material = material;\n        this.geometry = new (0, $ilwiq.BufferGeometry)();\n        this.name = \"MeshBVHRootHelper\";\n        this.depth = depth;\n        this.displayParents = false;\n        this.bvh = bvh;\n        this.displayEdges = true;\n        this._group = group;\n    }\n    raycast() {}\n    update() {\n        const geometry = this.geometry;\n        const boundsTree = this.bvh;\n        const group = this._group;\n        geometry.dispose();\n        this.visible = false;\n        if (boundsTree) {\n            // count the number of bounds required\n            const targetDepth = this.depth - 1;\n            const displayParents = this.displayParents;\n            let boundsCount = 0;\n            boundsTree.traverse((depth, isLeaf)=>{\n                if (depth >= targetDepth || isLeaf) {\n                    boundsCount++;\n                    return true;\n                } else if (displayParents) boundsCount++;\n            }, group);\n            // fill in the position buffer with the bounds corners\n            let posIndex = 0;\n            const positionArray = new Float32Array(24 * boundsCount);\n            boundsTree.traverse((depth, isLeaf, boundingData)=>{\n                const terminate = depth >= targetDepth || isLeaf;\n                if (terminate || displayParents) {\n                    (0, $aw71y.arrayToBox)(0, boundingData, $3c85f35a8c29fa9b$var$boundingBox);\n                    const { min: min, max: max } = $3c85f35a8c29fa9b$var$boundingBox;\n                    for(let x = -1; x <= 1; x += 2){\n                        const xVal = x < 0 ? min.x : max.x;\n                        for(let y = -1; y <= 1; y += 2){\n                            const yVal = y < 0 ? min.y : max.y;\n                            for(let z = -1; z <= 1; z += 2){\n                                const zVal = z < 0 ? min.z : max.z;\n                                positionArray[posIndex + 0] = xVal;\n                                positionArray[posIndex + 1] = yVal;\n                                positionArray[posIndex + 2] = zVal;\n                                posIndex += 3;\n                            }\n                        }\n                    }\n                    return terminate;\n                }\n            }, group);\n            let indexArray;\n            let indices;\n            if (this.displayEdges) // fill in the index buffer to point to the corner points\n            indices = new Uint8Array([\n                // x axis\n                0,\n                4,\n                1,\n                5,\n                2,\n                6,\n                3,\n                7,\n                // y axis\n                0,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                7,\n                // z axis\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7\n            ]);\n            else indices = new Uint8Array([\n                // X-, X+\n                0,\n                1,\n                2,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                6,\n                7,\n                5,\n                // Y-, Y+\n                1,\n                4,\n                5,\n                0,\n                4,\n                1,\n                2,\n                3,\n                6,\n                3,\n                7,\n                6,\n                // Z-, Z+\n                0,\n                2,\n                4,\n                2,\n                6,\n                4,\n                1,\n                5,\n                3,\n                3,\n                5,\n                7\n            ]);\n            if (positionArray.length > 65535) indexArray = new Uint32Array(indices.length * boundsCount);\n            else indexArray = new Uint16Array(indices.length * boundsCount);\n            const indexLength = indices.length;\n            for(let i = 0; i < boundsCount; i++){\n                const posOffset = i * 8;\n                const indexOffset = i * indexLength;\n                for(let j = 0; j < indexLength; j++)indexArray[indexOffset + j] = posOffset + indices[j];\n            }\n            // update the geometry\n            geometry.setIndex(new (0, $ilwiq.BufferAttribute)(indexArray, 1, false));\n            geometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(positionArray, 3, false));\n            this.visible = true;\n        }\n    }\n}\nclass $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 extends (0, $ilwiq.Group) {\n    get color() {\n        return this.edgeMaterial.color;\n    }\n    get opacity() {\n        return this.edgeMaterial.opacity;\n    }\n    set opacity(v) {\n        this.edgeMaterial.opacity = v;\n        this.meshMaterial.opacity = v;\n    }\n    constructor(mesh = null, bvh = null, depth = 10){\n        // handle bvh, depth signature\n        if (mesh instanceof (0, $ff8ed.MeshBVH)) {\n            depth = bvh || 10;\n            bvh = mesh;\n            mesh = null;\n        }\n        // handle mesh, depth signature\n        if (typeof bvh === \"number\") {\n            depth = bvh;\n            bvh = null;\n        }\n        super();\n        this.name = \"MeshBVHHelper\";\n        this.depth = depth;\n        this.mesh = mesh;\n        this.bvh = bvh;\n        this.displayParents = false;\n        this.displayEdges = true;\n        this._roots = [];\n        const edgeMaterial = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        const meshMaterial = new (0, $ilwiq.MeshBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        meshMaterial.color = edgeMaterial.color;\n        this.edgeMaterial = edgeMaterial;\n        this.meshMaterial = meshMaterial;\n        this.update();\n    }\n    update() {\n        const bvh = this.bvh || this.mesh.geometry.boundsTree;\n        const totalRoots = bvh ? bvh._roots.length : 0;\n        while(this._roots.length > totalRoots){\n            const root = this._roots.pop();\n            root.geometry.dispose();\n            this.remove(root);\n        }\n        for(let i = 0; i < totalRoots; i++){\n            const { depth: depth, edgeMaterial: edgeMaterial, meshMaterial: meshMaterial, displayParents: displayParents, displayEdges: displayEdges } = this;\n            if (i >= this._roots.length) {\n                const root = new $3c85f35a8c29fa9b$var$MeshBVHRootHelper(bvh, edgeMaterial, depth, i);\n                this.add(root);\n                this._roots.push(root);\n            }\n            const root = this._roots[i];\n            root.bvh = bvh;\n            root.depth = depth;\n            root.displayParents = displayParents;\n            root.displayEdges = displayEdges;\n            root.material = displayEdges ? edgeMaterial : meshMaterial;\n            root.update();\n        }\n    }\n    updateMatrixWorld(...args) {\n        const mesh = this.mesh;\n        const parent = this.parent;\n        if (mesh !== null) {\n            mesh.updateWorldMatrix(true, false);\n            if (parent) this.matrix.copy(parent.matrixWorld).invert().multiply(mesh.matrixWorld);\n            else this.matrix.copy(mesh.matrixWorld);\n            this.matrix.decompose(this.position, this.quaternion, this.scale);\n        }\n        super.updateMatrixWorld(...args);\n    }\n    copy(source) {\n        this.depth = source.depth;\n        this.mesh = source.mesh;\n        this.bvh = source.bvh;\n        this.opacity = source.opacity;\n        this.color.copy(source.color);\n    }\n    clone() {\n        return new $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5(this.mesh, this.bvh, this.depth);\n    }\n    dispose() {\n        this.edgeMaterial.dispose();\n        this.meshMaterial.dispose();\n        const children = this.children;\n        for(let i = 0, l = children.length; i < l; i++)children[i].geometry.dispose();\n    }\n}\nclass $3c85f35a8c29fa9b$export$5ead38ed5c75a1c8 extends $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 {\n    constructor(...args){\n        super(...args);\n        console.warn(\"MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.\");\n    }\n}\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $c8CJQ = parcelRequire(\"c8CJQ\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nvar $5ca9G = parcelRequire(\"5ca9G\");\nvar $jAT47 = parcelRequire(\"jAT47\");\nconst $3512fa0ea556b359$var$params = {\n    displayCollider: false,\n    displayBVH: false,\n    displayParents: false,\n    visualizeDepth: 10,\n    gravity: -9.8,\n    physicsSteps: 5,\n    // TODO: support steps based on given sphere velocity / radius\n    simulationSpeed: 1,\n    sphereSize: 1,\n    pause: false,\n    step: ()=>{\n        const steps = $3512fa0ea556b359$var$params.physicsSteps;\n        for(let i = 0; i < steps; i++)$3512fa0ea556b359$var$update(0.016 / steps);\n    },\n    explode: $3512fa0ea556b359$var$explodeSpheres,\n    reset: $3512fa0ea556b359$var$reset\n};\nlet $3512fa0ea556b359$var$renderer, $3512fa0ea556b359$var$camera, $3512fa0ea556b359$var$scene, $3512fa0ea556b359$var$clock, $3512fa0ea556b359$var$gui, $3512fa0ea556b359$var$stats;\nlet $3512fa0ea556b359$var$environment, $3512fa0ea556b359$var$collider, $3512fa0ea556b359$var$visualizer;\nconst $3512fa0ea556b359$var$spheres = [];\nconst $3512fa0ea556b359$var$hits = [];\nconst $3512fa0ea556b359$var$tempSphere = new $ilwiq.Sphere();\nconst $3512fa0ea556b359$var$deltaVec = new $ilwiq.Vector3();\nconst $3512fa0ea556b359$var$tempVec = new $ilwiq.Vector3();\nconst $3512fa0ea556b359$var$forwardVector = new $ilwiq.Vector3(0, 0, 1);\n$3512fa0ea556b359$var$init();\n$3512fa0ea556b359$var$render();\nfunction $3512fa0ea556b359$var$init() {\n    const bgColor = 1251612;\n    // renderer setup\n    $3512fa0ea556b359$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $3512fa0ea556b359$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $3512fa0ea556b359$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $3512fa0ea556b359$var$renderer.setClearColor(bgColor, 1);\n    $3512fa0ea556b359$var$renderer.shadowMap.enabled = true;\n    $3512fa0ea556b359$var$renderer.shadowMap.type = $ilwiq.PCFSoftShadowMap;\n    $3512fa0ea556b359$var$renderer.outputEncoding = $ilwiq.sRGBEncoding;\n    document.body.appendChild($3512fa0ea556b359$var$renderer.domElement);\n    // scene setup\n    $3512fa0ea556b359$var$scene = new $ilwiq.Scene();\n    $3512fa0ea556b359$var$scene.fog = new $ilwiq.Fog(bgColor, 30, 70);\n    // lights\n    const light = new $ilwiq.DirectionalLight(0xaaccff, 1);\n    light.position.set(1, 1.5, 1).multiplyScalar(50);\n    light.intensity = 0.25;\n    const shadowCam = light.shadow.camera;\n    shadowCam.bottom = shadowCam.left = -10;\n    shadowCam.top = shadowCam.right = 10;\n    $3512fa0ea556b359$var$scene.add(light);\n    $3512fa0ea556b359$var$scene.add(new $ilwiq.HemisphereLight(0x4488ff, 0x223344, 0.3));\n    // camera setup\n    $3512fa0ea556b359$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);\n    $3512fa0ea556b359$var$camera.position.set(10, 10, -10);\n    $3512fa0ea556b359$var$camera.far = 100;\n    $3512fa0ea556b359$var$camera.updateProjectionMatrix();\n    window.camera = $3512fa0ea556b359$var$camera;\n    $3512fa0ea556b359$var$clock = new $ilwiq.Clock();\n    new (0, $5Rd1x.OrbitControls)($3512fa0ea556b359$var$camera, $3512fa0ea556b359$var$renderer.domElement);\n    // stats setup\n    $3512fa0ea556b359$var$stats = new (0, (/*@__PURE__*/$parcel$interopDefault($c8CJQ)))();\n    document.body.appendChild($3512fa0ea556b359$var$stats.dom);\n    $3512fa0ea556b359$var$loadColliderEnvironment();\n    // dat.gui\n    $3512fa0ea556b359$var$gui = new (0, $jiuw3.GUI)();\n    const visFolder = $3512fa0ea556b359$var$gui.addFolder(\"Visualization\");\n    visFolder.add($3512fa0ea556b359$var$params, \"displayCollider\");\n    visFolder.add($3512fa0ea556b359$var$params, \"displayBVH\");\n    visFolder.add($3512fa0ea556b359$var$params, \"displayParents\").onChange((v)=>{\n        $3512fa0ea556b359$var$visualizer.displayParents = v;\n        $3512fa0ea556b359$var$visualizer.update();\n    });\n    visFolder.add($3512fa0ea556b359$var$params, \"visualizeDepth\", 1, 20, 1).onChange((v)=>{\n        $3512fa0ea556b359$var$visualizer.depth = v;\n        $3512fa0ea556b359$var$visualizer.update();\n    });\n    visFolder.open();\n    const physicsFolder = $3512fa0ea556b359$var$gui.addFolder(\"Physics\");\n    physicsFolder.add($3512fa0ea556b359$var$params, \"physicsSteps\", 0, 30, 1);\n    physicsFolder.add($3512fa0ea556b359$var$params, \"gravity\", -100, 100, 0.01).onChange((v)=>{\n        $3512fa0ea556b359$var$params.gravity = parseFloat(v);\n    });\n    physicsFolder.add($3512fa0ea556b359$var$params, \"simulationSpeed\", 0, 5, 0.01);\n    physicsFolder.add($3512fa0ea556b359$var$params, \"sphereSize\", 0.2, 5, 0.1);\n    physicsFolder.add($3512fa0ea556b359$var$params, \"pause\");\n    physicsFolder.add($3512fa0ea556b359$var$params, \"step\");\n    physicsFolder.open();\n    $3512fa0ea556b359$var$gui.add($3512fa0ea556b359$var$params, \"explode\");\n    $3512fa0ea556b359$var$gui.add($3512fa0ea556b359$var$params, \"reset\");\n    $3512fa0ea556b359$var$gui.open();\n    const raycaster = new $ilwiq.Raycaster();\n    const mouse = new $ilwiq.Vector2();\n    let x = 0;\n    let y = 0;\n    $3512fa0ea556b359$var$renderer.domElement.addEventListener(\"pointerdown\", (e)=>{\n        x = e.clientX;\n        y = e.clientY;\n    });\n    $3512fa0ea556b359$var$renderer.domElement.addEventListener(\"pointerup\", (e)=>{\n        const totalDelta = Math.abs(e.clientX - x) + Math.abs(e.clientY - y);\n        if (totalDelta > 2) return;\n        mouse.x = e.clientX / window.innerWidth * 2 - 1;\n        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n        raycaster.setFromCamera(mouse, $3512fa0ea556b359$var$camera);\n        const sphere = $3512fa0ea556b359$var$createSphere();\n        sphere.position.copy($3512fa0ea556b359$var$camera.position).addScaledVector(raycaster.ray.direction, 3);\n        sphere.velocity.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).addScaledVector(raycaster.ray.direction, 10 * Math.random() + 15).multiplyScalar(0.5);\n    });\n    window.addEventListener(\"resize\", function() {\n        $3512fa0ea556b359$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $3512fa0ea556b359$var$camera.updateProjectionMatrix();\n        $3512fa0ea556b359$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    }, false);\n    window.createSphere = $3512fa0ea556b359$var$createSphere;\n}\nfunction $3512fa0ea556b359$var$loadColliderEnvironment() {\n    new (0, $7lx9d.GLTFLoader)().load(\"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/low-poly-jungle-scene/scene.gltf\", (res)=>{\n        $3512fa0ea556b359$var$environment = res.scene;\n        $3512fa0ea556b359$var$environment.scale.setScalar(0.05);\n        const pointLight = new $ilwiq.PointLight(0x00ffff);\n        pointLight.distance = 7;\n        pointLight.position.set(-100, -40, 100);\n        $3512fa0ea556b359$var$environment.add(pointLight);\n        const porchLight = new $ilwiq.PointLight(0xffdd66);\n        porchLight.distance = 15;\n        porchLight.intensity = 5;\n        porchLight.position.set(80, 80, 135);\n        porchLight.shadow.normalBias = 1e-2;\n        porchLight.shadow.bias = -0.001;\n        porchLight.shadow.mapSize.setScalar(1024);\n        porchLight.castShadow = true;\n        $3512fa0ea556b359$var$environment.add(porchLight);\n        // collect all geometries to merge\n        $3512fa0ea556b359$var$environment.updateMatrixWorld(true);\n        const staticGenerator = new (0, $jAT47.StaticGeometryGenerator)($3512fa0ea556b359$var$environment);\n        staticGenerator.attributes = [\n            \"position\"\n        ];\n        const mergedGeometry = staticGenerator.generate();\n        mergedGeometry.boundsTree = new (0, $ff8ed.MeshBVH)(mergedGeometry);\n        $3512fa0ea556b359$var$collider = new $ilwiq.Mesh(mergedGeometry);\n        $3512fa0ea556b359$var$collider.material.wireframe = true;\n        $3512fa0ea556b359$var$collider.material.opacity = 0.5;\n        $3512fa0ea556b359$var$collider.material.transparent = true;\n        $3512fa0ea556b359$var$visualizer = new (0, $5ca9G.MeshBVHHelper)($3512fa0ea556b359$var$collider, $3512fa0ea556b359$var$params.visualizeDepth);\n        $3512fa0ea556b359$var$scene.add($3512fa0ea556b359$var$visualizer);\n        $3512fa0ea556b359$var$scene.add($3512fa0ea556b359$var$collider);\n        $3512fa0ea556b359$var$scene.add($3512fa0ea556b359$var$environment);\n        $3512fa0ea556b359$var$environment.traverse((c)=>{\n            if (c.material) {\n                c.castShadow = true;\n                c.receiveShadow = true;\n                c.material.shadowSide = 2;\n            }\n        });\n    });\n}\nfunction $3512fa0ea556b359$var$onCollide(object1, object2, point, normal, velocity, offset = 0) {\n    if (velocity < Math.max(Math.abs(0.04 * $3512fa0ea556b359$var$params.gravity), 5)) return;\n    // Create an animation when objects collide\n    const effectScale = Math.max(object2 ? Math.max(object1.collider.radius, object2.collider.radius) : object1.collider.radius, 0.4) * 2.0;\n    const plane = new $ilwiq.Mesh(new $ilwiq.RingGeometry(0, 1, 30), new $ilwiq.MeshBasicMaterial({\n        side: 2,\n        transparent: true,\n        depthWrite: false\n    }));\n    plane.lifetime = 0;\n    plane.maxLifetime = 0.4;\n    plane.maxScale = effectScale * Math.max(Math.sin(Math.min(velocity / 200, 1) * Math.PI / 2), 0.35);\n    plane.position.copy(point).addScaledVector(normal, offset);\n    plane.quaternion.setFromUnitVectors($3512fa0ea556b359$var$forwardVector, normal);\n    $3512fa0ea556b359$var$scene.add(plane);\n    $3512fa0ea556b359$var$hits.push(plane);\n}\nfunction $3512fa0ea556b359$var$createSphere() {\n    const white = new $ilwiq.Color(0xffffff);\n    const color = new $ilwiq.Color(1251612).lerp(white, Math.random() * 0.5 + 0.5).convertSRGBToLinear();\n    const sphere = new $ilwiq.Mesh(new $ilwiq.SphereGeometry(1, 20, 20), new $ilwiq.MeshStandardMaterial({\n        color: color\n    }));\n    $3512fa0ea556b359$var$scene.add(sphere);\n    sphere.castShadow = true;\n    sphere.receiveShadow = true;\n    sphere.material.shadowSide = 2;\n    const radius = 0.5 * $3512fa0ea556b359$var$params.sphereSize * (Math.random() * .2 + 0.6);\n    sphere.scale.setScalar(radius);\n    sphere.collider = new $ilwiq.Sphere(sphere.position, radius);\n    sphere.velocity = new $ilwiq.Vector3(0, 0, 0);\n    sphere.mass = Math.pow(radius, 3) * Math.PI * 4 / 3;\n    $3512fa0ea556b359$var$spheres.push(sphere);\n    return sphere;\n}\nfunction $3512fa0ea556b359$var$updateSphereCollisions(deltaTime) {\n    // TODO: Add visualization for velocity vector, collision vector, all intersection vectors\n    const bvh = $3512fa0ea556b359$var$collider.geometry.boundsTree;\n    for(let i = 0, l = $3512fa0ea556b359$var$spheres.length; i < l; i++){\n        const sphere = $3512fa0ea556b359$var$spheres[i];\n        const sphereCollider = sphere.collider;\n        // move the sphere\n        sphere.velocity.y += $3512fa0ea556b359$var$params.gravity * deltaTime;\n        sphereCollider.center.addScaledVector(sphere.velocity, deltaTime);\n        // remove the spheres if they've left the world\n        if (sphereCollider.center.y < -80) {\n            $3512fa0ea556b359$var$spheres.splice(i, 1);\n            i--;\n            l--;\n            sphere.material.dispose();\n            sphere.geometry.dispose();\n            $3512fa0ea556b359$var$scene.remove(sphere);\n            continue;\n        }\n        // get the sphere position in world space\n        $3512fa0ea556b359$var$tempSphere.copy(sphere.collider);\n        let collided = false;\n        bvh.shapecast({\n            intersectsBounds: (box)=>{\n                return box.intersectsSphere($3512fa0ea556b359$var$tempSphere);\n            },\n            intersectsTriangle: (tri)=>{\n                // get delta between closest point and center\n                tri.closestPointToPoint($3512fa0ea556b359$var$tempSphere.center, $3512fa0ea556b359$var$deltaVec);\n                $3512fa0ea556b359$var$deltaVec.sub($3512fa0ea556b359$var$tempSphere.center);\n                const distance = $3512fa0ea556b359$var$deltaVec.length();\n                if (distance < $3512fa0ea556b359$var$tempSphere.radius) {\n                    // move the sphere position to be outside the triangle\n                    const radius = $3512fa0ea556b359$var$tempSphere.radius;\n                    const depth = distance - radius;\n                    $3512fa0ea556b359$var$deltaVec.multiplyScalar(1 / distance);\n                    $3512fa0ea556b359$var$tempSphere.center.addScaledVector($3512fa0ea556b359$var$deltaVec, depth);\n                    collided = true;\n                }\n            },\n            boundsTraverseOrder: (box)=>{\n                return box.distanceToPoint($3512fa0ea556b359$var$tempSphere.center) - $3512fa0ea556b359$var$tempSphere.radius;\n            }\n        });\n        if (collided) {\n            // get the delta direction and reflect the velocity across it\n            $3512fa0ea556b359$var$deltaVec.subVectors($3512fa0ea556b359$var$tempSphere.center, sphereCollider.center).normalize();\n            sphere.velocity.reflect($3512fa0ea556b359$var$deltaVec);\n            // dampen the velocity and apply some drag\n            const dot = sphere.velocity.dot($3512fa0ea556b359$var$deltaVec);\n            sphere.velocity.addScaledVector($3512fa0ea556b359$var$deltaVec, -dot * 0.5);\n            sphere.velocity.multiplyScalar(Math.max(1.0 - deltaTime, 0));\n            // update the sphere collider position\n            sphereCollider.center.copy($3512fa0ea556b359$var$tempSphere.center);\n            // find the point on the surface that was hit\n            $3512fa0ea556b359$var$tempVec.copy($3512fa0ea556b359$var$tempSphere.center).addScaledVector($3512fa0ea556b359$var$deltaVec, -$3512fa0ea556b359$var$tempSphere.radius);\n            $3512fa0ea556b359$var$onCollide(sphere, null, $3512fa0ea556b359$var$tempVec, $3512fa0ea556b359$var$deltaVec, dot, 0.05);\n        }\n    }\n    // Handle sphere collisions\n    for(let i = 0, l = $3512fa0ea556b359$var$spheres.length; i < l; i++){\n        const s1 = $3512fa0ea556b359$var$spheres[i];\n        const c1 = s1.collider;\n        for(let j = i + 1; j < l; j++){\n            const s2 = $3512fa0ea556b359$var$spheres[j];\n            const c2 = s2.collider;\n            // If they actually intersected\n            $3512fa0ea556b359$var$deltaVec.subVectors(c1.center, c2.center);\n            const depth = $3512fa0ea556b359$var$deltaVec.length() - (c1.radius + c2.radius);\n            if (depth < 0) {\n                $3512fa0ea556b359$var$deltaVec.normalize();\n                // get the magnitude of the velocity in the hit direction\n                const v1dot = s1.velocity.dot($3512fa0ea556b359$var$deltaVec);\n                const v2dot = s2.velocity.dot($3512fa0ea556b359$var$deltaVec);\n                // distribute how much to offset the spheres based on how\n                // quickly they were going relative to each other. The ball\n                // that was moving should move back the most. Add a max value\n                // to avoid jitter.\n                const offsetRatio1 = Math.max(v1dot, 0.2);\n                const offsetRatio2 = Math.max(v2dot, 0.2);\n                const total = offsetRatio1 + offsetRatio2;\n                const ratio1 = offsetRatio1 / total;\n                const ratio2 = offsetRatio2 / total;\n                // correct the positioning of the spheres\n                c1.center.addScaledVector($3512fa0ea556b359$var$deltaVec, -ratio1 * depth);\n                c2.center.addScaledVector($3512fa0ea556b359$var$deltaVec, ratio2 * depth);\n                // Use the momentum formula to adjust velocities\n                const velocityDifference = new $ilwiq.Vector3();\n                velocityDifference.addScaledVector($3512fa0ea556b359$var$deltaVec, -v1dot).addScaledVector($3512fa0ea556b359$var$deltaVec, v2dot);\n                const velDiff = velocityDifference.length();\n                const m1 = s1.mass;\n                const m2 = s2.mass;\n                // Compute new velocities in the moving frame of the sphere that\n                // moved into the other.\n                let newVel1, newVel2;\n                const damping = 0.5;\n                if (velocityDifference.dot(s1.velocity) > velocityDifference.dot(s2.velocity)) {\n                    newVel1 = damping * velDiff * (m1 - m2) / (m1 + m2);\n                    newVel2 = damping * velDiff * 2 * m1 / (m1 + m2);\n                    // remove any existing relative velocity from the moving sphere\n                    newVel1 -= velDiff;\n                } else {\n                    newVel1 = damping * velDiff * 2 * m2 / (m1 + m2);\n                    newVel2 = damping * velDiff * (m2 - m1) / (m1 + m2);\n                    // remove any existing relative velocity from the moving sphere\n                    newVel2 -= velDiff;\n                }\n                // Apply new velocities\n                velocityDifference.normalize();\n                s1.velocity.addScaledVector(velocityDifference, newVel1);\n                s2.velocity.addScaledVector(velocityDifference, newVel2);\n                $3512fa0ea556b359$var$tempVec.copy(c1.center).addScaledVector($3512fa0ea556b359$var$deltaVec, -c1.radius);\n                $3512fa0ea556b359$var$onCollide(s1, s2, $3512fa0ea556b359$var$tempVec, $3512fa0ea556b359$var$deltaVec, velDiff, 0);\n            }\n        }\n        s1.position.copy(c1.center);\n    }\n}\nfunction $3512fa0ea556b359$var$reset() {\n    $3512fa0ea556b359$var$spheres.forEach((s)=>{\n        s.material.dispose();\n        s.geometry.dispose();\n        $3512fa0ea556b359$var$scene.remove(s);\n    });\n    $3512fa0ea556b359$var$spheres.length = 0;\n    $3512fa0ea556b359$var$hits.forEach((h)=>{\n        h.material.dispose();\n        h.geometry.dispose();\n        $3512fa0ea556b359$var$scene.remove(h);\n    });\n    $3512fa0ea556b359$var$hits.length = 0;\n}\nfunction $3512fa0ea556b359$var$explodeSpheres() {\n    const temp = new $ilwiq.Vector3();\n    $3512fa0ea556b359$var$spheres.forEach((s)=>{\n        temp.copy(s.position);\n        temp.y += 10;\n        temp.normalize();\n        s.velocity.addScaledVector(temp, 120);\n    });\n}\n// Update physics and animation\nfunction $3512fa0ea556b359$var$update(delta) {\n    if ($3512fa0ea556b359$var$collider) {\n        const steps = $3512fa0ea556b359$var$params.physicsSteps;\n        for(let i = 0; i < steps; i++)$3512fa0ea556b359$var$updateSphereCollisions(delta / steps);\n    }\n    // Update collision animations\n    for(let i = 0, l = $3512fa0ea556b359$var$hits.length; i < l; i++){\n        const hit = $3512fa0ea556b359$var$hits[i];\n        hit.lifetime += delta;\n        const ratio = hit.lifetime / hit.maxLifetime;\n        let scale = Math.sin(ratio * 4.5 * Math.PI / 4);\n        scale = 1.0 - Math.pow(1.0 - scale, 2);\n        hit.scale.setScalar(scale * hit.maxScale);\n        hit.material.opacity = 1.0 - Math.sin(ratio * 2 * Math.PI / 4);\n        if (ratio >= 1) {\n            $3512fa0ea556b359$var$hits.splice(i, 1);\n            hit.parent.remove(hit);\n            hit.geometry.dispose();\n            hit.material.dispose();\n            i--;\n            l--;\n        }\n    }\n}\nfunction $3512fa0ea556b359$var$render() {\n    $3512fa0ea556b359$var$stats.update();\n    requestAnimationFrame($3512fa0ea556b359$var$render);\n    const delta = Math.min($3512fa0ea556b359$var$clock.getDelta(), 0.1);\n    if ($3512fa0ea556b359$var$collider) {\n        $3512fa0ea556b359$var$collider.visible = $3512fa0ea556b359$var$params.displayCollider;\n        $3512fa0ea556b359$var$visualizer.visible = $3512fa0ea556b359$var$params.displayBVH;\n        if (!$3512fa0ea556b359$var$params.pause) $3512fa0ea556b359$var$update($3512fa0ea556b359$var$params.simulationSpeed * delta);\n    }\n    $3512fa0ea556b359$var$renderer.render($3512fa0ea556b359$var$scene, $3512fa0ea556b359$var$camera);\n}\n\n\n//# sourceMappingURL=physics.3955b22d.js.map\n","// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.bvh || this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n","import * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport Stats from 'stats.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { MeshBVH, MeshBVHHelper, StaticGeometryGenerator } from '..';\n\nconst params = {\n\n\tdisplayCollider: false,\n\tdisplayBVH: false,\n\tdisplayParents: false,\n\tvisualizeDepth: 10,\n\tgravity: - 9.8,\n\tphysicsSteps: 5,\n\t// TODO: support steps based on given sphere velocity / radius\n\tsimulationSpeed: 1,\n\tsphereSize: 1,\n\tpause: false,\n\tstep: () => {\n\n\t\tconst steps = params.physicsSteps;\n\t\tfor ( let i = 0; i < steps; i ++ ) {\n\n\t\t\tupdate( 0.016 / steps );\n\n\t\t}\n\n\t},\n\texplode: explodeSpheres,\n\treset: reset,\n\n};\n\nlet renderer, camera, scene, clock, gui, stats;\nlet environment, collider, visualizer;\nconst spheres = [];\nconst hits = [];\nconst tempSphere = new THREE.Sphere();\nconst deltaVec = new THREE.Vector3();\nconst tempVec = new THREE.Vector3();\nconst forwardVector = new THREE.Vector3( 0, 0, 1 );\n\ninit();\nrender();\n\nfunction init() {\n\n\tconst bgColor = 0x263238 / 2;\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.shadowMap.enabled = true;\n\trenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\tscene.fog = new THREE.Fog( bgColor, 30, 70 );\n\n\t// lights\n\tconst light = new THREE.DirectionalLight( 0xaaccff, 1 );\n\tlight.position.set( 1, 1.5, 1 ).multiplyScalar( 50 );\n\tlight.intensity = 0.25;\n\n\tconst shadowCam = light.shadow.camera;\n\tshadowCam.bottom = shadowCam.left = - 10;\n\tshadowCam.top = shadowCam.right = 10;\n\n\tscene.add( light );\n\tscene.add( new THREE.HemisphereLight( 0x4488ff, 0x223344, 0.3 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 10, 10, - 10 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\twindow.camera = camera;\n\n\tclock = new THREE.Clock();\n\n\tnew OrbitControls( camera, renderer.domElement );\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\tloadColliderEnvironment();\n\n\t// dat.gui\n\tgui = new GUI();\n\tconst visFolder = gui.addFolder( 'Visualization' );\n\tvisFolder.add( params, 'displayCollider' );\n\tvisFolder.add( params, 'displayBVH' );\n\tvisFolder.add( params, 'displayParents' ).onChange( v => {\n\n\t\tvisualizer.displayParents = v;\n\t\tvisualizer.update();\n\n\t} );\n\tvisFolder.add( params, 'visualizeDepth', 1, 20, 1 ).onChange( v => {\n\n\t\tvisualizer.depth = v;\n\t\tvisualizer.update();\n\n\t} );\n\tvisFolder.open();\n\n\tconst physicsFolder = gui.addFolder( 'Physics' );\n\tphysicsFolder.add( params, 'physicsSteps', 0, 30, 1 );\n\tphysicsFolder.add( params, 'gravity', - 100, 100, 0.01 ).onChange( v => {\n\n\t\tparams.gravity = parseFloat( v );\n\n\t} );\n\tphysicsFolder.add( params, 'simulationSpeed', 0, 5, 0.01 );\n\tphysicsFolder.add( params, 'sphereSize', 0.2, 5, 0.1 );\n\tphysicsFolder.add( params, 'pause' );\n\tphysicsFolder.add( params, 'step' );\n\tphysicsFolder.open();\n\n\tgui.add( params, 'explode' );\n\tgui.add( params, 'reset' );\n\tgui.open();\n\n\tconst raycaster = new THREE.Raycaster();\n\tconst mouse = new THREE.Vector2();\n\tlet x = 0;\n\tlet y = 0;\n\trenderer.domElement.addEventListener( 'pointerdown', e => {\n\n\t\tx = e.clientX;\n\t\ty = e.clientY;\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointerup', e => {\n\n\t\tconst totalDelta = Math.abs( e.clientX - x ) + Math.abs( e.clientY - y );\n\t\tif ( totalDelta > 2 ) return;\n\n\t\tmouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tmouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\n\t\traycaster.setFromCamera( mouse, camera );\n\n\t\tconst sphere = createSphere();\n\t\tsphere.position.copy( camera.position ).addScaledVector( raycaster.ray.direction, 3 );\n\t\tsphere\n\t\t\t.velocity\n\t\t\t.set( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 )\n\t\t\t.addScaledVector( raycaster.ray.direction, 10 * Math.random() + 15 )\n\t\t\t.multiplyScalar( 0.5 );\n\n\t} );\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n\twindow.createSphere = createSphere;\n\n}\n\nfunction loadColliderEnvironment() {\n\n\tnew GLTFLoader()\n\t\t.load( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/low-poly-jungle-scene/scene.gltf', res => {\n\n\t\t\tenvironment = res.scene;\n\t\t\tenvironment.scale.setScalar( 0.05 );\n\n\t\t\tconst pointLight = new THREE.PointLight( 0x00ffff );\n\t\t\tpointLight.distance = 7;\n\t\t\tpointLight.position.set( - 100, - 40, 100 );\n\t\t\tenvironment.add( pointLight );\n\n\t\t\tconst porchLight = new THREE.PointLight( 0xffdd66 );\n\t\t\tporchLight.distance = 15;\n\t\t\tporchLight.intensity = 5;\n\t\t\tporchLight.position.set( 80, 80, 135 );\n\t\t\tporchLight.shadow.normalBias = 1e-2;\n\t\t\tporchLight.shadow.bias = - 1e-3;\n\t\t\tporchLight.shadow.mapSize.setScalar( 1024 );\n\t\t\tporchLight.castShadow = true;\n\n\t\t\tenvironment.add( porchLight );\n\n\t\t\t// collect all geometries to merge\n\t\t\tenvironment.updateMatrixWorld( true );\n\n\t\t\tconst staticGenerator = new StaticGeometryGenerator( environment );\n\t\t\tstaticGenerator.attributes = [ 'position' ];\n\n\t\t\tconst mergedGeometry = staticGenerator.generate();\n\t\t\tmergedGeometry.boundsTree = new MeshBVH( mergedGeometry );\n\n\t\t\tcollider = new THREE.Mesh( mergedGeometry );\n\t\t\tcollider.material.wireframe = true;\n\t\t\tcollider.material.opacity = 0.5;\n\t\t\tcollider.material.transparent = true;\n\n\t\t\tvisualizer = new MeshBVHHelper( collider, params.visualizeDepth );\n\t\t\tscene.add( visualizer );\n\t\t\tscene.add( collider );\n\t\t\tscene.add( environment );\n\n\t\t\tenvironment.traverse( c => {\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tc.castShadow = true;\n\t\t\t\t\tc.receiveShadow = true;\n\t\t\t\t\tc.material.shadowSide = 2;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n}\n\nfunction onCollide( object1, object2, point, normal, velocity, offset = 0 ) {\n\n\tif ( velocity < Math.max( Math.abs( 0.04 * params.gravity ), 5 ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// Create an animation when objects collide\n\tconst effectScale = Math.max(\n\t\tobject2 ?\n\t\t\tMath.max( object1.collider.radius, object2.collider.radius ) :\n\t\t\tobject1.collider.radius,\n\t\t0.4\n\t) * 2.0;\n\tconst plane = new THREE.Mesh(\n\t\tnew THREE.RingGeometry( 0, 1, 30 ),\n\t\tnew THREE.MeshBasicMaterial( { side: 2, transparent: true, depthWrite: false } )\n\t);\n\tplane.lifetime = 0;\n\tplane.maxLifetime = 0.4;\n\tplane.maxScale = effectScale * Math.max( Math.sin( Math.min( velocity / 200, 1 ) * Math.PI / 2 ), 0.35 );\n\n\tplane.position.copy( point ).addScaledVector( normal, offset );\n\tplane.quaternion.setFromUnitVectors( forwardVector, normal );\n\tscene.add( plane );\n\thits.push( plane );\n\n}\n\nfunction createSphere() {\n\n\tconst white = new THREE.Color( 0xffffff );\n\tconst color = new THREE.Color( 0x263238 / 2 ).lerp( white, Math.random() * 0.5 + 0.5 ).convertSRGBToLinear();\n\tconst sphere = new THREE.Mesh(\n\t\tnew THREE.SphereGeometry( 1, 20, 20 ),\n\t\tnew THREE.MeshStandardMaterial( { color } )\n\t);\n\tscene.add( sphere );\n\tsphere.castShadow = true;\n\tsphere.receiveShadow = true;\n\tsphere.material.shadowSide = 2;\n\n\tconst radius = 0.5 * params.sphereSize * ( Math.random() * .2 + 0.6 );\n\tsphere.scale.setScalar( radius );\n\tsphere.collider = new THREE.Sphere( sphere.position, radius );\n\tsphere.velocity = new THREE.Vector3( 0, 0, 0 );\n\tsphere.mass = Math.pow( radius, 3 ) * Math.PI * 4 / 3;\n\n\tspheres.push( sphere );\n\treturn sphere;\n\n}\n\nfunction updateSphereCollisions( deltaTime ) {\n\n\t// TODO: Add visualization for velocity vector, collision vector, all intersection vectors\n\tconst bvh = collider.geometry.boundsTree;\n\tfor ( let i = 0, l = spheres.length; i < l; i ++ ) {\n\n\t\tconst sphere = spheres[ i ];\n\t\tconst sphereCollider = sphere.collider;\n\n\t\t// move the sphere\n\t\tsphere.velocity.y += params.gravity * deltaTime;\n\t\tsphereCollider.center.addScaledVector( sphere.velocity, deltaTime );\n\n\t\t// remove the spheres if they've left the world\n\t\tif ( sphereCollider.center.y < - 80 ) {\n\n\t\t\tspheres.splice( i, 1 );\n\t\t\ti --;\n\t\t\tl --;\n\n\t\t\tsphere.material.dispose();\n\t\t\tsphere.geometry.dispose();\n\t\t\tscene.remove( sphere );\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// get the sphere position in world space\n\t\ttempSphere.copy( sphere.collider );\n\n\t\tlet collided = false;\n\t\tbvh.shapecast( {\n\n\t\t\tintersectsBounds: box => {\n\n\t\t\t\treturn box.intersectsSphere( tempSphere );\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t// get delta between closest point and center\n\t\t\t\ttri.closestPointToPoint( tempSphere.center, deltaVec );\n\t\t\t\tdeltaVec.sub( tempSphere.center );\n\t\t\t\tconst distance = deltaVec.length();\n\t\t\t\tif ( distance < tempSphere.radius ) {\n\n\t\t\t\t\t// move the sphere position to be outside the triangle\n\t\t\t\t\tconst radius = tempSphere.radius;\n\t\t\t\t\tconst depth = distance - radius;\n\t\t\t\t\tdeltaVec.multiplyScalar( 1 / distance );\n\t\t\t\t\ttempSphere.center.addScaledVector( deltaVec, depth );\n\n\t\t\t\t\tcollided = true;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn box.distanceToPoint( tempSphere.center ) - tempSphere.radius;\n\n\t\t\t},\n\n\t\t} );\n\n\t\tif ( collided ) {\n\n\t\t\t// get the delta direction and reflect the velocity across it\n\t\t\tdeltaVec.subVectors( tempSphere.center, sphereCollider.center ).normalize();\n\t\t\tsphere.velocity.reflect( deltaVec );\n\n\t\t\t// dampen the velocity and apply some drag\n\t\t\tconst dot = sphere.velocity.dot( deltaVec );\n\t\t\tsphere.velocity.addScaledVector( deltaVec, - dot * 0.5 );\n\t\t\tsphere.velocity.multiplyScalar( Math.max( 1.0 - deltaTime, 0 ) );\n\n\t\t\t// update the sphere collider position\n\t\t\tsphereCollider.center.copy( tempSphere.center );\n\n\t\t\t// find the point on the surface that was hit\n\t\t\ttempVec\n\t\t\t\t.copy( tempSphere.center )\n\t\t\t\t.addScaledVector( deltaVec, - tempSphere.radius );\n\t\t\tonCollide( sphere, null, tempVec, deltaVec, dot, 0.05 );\n\n\t\t}\n\n\t}\n\n\t// Handle sphere collisions\n\tfor ( let i = 0, l = spheres.length; i < l; i ++ ) {\n\n\t\tconst s1 = spheres[ i ];\n\t\tconst c1 = s1.collider;\n\t\tfor ( let j = i + 1; j < l; j ++ ) {\n\n\t\t\tconst s2 = spheres[ j ];\n\t\t\tconst c2 = s2.collider;\n\n\t\t\t// If they actually intersected\n\t\t\tdeltaVec.subVectors( c1.center, c2.center );\n\t\t\tconst depth = deltaVec.length() - ( c1.radius + c2.radius );\n\t\t\tif ( depth < 0 ) {\n\n\t\t\t\tdeltaVec.normalize();\n\n\t\t\t\t// get the magnitude of the velocity in the hit direction\n\t\t\t\tconst v1dot = s1.velocity.dot( deltaVec );\n\t\t\t\tconst v2dot = s2.velocity.dot( deltaVec );\n\n\t\t\t\t// distribute how much to offset the spheres based on how\n\t\t\t\t// quickly they were going relative to each other. The ball\n\t\t\t\t// that was moving should move back the most. Add a max value\n\t\t\t\t// to avoid jitter.\n\t\t\t\tconst offsetRatio1 = Math.max( v1dot, 0.2 );\n\t\t\t\tconst offsetRatio2 = Math.max( v2dot, 0.2 );\n\n\t\t\t\tconst total = offsetRatio1 + offsetRatio2;\n\t\t\t\tconst ratio1 = offsetRatio1 / total;\n\t\t\t\tconst ratio2 = offsetRatio2 / total;\n\n\t\t\t\t// correct the positioning of the spheres\n\t\t\t\tc1.center.addScaledVector( deltaVec, - ratio1 * depth );\n\t\t\t\tc2.center.addScaledVector( deltaVec, ratio2 * depth );\n\n\t\t\t\t// Use the momentum formula to adjust velocities\n\t\t\t\tconst velocityDifference = new THREE.Vector3();\n\t\t\t\tvelocityDifference\n\t\t\t\t\t.addScaledVector( deltaVec, - v1dot )\n\t\t\t\t\t.addScaledVector( deltaVec, v2dot );\n\n\t\t\t\tconst velDiff = velocityDifference.length();\n\t\t\t\tconst m1 = s1.mass;\n\t\t\t\tconst m2 = s2.mass;\n\n\t\t\t\t// Compute new velocities in the moving frame of the sphere that\n\t\t\t\t// moved into the other.\n\t\t\t\tlet newVel1, newVel2;\n\t\t\t\tconst damping = 0.5;\n\t\t\t\tif ( velocityDifference.dot( s1.velocity ) > velocityDifference.dot( s2.velocity ) ) {\n\n\t\t\t\t\tnewVel1 = damping * velDiff * ( m1 - m2 ) / ( m1 + m2 );\n\t\t\t\t\tnewVel2 = damping * velDiff * 2 * m1 / ( m1 + m2 );\n\n\t\t\t\t\t// remove any existing relative velocity from the moving sphere\n\t\t\t\t\tnewVel1 -= velDiff;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewVel1 = damping * velDiff * 2 * m2 / ( m1 + m2 );\n\t\t\t\t\tnewVel2 = damping * velDiff * ( m2 - m1 ) / ( m1 + m2 );\n\n\t\t\t\t\t// remove any existing relative velocity from the moving sphere\n\t\t\t\t\tnewVel2 -= velDiff;\n\n\t\t\t\t}\n\n\t\t\t\t// Apply new velocities\n\t\t\t\tvelocityDifference.normalize();\n\t\t\t\ts1.velocity.addScaledVector( velocityDifference, newVel1 );\n\t\t\t\ts2.velocity.addScaledVector( velocityDifference, newVel2 );\n\n\t\t\t\ttempVec.copy( c1.center ).addScaledVector( deltaVec, - c1.radius );\n\t\t\t\tonCollide( s1, s2, tempVec, deltaVec, velDiff, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\ts1.position.copy( c1.center );\n\n\t}\n\n}\n\nfunction reset() {\n\n\tspheres.forEach( s => {\n\n\t\ts.material.dispose();\n\t\ts.geometry.dispose();\n\t\tscene.remove( s );\n\n\t} );\n\tspheres.length = 0;\n\n\thits.forEach( h => {\n\n\t\th.material.dispose();\n\t\th.geometry.dispose();\n\t\tscene.remove( h );\n\n\t} );\n\thits.length = 0;\n\n}\n\nfunction explodeSpheres() {\n\n\tconst temp = new THREE.Vector3();\n\tspheres.forEach( s => {\n\n\t\ttemp.copy( s.position );\n\t\ttemp.y += 10;\n\t\ttemp.normalize();\n\t\ts.velocity.addScaledVector( temp, 120 );\n\n\t} );\n\n}\n\n// Update physics and animation\nfunction update( delta ) {\n\n\tif ( collider ) {\n\n\t\tconst steps = params.physicsSteps;\n\t\tfor ( let i = 0; i < steps; i ++ ) {\n\n\t\t\tupdateSphereCollisions( delta / steps );\n\n\t\t}\n\n\t}\n\n\t// Update collision animations\n\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\tconst hit = hits[ i ];\n\t\thit.lifetime += delta;\n\n\t\tconst ratio = hit.lifetime / hit.maxLifetime;\n\t\tlet scale = Math.sin( ratio * 4.5 * Math.PI / 4 );\n\t\tscale = 1.0 - Math.pow( 1.0 - scale, 2 );\n\t\thit.scale.setScalar( scale * hit.maxScale );\n\t\thit.material.opacity = 1.0 - Math.sin( ratio * 2 * Math.PI / 4 );\n\n\t\tif ( ratio >= 1 ) {\n\n\t\t\thits.splice( i, 1 );\n\t\t\thit.parent.remove( hit );\n\t\t\thit.geometry.dispose();\n\t\t\thit.material.dispose();\n\t\t\ti --;\n\t\t\tl --;\n\n\t\t}\n\n\t}\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tconst delta = Math.min( clock.getDelta(), 0.1 );\n\n\tif ( collider ) {\n\n\t\tcollider.visible = params.displayCollider;\n\t\tvisualizer.visible = params.displayBVH;\n\n\t\tif ( ! params.pause ) {\n\n\t\t\tupdate( params.simulationSpeed * delta );\n\n\t\t}\n\n\t}\n\n\trenderer.render( scene, camera );\n\n}\n"],"names":["$3512fa0ea556b359$var$renderer","$3512fa0ea556b359$var$camera","$3512fa0ea556b359$var$scene","$3512fa0ea556b359$var$clock","$3512fa0ea556b359$var$gui","$3512fa0ea556b359$var$stats","$3512fa0ea556b359$var$environment","$3512fa0ea556b359$var$collider","$3512fa0ea556b359$var$visualizer","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","f","e","a","c","appendChild","dom","u","d","children","length","style","display","l","document","createElement","cssText","addEventListener","preventDefault","k","performance","Date","now","g","r","Panel","h","self","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","Infinity","Math","round","window","devicePixelRatio","v","m","n","p","q","width","height","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","w","min","max","drawImage","Object","defineProperty","get","$3c85f35a8c29fa9b$export$e57d74bcb7e3bec5","set","s","enumerable","configurable","$ilwiq","$aw71y","$ff8ed","$3c85f35a8c29fa9b$var$boundingBox","Box3","$3c85f35a8c29fa9b$var$MeshBVHRootHelper","Object3D","isMesh","displayEdges","isLineSegments","isLine","constructor","bvh","material","depth","group","geometry","BufferGeometry","name","displayParents","_group","raycast","boundsTree","dispose","visible","indexArray","indices","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","arrayToBox","x","xVal","y","yVal","z","zVal","Uint8Array","Uint32Array","Uint16Array","indexLength","i","posOffset","indexOffset","j","setIndex","BufferAttribute","setAttribute","Group","color","edgeMaterial","opacity","meshMaterial","mesh","MeshBVH","_roots","LineBasicMaterial","transparent","depthWrite","MeshBasicMaterial","totalRoots","root","pop","remove","add","push","updateMatrixWorld","args","parent","updateWorldMatrix","matrix","copy","matrixWorld","invert","multiply","decompose","position","quaternion","scale","source","clone","$7lx9d","$5Rd1x","$c8CJQ","$jiuw3","$5ca9G","$jAT47","$3512fa0ea556b359$var$params","displayCollider","displayBVH","visualizeDepth","gravity","physicsSteps","simulationSpeed","sphereSize","pause","step","steps","$3512fa0ea556b359$var$update","explode","temp","Vector3","$3512fa0ea556b359$var$spheres","forEach","normalize","velocity","addScaledVector","reset","$3512fa0ea556b359$var$hits","$3512fa0ea556b359$var$tempSphere","Sphere","$3512fa0ea556b359$var$deltaVec","$3512fa0ea556b359$var$tempVec","$3512fa0ea556b359$var$forwardVector","$3512fa0ea556b359$var$onCollide","object1","object2","point","normal","offset","abs","effectScale","collider","radius","plane","Mesh","RingGeometry","side","lifetime","maxLifetime","maxScale","sin","PI","setFromUnitVectors","$3512fa0ea556b359$var$createSphere","white","Color","lerp","random","convertSRGBToLinear","sphere","SphereGeometry","MeshStandardMaterial","castShadow","receiveShadow","shadowSide","setScalar","mass","pow","delta","$3512fa0ea556b359$var$updateSphereCollisions","deltaTime","sphereCollider","center","splice","collided","shapecast","intersectsBounds","box","intersectsSphere","intersectsTriangle","tri","closestPointToPoint","sub","distance","multiplyScalar","boundsTraverseOrder","distanceToPoint","subVectors","reflect","dot","s1","c1","s2","c2","newVel1","newVel2","v1dot","v2dot","offsetRatio1","offsetRatio2","total","ratio1","ratio2","velocityDifference","velDiff","m1","m2","damping","hit","ratio","$3512fa0ea556b359$var$init","WebGLRenderer","antialias","setPixelRatio","setSize","innerWidth","innerHeight","setClearColor","shadowMap","enabled","type","PCFSoftShadowMap","outputEncoding","sRGBEncoding","body","Scene","fog","Fog","light","DirectionalLight","intensity","shadowCam","shadow","camera","bottom","left","top","right","HemisphereLight","PerspectiveCamera","far","updateProjectionMatrix","Clock","OrbitControls","__esModule","default","GLTFLoader","load","res","scene","pointLight","PointLight","porchLight","normalBias","bias","mapSize","staticGenerator","StaticGeometryGenerator","attributes","mergedGeometry","generate","wireframe","MeshBVHHelper","visFolder","GUI","addFolder","onChange","open","physicsFolder","parseFloat","raycaster","Raycaster","mouse","Vector2","clientX","clientY","totalDelta","setFromCamera","ray","direction","aspect","createSphere","$3512fa0ea556b359$var$render","requestAnimationFrame","getDelta","render"],"version":3,"file":"physics.3955b22d.js.map"}