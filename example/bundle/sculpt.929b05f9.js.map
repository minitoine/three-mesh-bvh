{"mappings":"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","sources":["<anon>","node_modules/stats.js/src/Stats.js","src/utils/ExtensionUtilities.js","src/utils/GeometryRayIntersectUtilities.js","src/objects/MeshBVHHelper.js","example/sculpt.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"hBOJ2\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $cd1d3d651be7f2fc$export$2e2bcd8739ae039);\n/**\n * @author mrdoob / http://mrdoob.com/\n */ var $cd1d3d651be7f2fc$export$2e2bcd8739ae039 = function() {\n    var mode = 0;\n    var container = document.createElement(\"div\");\n    container.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n    container.addEventListener(\"click\", function(event) {\n        event.preventDefault();\n        showPanel(++mode % container.children.length);\n    }, false);\n    //\n    function addPanel(panel) {\n        container.appendChild(panel.dom);\n        return panel;\n    }\n    function showPanel(id) {\n        for(var i = 0; i < container.children.length; i++)container.children[i].style.display = i === id ? \"block\" : \"none\";\n        mode = id;\n    }\n    //\n    var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;\n    var fpsPanel = addPanel(new $cd1d3d651be7f2fc$export$2e2bcd8739ae039.Panel(\"FPS\", \"#0ff\", \"#002\"));\n    var msPanel = addPanel(new $cd1d3d651be7f2fc$export$2e2bcd8739ae039.Panel(\"MS\", \"#0f0\", \"#020\"));\n    if (self.performance && self.performance.memory) var memPanel = addPanel(new $cd1d3d651be7f2fc$export$2e2bcd8739ae039.Panel(\"MB\", \"#f08\", \"#201\"));\n    showPanel(0);\n    return {\n        REVISION: 16,\n        dom: container,\n        addPanel: addPanel,\n        showPanel: showPanel,\n        begin: function() {\n            beginTime = (performance || Date).now();\n        },\n        end: function() {\n            frames++;\n            var time = (performance || Date).now();\n            msPanel.update(time - beginTime, 200);\n            if (time > prevTime + 1000) {\n                fpsPanel.update(frames * 1000 / (time - prevTime), 100);\n                prevTime = time;\n                frames = 0;\n                if (memPanel) {\n                    var memory = performance.memory;\n                    memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);\n                }\n            }\n            return time;\n        },\n        update: function() {\n            beginTime = this.end();\n        },\n        // Backwards Compatibility\n        domElement: container,\n        setMode: showPanel\n    };\n};\n$cd1d3d651be7f2fc$export$2e2bcd8739ae039.Panel = function(name, fg, bg) {\n    var min = Infinity, max = 0, round = Math.round;\n    var PR = round(window.devicePixelRatio || 1);\n    var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = WIDTH;\n    canvas.height = HEIGHT;\n    canvas.style.cssText = \"width:80px;height:48px\";\n    var context = canvas.getContext(\"2d\");\n    context.font = \"bold \" + 9 * PR + \"px Helvetica,Arial,sans-serif\";\n    context.textBaseline = \"top\";\n    context.fillStyle = bg;\n    context.fillRect(0, 0, WIDTH, HEIGHT);\n    context.fillStyle = fg;\n    context.fillText(name, TEXT_X, TEXT_Y);\n    context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n    context.fillStyle = bg;\n    context.globalAlpha = 0.9;\n    context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n    return {\n        dom: canvas,\n        update: function(value, maxValue) {\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n            context.fillStyle = bg;\n            context.globalAlpha = 1;\n            context.fillRect(0, 0, WIDTH, GRAPH_Y);\n            context.fillStyle = fg;\n            context.fillText(round(value) + \" \" + name + \" (\" + round(min) + \"-\" + round(max) + \")\", TEXT_X, TEXT_Y);\n            context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);\n            context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);\n            context.fillStyle = bg;\n            context.globalAlpha = 0.9;\n            context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));\n        }\n    };\n};\n\n});\n\nparcelRegister(\"4h5hN\", function(module, exports) {\n\n$parcel$export(module.exports, \"acceleratedRaycast\", () => $31ccd9a92979d6bb$export$a0dc2935489c814a);\n$parcel$export(module.exports, \"computeBoundsTree\", () => $31ccd9a92979d6bb$export$749bba8a65fa6d70);\n$parcel$export(module.exports, \"disposeBoundsTree\", () => $31ccd9a92979d6bb$export$e0a981a7a32ddba4);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $b4YKL = parcelRequire(\"b4YKL\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $31ccd9a92979d6bb$var$ray = /* @__PURE__ */ new (0, $ilwiq.Ray)();\nconst $31ccd9a92979d6bb$var$tmpInverseMatrix = /* @__PURE__ */ new (0, $ilwiq.Matrix4)();\nconst $31ccd9a92979d6bb$var$origMeshRaycastFunc = (0, $ilwiq.Mesh).prototype.raycast;\nfunction $31ccd9a92979d6bb$export$a0dc2935489c814a(raycaster, intersects) {\n    if (this.geometry.boundsTree) {\n        if (this.material === undefined) return;\n        $31ccd9a92979d6bb$var$tmpInverseMatrix.copy(this.matrixWorld).invert();\n        $31ccd9a92979d6bb$var$ray.copy(raycaster.ray).applyMatrix4($31ccd9a92979d6bb$var$tmpInverseMatrix);\n        const bvh = this.geometry.boundsTree;\n        if (raycaster.firstHitOnly === true) {\n            const hit = (0, $b4YKL.convertRaycastIntersect)(bvh.raycastFirst($31ccd9a92979d6bb$var$ray, this.material), this, raycaster);\n            if (hit) intersects.push(hit);\n        } else {\n            const hits = bvh.raycast($31ccd9a92979d6bb$var$ray, this.material);\n            for(let i = 0, l = hits.length; i < l; i++){\n                const hit = (0, $b4YKL.convertRaycastIntersect)(hits[i], this, raycaster);\n                if (hit) intersects.push(hit);\n            }\n        }\n    } else $31ccd9a92979d6bb$var$origMeshRaycastFunc.call(this, raycaster, intersects);\n}\nfunction $31ccd9a92979d6bb$export$749bba8a65fa6d70(options) {\n    this.boundsTree = new (0, $ff8ed.MeshBVH)(this, options);\n    return this.boundsTree;\n}\nfunction $31ccd9a92979d6bb$export$e0a981a7a32ddba4() {\n    this.boundsTree = null;\n}\n\n});\nparcelRegister(\"b4YKL\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertRaycastIntersect\", () => $810f31c6ff4f494e$export$adb106eed99e8cd8);\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nfunction $810f31c6ff4f494e$export$adb106eed99e8cd8(hit, object, raycaster) {\n    if (hit === null) return null;\n    hit.point.applyMatrix4(object.matrixWorld);\n    hit.distance = hit.point.distanceTo(raycaster.ray.origin);\n    hit.object = object;\n    if (hit.distance < raycaster.near || hit.distance > raycaster.far) return null;\n    else return hit;\n}\n\n});\n\n\nparcelRegister(\"5ca9G\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHHelper\", () => $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $3c85f35a8c29fa9b$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nclass $3c85f35a8c29fa9b$var$MeshBVHRootHelper extends (0, $ilwiq.Object3D) {\n    get isMesh() {\n        return !this.displayEdges;\n    }\n    get isLineSegments() {\n        return this.displayEdges;\n    }\n    get isLine() {\n        return this.displayEdges;\n    }\n    constructor(bvh, material, depth = 10, group = 0){\n        super();\n        this.material = material;\n        this.geometry = new (0, $ilwiq.BufferGeometry)();\n        this.name = \"MeshBVHRootHelper\";\n        this.depth = depth;\n        this.displayParents = false;\n        this.bvh = bvh;\n        this.displayEdges = true;\n        this._group = group;\n    }\n    raycast() {}\n    update() {\n        const geometry = this.geometry;\n        const boundsTree = this.bvh;\n        const group = this._group;\n        geometry.dispose();\n        this.visible = false;\n        if (boundsTree) {\n            // count the number of bounds required\n            const targetDepth = this.depth - 1;\n            const displayParents = this.displayParents;\n            let boundsCount = 0;\n            boundsTree.traverse((depth, isLeaf)=>{\n                if (depth >= targetDepth || isLeaf) {\n                    boundsCount++;\n                    return true;\n                } else if (displayParents) boundsCount++;\n            }, group);\n            // fill in the position buffer with the bounds corners\n            let posIndex = 0;\n            const positionArray = new Float32Array(24 * boundsCount);\n            boundsTree.traverse((depth, isLeaf, boundingData)=>{\n                const terminate = depth >= targetDepth || isLeaf;\n                if (terminate || displayParents) {\n                    (0, $aw71y.arrayToBox)(0, boundingData, $3c85f35a8c29fa9b$var$boundingBox);\n                    const { min: min, max: max } = $3c85f35a8c29fa9b$var$boundingBox;\n                    for(let x = -1; x <= 1; x += 2){\n                        const xVal = x < 0 ? min.x : max.x;\n                        for(let y = -1; y <= 1; y += 2){\n                            const yVal = y < 0 ? min.y : max.y;\n                            for(let z = -1; z <= 1; z += 2){\n                                const zVal = z < 0 ? min.z : max.z;\n                                positionArray[posIndex + 0] = xVal;\n                                positionArray[posIndex + 1] = yVal;\n                                positionArray[posIndex + 2] = zVal;\n                                posIndex += 3;\n                            }\n                        }\n                    }\n                    return terminate;\n                }\n            }, group);\n            let indexArray;\n            let indices;\n            if (this.displayEdges) // fill in the index buffer to point to the corner points\n            indices = new Uint8Array([\n                // x axis\n                0,\n                4,\n                1,\n                5,\n                2,\n                6,\n                3,\n                7,\n                // y axis\n                0,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                7,\n                // z axis\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7\n            ]);\n            else indices = new Uint8Array([\n                // X-, X+\n                0,\n                1,\n                2,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                6,\n                7,\n                5,\n                // Y-, Y+\n                1,\n                4,\n                5,\n                0,\n                4,\n                1,\n                2,\n                3,\n                6,\n                3,\n                7,\n                6,\n                // Z-, Z+\n                0,\n                2,\n                4,\n                2,\n                6,\n                4,\n                1,\n                5,\n                3,\n                3,\n                5,\n                7\n            ]);\n            if (positionArray.length > 65535) indexArray = new Uint32Array(indices.length * boundsCount);\n            else indexArray = new Uint16Array(indices.length * boundsCount);\n            const indexLength = indices.length;\n            for(let i = 0; i < boundsCount; i++){\n                const posOffset = i * 8;\n                const indexOffset = i * indexLength;\n                for(let j = 0; j < indexLength; j++)indexArray[indexOffset + j] = posOffset + indices[j];\n            }\n            // update the geometry\n            geometry.setIndex(new (0, $ilwiq.BufferAttribute)(indexArray, 1, false));\n            geometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(positionArray, 3, false));\n            this.visible = true;\n        }\n    }\n}\nclass $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 extends (0, $ilwiq.Group) {\n    get color() {\n        return this.edgeMaterial.color;\n    }\n    get opacity() {\n        return this.edgeMaterial.opacity;\n    }\n    set opacity(v) {\n        this.edgeMaterial.opacity = v;\n        this.meshMaterial.opacity = v;\n    }\n    constructor(mesh = null, bvh = null, depth = 10){\n        // handle bvh, depth signature\n        if (mesh instanceof (0, $ff8ed.MeshBVH)) {\n            depth = bvh || 10;\n            bvh = mesh;\n            mesh = null;\n        }\n        // handle mesh, depth signature\n        if (typeof bvh === \"number\") {\n            depth = bvh;\n            bvh = null;\n        }\n        super();\n        this.name = \"MeshBVHHelper\";\n        this.depth = depth;\n        this.mesh = mesh;\n        this.bvh = bvh;\n        this.displayParents = false;\n        this.displayEdges = true;\n        this._roots = [];\n        const edgeMaterial = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        const meshMaterial = new (0, $ilwiq.MeshBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        meshMaterial.color = edgeMaterial.color;\n        this.edgeMaterial = edgeMaterial;\n        this.meshMaterial = meshMaterial;\n        this.update();\n    }\n    update() {\n        const bvh = this.bvh || this.mesh.geometry.boundsTree;\n        const totalRoots = bvh ? bvh._roots.length : 0;\n        while(this._roots.length > totalRoots){\n            const root = this._roots.pop();\n            root.geometry.dispose();\n            this.remove(root);\n        }\n        for(let i = 0; i < totalRoots; i++){\n            const { depth: depth, edgeMaterial: edgeMaterial, meshMaterial: meshMaterial, displayParents: displayParents, displayEdges: displayEdges } = this;\n            if (i >= this._roots.length) {\n                const root = new $3c85f35a8c29fa9b$var$MeshBVHRootHelper(bvh, edgeMaterial, depth, i);\n                this.add(root);\n                this._roots.push(root);\n            }\n            const root = this._roots[i];\n            root.bvh = bvh;\n            root.depth = depth;\n            root.displayParents = displayParents;\n            root.displayEdges = displayEdges;\n            root.material = displayEdges ? edgeMaterial : meshMaterial;\n            root.update();\n        }\n    }\n    updateMatrixWorld(...args) {\n        const mesh = this.mesh;\n        const parent = this.parent;\n        if (mesh !== null) {\n            mesh.updateWorldMatrix(true, false);\n            if (parent) this.matrix.copy(parent.matrixWorld).invert().multiply(mesh.matrixWorld);\n            else this.matrix.copy(mesh.matrixWorld);\n            this.matrix.decompose(this.position, this.quaternion, this.scale);\n        }\n        super.updateMatrixWorld(...args);\n    }\n    copy(source) {\n        this.depth = source.depth;\n        this.mesh = source.mesh;\n        this.bvh = source.bvh;\n        this.opacity = source.opacity;\n        this.color.copy(source.color);\n    }\n    clone() {\n        return new $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5(this.mesh, this.bvh, this.depth);\n    }\n    dispose() {\n        this.edgeMaterial.dispose();\n        this.meshMaterial.dispose();\n        const children = this.children;\n        for(let i = 0, l = children.length; i < l; i++)children[i].geometry.dispose();\n    }\n}\nclass $3c85f35a8c29fa9b$export$5ead38ed5c75a1c8 extends $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 {\n    constructor(...args){\n        super(...args);\n        console.warn(\"MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.\");\n    }\n}\n\n});\n\n\nvar $hBOJ2 = parcelRequire(\"hBOJ2\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $7ePFa = parcelRequire(\"7ePFa\");\n\nvar $4h5hN = parcelRequire(\"4h5hN\");\nvar $Mleu6 = parcelRequire(\"Mleu6\");\nvar $5ca9G = parcelRequire(\"5ca9G\");\n$ilwiq.Mesh.prototype.raycast = (0, $4h5hN.acceleratedRaycast);\n$ilwiq.BufferGeometry.prototype.computeBoundsTree = (0, $4h5hN.computeBoundsTree);\n$ilwiq.BufferGeometry.prototype.disposeBoundsTree = (0, $4h5hN.disposeBoundsTree);\nlet $abfc71144f7bffd4$var$stats;\nlet $abfc71144f7bffd4$var$scene, $abfc71144f7bffd4$var$camera, $abfc71144f7bffd4$var$renderer, $abfc71144f7bffd4$var$controls;\nlet $abfc71144f7bffd4$var$targetMesh, $abfc71144f7bffd4$var$brush, $abfc71144f7bffd4$var$symmetryBrush, $abfc71144f7bffd4$var$bvhHelper;\nlet $abfc71144f7bffd4$var$normalZ = new $ilwiq.Vector3(0, 0, 1);\nlet $abfc71144f7bffd4$var$brushActive = false;\nlet $abfc71144f7bffd4$var$mouse = new $ilwiq.Vector2(), $abfc71144f7bffd4$var$lastMouse = new $ilwiq.Vector2();\nlet $abfc71144f7bffd4$var$mouseState = false, $abfc71144f7bffd4$var$lastMouseState = false;\nlet $abfc71144f7bffd4$var$lastCastPose = new $ilwiq.Vector3();\nlet $abfc71144f7bffd4$var$material, $abfc71144f7bffd4$var$rightClick = false;\nconst $abfc71144f7bffd4$var$params = {\n    matcap: \"Clay\",\n    size: 0.1,\n    brush: \"clay\",\n    intensity: 50,\n    maxSteps: 10,\n    invert: false,\n    symmetrical: true,\n    flatShading: false,\n    depth: 10,\n    displayHelper: false\n};\nconst $abfc71144f7bffd4$var$matcaps = {};\n$abfc71144f7bffd4$var$init();\n$abfc71144f7bffd4$var$render();\n// reset the sculpt mesh\nfunction $abfc71144f7bffd4$var$reset() {\n    // dispose of the mesh if it exists\n    if ($abfc71144f7bffd4$var$targetMesh) {\n        $abfc71144f7bffd4$var$targetMesh.geometry.dispose();\n        $abfc71144f7bffd4$var$targetMesh.material.dispose();\n        $abfc71144f7bffd4$var$scene.remove($abfc71144f7bffd4$var$targetMesh);\n    }\n    // merge the vertices because they're not already merged\n    let geometry = new $ilwiq.IcosahedronBufferGeometry(1, 100);\n    geometry.deleteAttribute(\"uv\");\n    geometry = $7ePFa.mergeVertices(geometry);\n    geometry.attributes.position.setUsage($ilwiq.DynamicDrawUsage);\n    geometry.attributes.normal.setUsage($ilwiq.DynamicDrawUsage);\n    geometry.computeBoundsTree({\n        setBoundingBox: false\n    });\n    // disable frustum culling because the verts will be updated\n    $abfc71144f7bffd4$var$targetMesh = new $ilwiq.Mesh(geometry, $abfc71144f7bffd4$var$material);\n    $abfc71144f7bffd4$var$targetMesh.frustumCulled = false;\n    $abfc71144f7bffd4$var$scene.add($abfc71144f7bffd4$var$targetMesh);\n    // initialize bvh helper\n    if (!$abfc71144f7bffd4$var$bvhHelper) {\n        $abfc71144f7bffd4$var$bvhHelper = new (0, $5ca9G.MeshBVHHelper)($abfc71144f7bffd4$var$targetMesh, $abfc71144f7bffd4$var$params.depth);\n        if ($abfc71144f7bffd4$var$params.displayHelper) $abfc71144f7bffd4$var$scene.add($abfc71144f7bffd4$var$bvhHelper);\n    }\n    $abfc71144f7bffd4$var$bvhHelper.mesh = $abfc71144f7bffd4$var$targetMesh;\n    $abfc71144f7bffd4$var$bvhHelper.update();\n}\nfunction $abfc71144f7bffd4$var$init() {\n    const bgColor = 0x060609;\n    // renderer setup\n    $abfc71144f7bffd4$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $abfc71144f7bffd4$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $abfc71144f7bffd4$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $abfc71144f7bffd4$var$renderer.setClearColor(bgColor, 1);\n    $abfc71144f7bffd4$var$renderer.outputEncoding = $ilwiq.sRGBEncoding;\n    document.body.appendChild($abfc71144f7bffd4$var$renderer.domElement);\n    $abfc71144f7bffd4$var$renderer.domElement.style.touchAction = \"none\";\n    // scene setup\n    $abfc71144f7bffd4$var$scene = new $ilwiq.Scene();\n    $abfc71144f7bffd4$var$scene.fog = new $ilwiq.Fog(1251612, 20, 60);\n    const light = new $ilwiq.DirectionalLight(0xffffff, 0.5);\n    light.position.set(1, 1, 1);\n    $abfc71144f7bffd4$var$scene.add(light);\n    $abfc71144f7bffd4$var$scene.add(new $ilwiq.AmbientLight(0xffffff, 0.4));\n    // initialize brush cursor\n    const brushSegments = [\n        new $ilwiq.Vector3(),\n        new $ilwiq.Vector3(0, 0, 1)\n    ];\n    for(let i = 0; i < 50; i++){\n        const nexti = i + 1;\n        const x1 = Math.sin(2 * Math.PI * i / 50);\n        const y1 = Math.cos(2 * Math.PI * i / 50);\n        const x2 = Math.sin(2 * Math.PI * nexti / 50);\n        const y2 = Math.cos(2 * Math.PI * nexti / 50);\n        brushSegments.push(new $ilwiq.Vector3(x1, y1, 0), new $ilwiq.Vector3(x2, y2, 0));\n    }\n    $abfc71144f7bffd4$var$brush = new $ilwiq.LineSegments();\n    $abfc71144f7bffd4$var$brush.geometry.setFromPoints(brushSegments);\n    $abfc71144f7bffd4$var$brush.material.color.set(0xfb8c00);\n    $abfc71144f7bffd4$var$scene.add($abfc71144f7bffd4$var$brush);\n    $abfc71144f7bffd4$var$symmetryBrush = $abfc71144f7bffd4$var$brush.clone();\n    $abfc71144f7bffd4$var$scene.add($abfc71144f7bffd4$var$symmetryBrush);\n    // camera setup\n    $abfc71144f7bffd4$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);\n    $abfc71144f7bffd4$var$camera.position.set(0, 0, 3);\n    $abfc71144f7bffd4$var$camera.far = 100;\n    $abfc71144f7bffd4$var$camera.updateProjectionMatrix();\n    // stats setup\n    $abfc71144f7bffd4$var$stats = new (0, $hBOJ2.default)();\n    document.body.appendChild($abfc71144f7bffd4$var$stats.dom);\n    // init matcaps\n    $abfc71144f7bffd4$var$matcaps[\"Clay\"] = new $ilwiq.TextureLoader().load(\"../textures/B67F6B_4B2E2A_6C3A34_F3DBC6-256px.png\");\n    $abfc71144f7bffd4$var$matcaps[\"Red Wax\"] = new $ilwiq.TextureLoader().load(\"../textures/763C39_431510_210504_55241C-256px.png\");\n    $abfc71144f7bffd4$var$matcaps[\"Shiny Green\"] = new $ilwiq.TextureLoader().load(\"../textures/3B6E10_E3F2C3_88AC2E_99CE51-256px.png\");\n    $abfc71144f7bffd4$var$matcaps[\"Normal\"] = new $ilwiq.TextureLoader().load(\"../textures/7877EE_D87FC5_75D9C7_1C78C0-256px.png\");\n    $abfc71144f7bffd4$var$material = new $ilwiq.MeshMatcapMaterial({\n        flatShading: $abfc71144f7bffd4$var$params.flatShading\n    });\n    for(const key in $abfc71144f7bffd4$var$matcaps)$abfc71144f7bffd4$var$matcaps[key].encoding = $ilwiq.sRGBEncoding;\n    // geometry setup\n    $abfc71144f7bffd4$var$reset();\n    const gui = new $jiuw3.GUI();\n    gui.add($abfc71144f7bffd4$var$params, \"matcap\", Object.keys($abfc71144f7bffd4$var$matcaps));\n    const sculptFolder = gui.addFolder(\"Sculpting\");\n    sculptFolder.add($abfc71144f7bffd4$var$params, \"brush\", [\n        \"normal\",\n        \"clay\",\n        \"flatten\"\n    ]);\n    sculptFolder.add($abfc71144f7bffd4$var$params, \"size\").min(0.025).max(0.25).step(0.005);\n    sculptFolder.add($abfc71144f7bffd4$var$params, \"intensity\").min(1).max(100).step(1);\n    sculptFolder.add($abfc71144f7bffd4$var$params, \"maxSteps\").min(1).max(25).step(1);\n    sculptFolder.add($abfc71144f7bffd4$var$params, \"symmetrical\");\n    sculptFolder.add($abfc71144f7bffd4$var$params, \"invert\");\n    sculptFolder.add($abfc71144f7bffd4$var$params, \"flatShading\").onChange((value)=>{\n        $abfc71144f7bffd4$var$targetMesh.material.flatShading = value;\n        $abfc71144f7bffd4$var$targetMesh.material.needsUpdate = true;\n    });\n    sculptFolder.open();\n    const helperFolder = gui.addFolder(\"BVH Helper\");\n    helperFolder.add($abfc71144f7bffd4$var$params, \"depth\").min(1).max(20).step(1).onChange((d)=>{\n        $abfc71144f7bffd4$var$bvhHelper.depth = parseFloat(d);\n        $abfc71144f7bffd4$var$bvhHelper.update();\n    });\n    helperFolder.add($abfc71144f7bffd4$var$params, \"displayHelper\").onChange((display)=>{\n        if (display) {\n            $abfc71144f7bffd4$var$scene.add($abfc71144f7bffd4$var$bvhHelper);\n            $abfc71144f7bffd4$var$bvhHelper.update();\n        } else $abfc71144f7bffd4$var$scene.remove($abfc71144f7bffd4$var$bvhHelper);\n    });\n    helperFolder.open();\n    gui.add({\n        reset: $abfc71144f7bffd4$var$reset\n    }, \"reset\");\n    gui.add({\n        rebuildBVH: ()=>{\n            // don't create a bounding box because it's used in BVH construction but\n            // will be out of date after moving vertices. See issue #222.\n            $abfc71144f7bffd4$var$targetMesh.geometry.computeBoundsTree({\n                setBoundingBox: false\n            });\n            $abfc71144f7bffd4$var$bvhHelper.update();\n        }\n    }, \"rebuildBVH\");\n    gui.open();\n    window.addEventListener(\"resize\", function() {\n        $abfc71144f7bffd4$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $abfc71144f7bffd4$var$camera.updateProjectionMatrix();\n        $abfc71144f7bffd4$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    }, false);\n    window.addEventListener(\"pointermove\", function(e) {\n        $abfc71144f7bffd4$var$mouse.x = e.clientX / window.innerWidth * 2 - 1;\n        $abfc71144f7bffd4$var$mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n        $abfc71144f7bffd4$var$brushActive = true;\n    });\n    window.addEventListener(\"pointerdown\", (e)=>{\n        $abfc71144f7bffd4$var$mouse.x = e.clientX / window.innerWidth * 2 - 1;\n        $abfc71144f7bffd4$var$mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n        $abfc71144f7bffd4$var$mouseState = Boolean(e.buttons & 3);\n        $abfc71144f7bffd4$var$rightClick = Boolean(e.buttons & 2);\n        $abfc71144f7bffd4$var$brushActive = true;\n        const raycaster = new $ilwiq.Raycaster();\n        raycaster.setFromCamera($abfc71144f7bffd4$var$mouse, $abfc71144f7bffd4$var$camera);\n        raycaster.firstHitOnly = true;\n        const res = raycaster.intersectObject($abfc71144f7bffd4$var$targetMesh);\n        $abfc71144f7bffd4$var$controls.enabled = res.length === 0;\n    }, true);\n    window.addEventListener(\"pointerup\", (e)=>{\n        $abfc71144f7bffd4$var$mouseState = Boolean(e.buttons & 3);\n        if (e.pointerType === \"touch\") $abfc71144f7bffd4$var$brushActive = false;\n    });\n    window.addEventListener(\"contextmenu\", function(e) {\n        e.preventDefault();\n    });\n    window.addEventListener(\"wheel\", function(e) {\n        let delta = e.deltaY;\n        if (e.deltaMode === 1) delta *= 40;\n        if (e.deltaMode === 2) delta *= 40;\n        $abfc71144f7bffd4$var$params.size += delta * 0.0001;\n        $abfc71144f7bffd4$var$params.size = Math.max(Math.min($abfc71144f7bffd4$var$params.size, 0.25), 0.025);\n        gui.controllersRecursive().forEach((c)=>c.updateDisplay());\n    });\n    $abfc71144f7bffd4$var$controls = new (0, $5Rd1x.OrbitControls)($abfc71144f7bffd4$var$camera, $abfc71144f7bffd4$var$renderer.domElement);\n    $abfc71144f7bffd4$var$controls.minDistance = 1.5;\n    $abfc71144f7bffd4$var$controls.addEventListener(\"start\", function() {\n        this.active = true;\n    });\n    $abfc71144f7bffd4$var$controls.addEventListener(\"end\", function() {\n        this.active = false;\n    });\n}\n// Run the perform the brush movement\nfunction $abfc71144f7bffd4$var$performStroke(point, brushObject, brushOnly = false, accumulatedFields = {}) {\n    const { accumulatedTriangles: accumulatedTriangles = new Set(), accumulatedIndices: accumulatedIndices = new Set(), accumulatedTraversedNodeIndices: accumulatedTraversedNodeIndices = new Set() } = accumulatedFields;\n    const inverseMatrix = new $ilwiq.Matrix4();\n    inverseMatrix.copy($abfc71144f7bffd4$var$targetMesh.matrixWorld).invert();\n    const sphere = new $ilwiq.Sphere();\n    sphere.center.copy(point).applyMatrix4(inverseMatrix);\n    sphere.radius = $abfc71144f7bffd4$var$params.size;\n    // Collect the intersected vertices\n    const indices = new Set();\n    const tempVec = new $ilwiq.Vector3();\n    const normal = new $ilwiq.Vector3();\n    const indexAttr = $abfc71144f7bffd4$var$targetMesh.geometry.index;\n    const posAttr = $abfc71144f7bffd4$var$targetMesh.geometry.attributes.position;\n    const normalAttr = $abfc71144f7bffd4$var$targetMesh.geometry.attributes.normal;\n    const triangles = new Set();\n    const bvh = $abfc71144f7bffd4$var$targetMesh.geometry.boundsTree;\n    bvh.shapecast({\n        intersectsBounds: (box, isLeaf, score, depth, nodeIndex)=>{\n            accumulatedTraversedNodeIndices.add(nodeIndex);\n            const intersects = sphere.intersectsBox(box);\n            const { min: min, max: max } = box;\n            if (intersects) {\n                for(let x = 0; x <= 1; x++){\n                    for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                        tempVec.set(x === 0 ? min.x : max.x, y === 0 ? min.y : max.y, z === 0 ? min.z : max.z);\n                        if (!sphere.containsPoint(tempVec)) return 0, $Mleu6.INTERSECTED;\n                    }\n                }\n                return 0, $Mleu6.CONTAINED;\n            }\n            return intersects ? (0, $Mleu6.INTERSECTED) : (0, $Mleu6.NOT_INTERSECTED);\n        },\n        intersectsTriangle: (tri, index, contained)=>{\n            const triIndex = index;\n            triangles.add(triIndex);\n            accumulatedTriangles.add(triIndex);\n            const i3 = 3 * index;\n            const a = i3 + 0;\n            const b = i3 + 1;\n            const c = i3 + 2;\n            const va = indexAttr.getX(a);\n            const vb = indexAttr.getX(b);\n            const vc = indexAttr.getX(c);\n            if (contained) {\n                indices.add(va);\n                indices.add(vb);\n                indices.add(vc);\n                accumulatedIndices.add(va);\n                accumulatedIndices.add(vb);\n                accumulatedIndices.add(vc);\n            } else {\n                if (sphere.containsPoint(tri.a)) {\n                    indices.add(va);\n                    accumulatedIndices.add(va);\n                }\n                if (sphere.containsPoint(tri.b)) {\n                    indices.add(vb);\n                    accumulatedIndices.add(vb);\n                }\n                if (sphere.containsPoint(tri.c)) {\n                    indices.add(vc);\n                    accumulatedIndices.add(vc);\n                }\n            }\n            return false;\n        }\n    });\n    // Compute the average normal at this point\n    const localPoint = new $ilwiq.Vector3();\n    localPoint.copy(point).applyMatrix4(inverseMatrix);\n    const planePoint = new $ilwiq.Vector3();\n    let totalPoints = 0;\n    indices.forEach((index)=>{\n        tempVec.fromBufferAttribute(normalAttr, index);\n        normal.add(tempVec);\n        // compute the average point for cases where we need to flatten\n        // to the plane.\n        if (!brushOnly) {\n            totalPoints++;\n            tempVec.fromBufferAttribute(posAttr, index);\n            planePoint.add(tempVec);\n        }\n    });\n    normal.normalize();\n    brushObject.quaternion.setFromUnitVectors($abfc71144f7bffd4$var$normalZ, normal);\n    if (totalPoints) planePoint.multiplyScalar(1 / totalPoints);\n    // Early out if we just want to adjust the brush\n    if (brushOnly) return;\n    // perform vertex adjustment\n    const targetHeight = $abfc71144f7bffd4$var$params.intensity * 0.0001;\n    const plane = new $ilwiq.Plane();\n    plane.setFromNormalAndCoplanarPoint(normal, planePoint);\n    indices.forEach((index)=>{\n        tempVec.fromBufferAttribute(posAttr, index);\n        // compute the offset intensity\n        const dist = tempVec.distanceTo(localPoint);\n        const negated = $abfc71144f7bffd4$var$params.invert !== $abfc71144f7bffd4$var$rightClick ? -1 : 1;\n        let intensity = 1.0 - dist / $abfc71144f7bffd4$var$params.size;\n        // offset the vertex\n        if ($abfc71144f7bffd4$var$params.brush === \"clay\") {\n            intensity = Math.pow(intensity, 3);\n            const planeDist = plane.distanceToPoint(tempVec);\n            const clampedIntensity = negated * Math.min(intensity * 4, 1.0);\n            tempVec.addScaledVector(normal, clampedIntensity * targetHeight - negated * planeDist * clampedIntensity * 0.3);\n        } else if ($abfc71144f7bffd4$var$params.brush === \"normal\") {\n            intensity = Math.pow(intensity, 2);\n            tempVec.addScaledVector(normal, negated * intensity * targetHeight);\n        } else if ($abfc71144f7bffd4$var$params.brush === \"flatten\") {\n            intensity = Math.pow(intensity, 2);\n            const planeDist = plane.distanceToPoint(tempVec);\n            tempVec.addScaledVector(normal, -planeDist * intensity * $abfc71144f7bffd4$var$params.intensity * 0.005);\n        }\n        posAttr.setXYZ(index, tempVec.x, tempVec.y, tempVec.z);\n        normalAttr.setXYZ(index, 0, 0, 0);\n    });\n    // If we found vertices\n    if (indices.size) posAttr.needsUpdate = true;\n}\nfunction $abfc71144f7bffd4$var$updateNormals(triangles, indices) {\n    const tempVec = new $ilwiq.Vector3();\n    const tempVec2 = new $ilwiq.Vector3();\n    const indexAttr = $abfc71144f7bffd4$var$targetMesh.geometry.index;\n    const posAttr = $abfc71144f7bffd4$var$targetMesh.geometry.attributes.position;\n    const normalAttr = $abfc71144f7bffd4$var$targetMesh.geometry.attributes.normal;\n    // accumulate the normals in place in the normal buffer\n    const triangle = new $ilwiq.Triangle();\n    triangles.forEach((tri)=>{\n        const tri3 = tri * 3;\n        const i0 = tri3 + 0;\n        const i1 = tri3 + 1;\n        const i2 = tri3 + 2;\n        const v0 = indexAttr.getX(i0);\n        const v1 = indexAttr.getX(i1);\n        const v2 = indexAttr.getX(i2);\n        triangle.a.fromBufferAttribute(posAttr, v0);\n        triangle.b.fromBufferAttribute(posAttr, v1);\n        triangle.c.fromBufferAttribute(posAttr, v2);\n        triangle.getNormal(tempVec2);\n        if (indices.has(v0)) {\n            tempVec.fromBufferAttribute(normalAttr, v0);\n            tempVec.add(tempVec2);\n            normalAttr.setXYZ(v0, tempVec.x, tempVec.y, tempVec.z);\n        }\n        if (indices.has(v1)) {\n            tempVec.fromBufferAttribute(normalAttr, v1);\n            tempVec.add(tempVec2);\n            normalAttr.setXYZ(v1, tempVec.x, tempVec.y, tempVec.z);\n        }\n        if (indices.has(v2)) {\n            tempVec.fromBufferAttribute(normalAttr, v2);\n            tempVec.add(tempVec2);\n            normalAttr.setXYZ(v2, tempVec.x, tempVec.y, tempVec.z);\n        }\n    });\n    // normalize the accumulated normals\n    indices.forEach((index)=>{\n        tempVec.fromBufferAttribute(normalAttr, index);\n        tempVec.normalize();\n        normalAttr.setXYZ(index, tempVec.x, tempVec.y, tempVec.z);\n    });\n    normalAttr.needsUpdate = true;\n}\nfunction $abfc71144f7bffd4$var$render() {\n    requestAnimationFrame($abfc71144f7bffd4$var$render);\n    $abfc71144f7bffd4$var$stats.begin();\n    $abfc71144f7bffd4$var$material.matcap = $abfc71144f7bffd4$var$matcaps[$abfc71144f7bffd4$var$params.matcap];\n    if ($abfc71144f7bffd4$var$controls.active || !$abfc71144f7bffd4$var$brushActive) {\n        // If the controls are being used then don't perform the strokes\n        $abfc71144f7bffd4$var$brush.visible = false;\n        $abfc71144f7bffd4$var$symmetryBrush.visible = false;\n        $abfc71144f7bffd4$var$lastCastPose.setScalar(Infinity);\n    } else {\n        const raycaster = new $ilwiq.Raycaster();\n        raycaster.setFromCamera($abfc71144f7bffd4$var$mouse, $abfc71144f7bffd4$var$camera);\n        raycaster.firstHitOnly = true;\n        const hit = raycaster.intersectObject($abfc71144f7bffd4$var$targetMesh, true)[0];\n        // if we hit the target mesh\n        if (hit) {\n            $abfc71144f7bffd4$var$brush.visible = true;\n            $abfc71144f7bffd4$var$brush.scale.set($abfc71144f7bffd4$var$params.size, $abfc71144f7bffd4$var$params.size, 0.1);\n            $abfc71144f7bffd4$var$brush.position.copy(hit.point);\n            $abfc71144f7bffd4$var$symmetryBrush.visible = $abfc71144f7bffd4$var$params.symmetrical;\n            $abfc71144f7bffd4$var$symmetryBrush.scale.set($abfc71144f7bffd4$var$params.size, $abfc71144f7bffd4$var$params.size, 0.1);\n            $abfc71144f7bffd4$var$symmetryBrush.position.copy(hit.point);\n            $abfc71144f7bffd4$var$symmetryBrush.position.x *= -1;\n            $abfc71144f7bffd4$var$controls.enabled = false;\n            // if the last cast pose was missed in the last frame then set it to\n            // the current point so we don't streak across the surface\n            if ($abfc71144f7bffd4$var$lastCastPose.x === Infinity) $abfc71144f7bffd4$var$lastCastPose.copy(hit.point);\n            // If the mouse isn't pressed don't perform the stroke\n            if (!($abfc71144f7bffd4$var$mouseState || $abfc71144f7bffd4$var$lastMouseState)) {\n                $abfc71144f7bffd4$var$performStroke(hit.point, $abfc71144f7bffd4$var$brush, true);\n                if ($abfc71144f7bffd4$var$params.symmetrical) {\n                    hit.point.x *= -1;\n                    $abfc71144f7bffd4$var$performStroke(hit.point, $abfc71144f7bffd4$var$symmetryBrush, true);\n                    hit.point.x *= -1;\n                }\n                $abfc71144f7bffd4$var$lastMouse.copy($abfc71144f7bffd4$var$mouse);\n                $abfc71144f7bffd4$var$lastCastPose.copy(hit.point);\n            } else {\n                // compute the distance the mouse moved and that the cast point moved\n                const mdx = ($abfc71144f7bffd4$var$mouse.x - $abfc71144f7bffd4$var$lastMouse.x) * window.innerWidth * window.devicePixelRatio;\n                const mdy = ($abfc71144f7bffd4$var$mouse.y - $abfc71144f7bffd4$var$lastMouse.y) * window.innerHeight * window.devicePixelRatio;\n                let mdist = Math.sqrt(mdx * mdx + mdy * mdy);\n                let castDist = hit.point.distanceTo($abfc71144f7bffd4$var$lastCastPose);\n                const step = $abfc71144f7bffd4$var$params.size * 0.15;\n                const percent = Math.max(step / castDist, 1 / $abfc71144f7bffd4$var$params.maxSteps);\n                const mstep = mdist * percent;\n                let stepCount = 0;\n                // perform multiple iterations toward the current mouse pose for a consistent stroke\n                // TODO: recast here so he cursor is on the surface of the model which requires faster\n                // refitting of the model\n                const changedTriangles = new Set();\n                const changedIndices = new Set();\n                const traversedNodeIndices = new Set();\n                const sets = {\n                    accumulatedTriangles: changedTriangles,\n                    accumulatedIndices: changedIndices,\n                    accumulatedTraversedNodeIndices: traversedNodeIndices\n                };\n                while(castDist > step && mdist > $abfc71144f7bffd4$var$params.size * 200 / hit.distance){\n                    $abfc71144f7bffd4$var$lastMouse.lerp($abfc71144f7bffd4$var$mouse, percent);\n                    $abfc71144f7bffd4$var$lastCastPose.lerp(hit.point, percent);\n                    castDist -= step;\n                    mdist -= mstep;\n                    $abfc71144f7bffd4$var$performStroke($abfc71144f7bffd4$var$lastCastPose, $abfc71144f7bffd4$var$brush, false, sets);\n                    if ($abfc71144f7bffd4$var$params.symmetrical) {\n                        $abfc71144f7bffd4$var$lastCastPose.x *= -1;\n                        $abfc71144f7bffd4$var$performStroke($abfc71144f7bffd4$var$lastCastPose, $abfc71144f7bffd4$var$symmetryBrush, false, sets);\n                        $abfc71144f7bffd4$var$lastCastPose.x *= -1;\n                    }\n                    stepCount++;\n                    if (stepCount > $abfc71144f7bffd4$var$params.maxSteps) break;\n                }\n                // refit the bounds and update the normals if we adjusted the mesh\n                if (stepCount > 0) {\n                    // refit bounds and normal updates could happen after every stroke\n                    // so it's up to date for the next one because both of those are used when updating\n                    // the model but it's faster to do them here.\n                    $abfc71144f7bffd4$var$updateNormals(changedTriangles, changedIndices);\n                    $abfc71144f7bffd4$var$targetMesh.geometry.boundsTree.refit(traversedNodeIndices);\n                    if ($abfc71144f7bffd4$var$bvhHelper.parent !== null) $abfc71144f7bffd4$var$bvhHelper.update();\n                } else {\n                    $abfc71144f7bffd4$var$performStroke(hit.point, $abfc71144f7bffd4$var$brush, true);\n                    if ($abfc71144f7bffd4$var$params.symmetrical) {\n                        hit.point.x *= -1;\n                        $abfc71144f7bffd4$var$performStroke(hit.point, $abfc71144f7bffd4$var$symmetryBrush, true);\n                        hit.point.x *= -1;\n                    }\n                }\n            }\n        } else {\n            // if we didn't hit\n            $abfc71144f7bffd4$var$controls.enabled = true;\n            $abfc71144f7bffd4$var$brush.visible = false;\n            $abfc71144f7bffd4$var$symmetryBrush.visible = false;\n            $abfc71144f7bffd4$var$lastMouse.copy($abfc71144f7bffd4$var$mouse);\n            $abfc71144f7bffd4$var$lastCastPose.setScalar(Infinity);\n        }\n    }\n    $abfc71144f7bffd4$var$lastMouseState = $abfc71144f7bffd4$var$mouseState;\n    $abfc71144f7bffd4$var$renderer.render($abfc71144f7bffd4$var$scene, $abfc71144f7bffd4$var$camera);\n    $abfc71144f7bffd4$var$stats.end();\n}\n\n\n//# sourceMappingURL=sculpt.929b05f9.js.map\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time > prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport { Stats as default };\n","import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.bvh || this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n","import Stats from 'stats.js/src/Stats';\nimport * as dat from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport {\n\tacceleratedRaycast,\n\tcomputeBoundsTree,\n\tdisposeBoundsTree,\n\tCONTAINED,\n\tINTERSECTED,\n\tNOT_INTERSECTED,\n\tMeshBVHHelper,\n} from '..';\n\nTHREE.Mesh.prototype.raycast = acceleratedRaycast;\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n\nlet stats;\nlet scene, camera, renderer, controls;\nlet targetMesh, brush, symmetryBrush, bvhHelper;\nlet normalZ = new THREE.Vector3( 0, 0, 1 );\nlet brushActive = false;\nlet mouse = new THREE.Vector2(), lastMouse = new THREE.Vector2();\nlet mouseState = false, lastMouseState = false;\nlet lastCastPose = new THREE.Vector3();\nlet material, rightClick = false;\n\nconst params = {\n\tmatcap: 'Clay',\n\n\tsize: 0.1,\n\tbrush: 'clay',\n\tintensity: 50,\n\tmaxSteps: 10,\n\tinvert: false,\n\tsymmetrical: true,\n\tflatShading: false,\n\n\tdepth: 10,\n\tdisplayHelper: false,\n};\n\nconst matcaps = {};\n\ninit();\nrender();\n\n// reset the sculpt mesh\nfunction reset() {\n\n\t// dispose of the mesh if it exists\n\tif ( targetMesh ) {\n\n\t\ttargetMesh.geometry.dispose();\n\t\ttargetMesh.material.dispose();\n\t\tscene.remove( targetMesh );\n\n\t}\n\n\t// merge the vertices because they're not already merged\n\tlet geometry = new THREE.IcosahedronBufferGeometry( 1, 100 );\n\tgeometry.deleteAttribute( 'uv' );\n\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\tgeometry.attributes.position.setUsage( THREE.DynamicDrawUsage );\n\tgeometry.attributes.normal.setUsage( THREE.DynamicDrawUsage );\n\tgeometry.computeBoundsTree( { setBoundingBox: false } );\n\n\t// disable frustum culling because the verts will be updated\n\ttargetMesh = new THREE.Mesh(\n\t\tgeometry,\n\t\tmaterial,\n\t);\n\ttargetMesh.frustumCulled = false;\n\tscene.add( targetMesh );\n\n\t// initialize bvh helper\n\tif ( ! bvhHelper ) {\n\n\t\tbvhHelper = new MeshBVHHelper( targetMesh, params.depth );\n\t\tif ( params.displayHelper ) {\n\n\t\t\tscene.add( bvhHelper );\n\n\t\t}\n\n\t}\n\n\tbvhHelper.mesh = targetMesh;\n\tbvhHelper.update();\n\n}\n\nfunction init() {\n\n\tconst bgColor = 0x060609;\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\trenderer.domElement.style.touchAction = 'none';\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\tscene.fog = new THREE.Fog( 0x263238 / 2, 20, 60 );\n\n\tconst light = new THREE.DirectionalLight( 0xffffff, 0.5 );\n\tlight.position.set( 1, 1, 1 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xffffff, 0.4 ) );\n\n\t// initialize brush cursor\n\tconst brushSegments = [ new THREE.Vector3(), new THREE.Vector3( 0, 0, 1 ) ];\n\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\tconst nexti = i + 1;\n\t\tconst x1 = Math.sin( 2 * Math.PI * i / 50 );\n\t\tconst y1 = Math.cos( 2 * Math.PI * i / 50 );\n\n\t\tconst x2 = Math.sin( 2 * Math.PI * nexti / 50 );\n\t\tconst y2 = Math.cos( 2 * Math.PI * nexti / 50 );\n\n\t\tbrushSegments.push(\n\t\t\tnew THREE.Vector3( x1, y1, 0 ),\n\t\t\tnew THREE.Vector3( x2, y2, 0 )\n\t\t);\n\n\t}\n\n\tbrush = new THREE.LineSegments();\n\tbrush.geometry.setFromPoints( brushSegments );\n\tbrush.material.color.set( 0xfb8c00 );\n\tscene.add( brush );\n\n\tsymmetryBrush = brush.clone();\n\tscene.add( symmetryBrush );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 0, 0, 3 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// init matcaps\n\tmatcaps[ 'Clay' ] = new THREE.TextureLoader().load( '../textures/B67F6B_4B2E2A_6C3A34_F3DBC6-256px.png' );\n\tmatcaps[ 'Red Wax' ] = new THREE.TextureLoader().load( '../textures/763C39_431510_210504_55241C-256px.png' );\n\tmatcaps[ 'Shiny Green' ] = new THREE.TextureLoader().load( '../textures/3B6E10_E3F2C3_88AC2E_99CE51-256px.png' );\n\tmatcaps[ 'Normal' ] = new THREE.TextureLoader().load( '../textures/7877EE_D87FC5_75D9C7_1C78C0-256px.png' );\n\tmaterial = new THREE.MeshMatcapMaterial( {\n\t\tflatShading: params.flatShading,\n\t} );\n\n\tfor ( const key in matcaps ) {\n\n\t\tmatcaps[ key ].encoding = THREE.sRGBEncoding;\n\n\t}\n\n\t// geometry setup\n\treset();\n\n\tconst gui = new dat.GUI();\n\tgui.add( params, 'matcap', Object.keys( matcaps ) );\n\n\tconst sculptFolder = gui.addFolder( 'Sculpting' );\n\tsculptFolder.add( params, 'brush', [ 'normal', 'clay', 'flatten' ] );\n\tsculptFolder.add( params, 'size' ).min( 0.025 ).max( 0.25 ).step( 0.005 );\n\tsculptFolder.add( params, 'intensity' ).min( 1 ).max( 100 ).step( 1 );\n\tsculptFolder.add( params, 'maxSteps' ).min( 1 ).max( 25 ).step( 1 );\n\tsculptFolder.add( params, 'symmetrical' );\n\tsculptFolder.add( params, 'invert' );\n\tsculptFolder.add( params, 'flatShading' ).onChange( value => {\n\n\t\ttargetMesh.material.flatShading = value;\n\t\ttargetMesh.material.needsUpdate = true;\n\n\t} );\n\tsculptFolder.open();\n\n\tconst helperFolder = gui.addFolder( 'BVH Helper' );\n\thelperFolder.add( params, 'depth' ).min( 1 ).max( 20 ).step( 1 ).onChange( d => {\n\n\t\tbvhHelper.depth = parseFloat( d );\n\t\tbvhHelper.update();\n\n\t} );\n\thelperFolder.add( params, 'displayHelper' ).onChange( display => {\n\n\t\tif ( display ) {\n\n\t\t\tscene.add( bvhHelper );\n\t\t\tbvhHelper.update();\n\n\t\t} else {\n\n\t\t\tscene.remove( bvhHelper );\n\n\t\t}\n\n\t} );\n\thelperFolder.open();\n\n\tgui.add( { reset }, 'reset' );\n\tgui.add( { rebuildBVH: () => {\n\n\t\t// don't create a bounding box because it's used in BVH construction but\n\t\t// will be out of date after moving vertices. See issue #222.\n\t\ttargetMesh.geometry.computeBoundsTree( { setBoundingBox: false } );\n\t\tbvhHelper.update();\n\n\t} }, 'rebuildBVH' );\n\tgui.open();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n\twindow.addEventListener( 'pointermove', function ( e ) {\n\n\t\tmouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tmouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\n\t\tbrushActive = true;\n\n\t} );\n\n\twindow.addEventListener( 'pointerdown', e => {\n\n\t\tmouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tmouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\n\t\tmouseState = Boolean( e.buttons & 3 );\n\t\trightClick = Boolean( e.buttons & 2 );\n\t\tbrushActive = true;\n\n\t\tconst raycaster = new THREE.Raycaster();\n\t\traycaster.setFromCamera( mouse, camera );\n\t\traycaster.firstHitOnly = true;\n\n\t\tconst res = raycaster.intersectObject( targetMesh );\n\t\tcontrols.enabled = res.length === 0;\n\n\t}, true );\n\n\twindow.addEventListener( 'pointerup', e => {\n\n\t\tmouseState = Boolean( e.buttons & 3 );\n\t\tif ( e.pointerType === 'touch' ) {\n\n\t\t\tbrushActive = false;\n\n\t\t}\n\n\t} );\n\n\twindow.addEventListener( 'contextmenu', function ( e ) {\n\n\t\te.preventDefault();\n\n\t} );\n\n\twindow.addEventListener( 'wheel', function ( e ) {\n\n\t\tlet delta = e.deltaY;\n\n\t\tif ( e.deltaMode === 1 ) {\n\n\t\t\tdelta *= 40;\n\n\t\t}\n\n\t\tif ( e.deltaMode === 2 ) {\n\n\t\t\tdelta *= 40;\n\n\t\t}\n\n\t\tparams.size += delta * 0.0001;\n\t\tparams.size = Math.max( Math.min( params.size, 0.25 ), 0.025 );\n\t\tgui.controllersRecursive().forEach( c => c.updateDisplay() );\n\n\t} );\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.minDistance = 1.5;\n\n\tcontrols.addEventListener( 'start', function () {\n\n\t\tthis.active = true;\n\n\t} );\n\n\tcontrols.addEventListener( 'end', function () {\n\n\t\tthis.active = false;\n\n\t} );\n\n}\n\n// Run the perform the brush movement\nfunction performStroke( point, brushObject, brushOnly = false, accumulatedFields = {} ) {\n\n\tconst {\n\t\taccumulatedTriangles = new Set(),\n\t\taccumulatedIndices = new Set(),\n\t\taccumulatedTraversedNodeIndices = new Set(),\n\t} = accumulatedFields;\n\n\tconst inverseMatrix = new THREE.Matrix4();\n\tinverseMatrix.copy( targetMesh.matrixWorld ).invert();\n\n\tconst sphere = new THREE.Sphere();\n\tsphere.center.copy( point ).applyMatrix4( inverseMatrix );\n\tsphere.radius = params.size;\n\n\t// Collect the intersected vertices\n\tconst indices = new Set();\n\tconst tempVec = new THREE.Vector3();\n\tconst normal = new THREE.Vector3();\n\tconst indexAttr = targetMesh.geometry.index;\n\tconst posAttr = targetMesh.geometry.attributes.position;\n\tconst normalAttr = targetMesh.geometry.attributes.normal;\n\tconst triangles = new Set();\n\tconst bvh = targetMesh.geometry.boundsTree;\n\tbvh.shapecast( {\n\n\t\tintersectsBounds: ( box, isLeaf, score, depth, nodeIndex ) => {\n\n\t\t\taccumulatedTraversedNodeIndices.add( nodeIndex );\n\n\t\t\tconst intersects = sphere.intersectsBox( box );\n\t\t\tconst { min, max } = box;\n\t\t\tif ( intersects ) {\n\n\t\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\t\ttempVec.set(\n\t\t\t\t\t\t\t\tx === 0 ? min.x : max.x,\n\t\t\t\t\t\t\t\ty === 0 ? min.y : max.y,\n\t\t\t\t\t\t\t\tz === 0 ? min.z : max.z\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif ( ! sphere.containsPoint( tempVec ) ) {\n\n\t\t\t\t\t\t\t\treturn INTERSECTED;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn CONTAINED;\n\n\t\t\t}\n\n\t\t\treturn intersects ? INTERSECTED : NOT_INTERSECTED;\n\n\t\t},\n\n\t\tintersectsTriangle: ( tri, index, contained ) => {\n\n\t\t\tconst triIndex = index;\n\t\t\ttriangles.add( triIndex );\n\t\t\taccumulatedTriangles.add( triIndex );\n\n\t\t\tconst i3 = 3 * index;\n\t\t\tconst a = i3 + 0;\n\t\t\tconst b = i3 + 1;\n\t\t\tconst c = i3 + 2;\n\t\t\tconst va = indexAttr.getX( a );\n\t\t\tconst vb = indexAttr.getX( b );\n\t\t\tconst vc = indexAttr.getX( c );\n\t\t\tif ( contained ) {\n\n\t\t\t\tindices.add( va );\n\t\t\t\tindices.add( vb );\n\t\t\t\tindices.add( vc );\n\n\t\t\t\taccumulatedIndices.add( va );\n\t\t\t\taccumulatedIndices.add( vb );\n\t\t\t\taccumulatedIndices.add( vc );\n\n\t\t\t} else {\n\n\t\t\t\tif ( sphere.containsPoint( tri.a ) ) {\n\n\t\t\t\t\tindices.add( va );\n\t\t\t\t\taccumulatedIndices.add( va );\n\n\t\t\t\t}\n\n\t\t\t\tif ( sphere.containsPoint( tri.b ) ) {\n\n\t\t\t\t\tindices.add( vb );\n\t\t\t\t\taccumulatedIndices.add( vb );\n\n\t\t\t\t}\n\n\t\t\t\tif ( sphere.containsPoint( tri.c ) ) {\n\n\t\t\t\t\tindices.add( vc );\n\t\t\t\t\taccumulatedIndices.add( vc );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\t// Compute the average normal at this point\n\tconst localPoint = new THREE.Vector3();\n\tlocalPoint.copy( point ).applyMatrix4( inverseMatrix );\n\n\tconst planePoint = new THREE.Vector3();\n\tlet totalPoints = 0;\n\tindices.forEach( index => {\n\n\t\ttempVec.fromBufferAttribute( normalAttr, index );\n\t\tnormal.add( tempVec );\n\n\t\t// compute the average point for cases where we need to flatten\n\t\t// to the plane.\n\t\tif ( ! brushOnly ) {\n\n\t\t\ttotalPoints ++;\n\t\t\ttempVec.fromBufferAttribute( posAttr, index );\n\t\t\tplanePoint.add( tempVec );\n\n\t\t}\n\n\t} );\n\tnormal.normalize();\n\tbrushObject.quaternion.setFromUnitVectors( normalZ, normal );\n\n\tif ( totalPoints ) {\n\n\t\tplanePoint.multiplyScalar( 1 / totalPoints );\n\n\t}\n\n\t// Early out if we just want to adjust the brush\n\tif ( brushOnly ) {\n\n\t\treturn;\n\n\t}\n\n\t// perform vertex adjustment\n\tconst targetHeight = params.intensity * 0.0001;\n\tconst plane = new THREE.Plane();\n\tplane.setFromNormalAndCoplanarPoint( normal, planePoint );\n\n\tindices.forEach( index => {\n\n\t\ttempVec.fromBufferAttribute( posAttr, index );\n\n\t\t// compute the offset intensity\n\t\tconst dist = tempVec.distanceTo( localPoint );\n\t\tconst negated = params.invert !== rightClick ? - 1 : 1;\n\t\tlet intensity = 1.0 - ( dist / params.size );\n\n\t\t// offset the vertex\n\t\tif ( params.brush === 'clay' ) {\n\n\t\t\tintensity = Math.pow( intensity, 3 );\n\t\t\tconst planeDist = plane.distanceToPoint( tempVec );\n\t\t\tconst clampedIntensity = negated * Math.min( intensity * 4, 1.0 );\n\t\t\ttempVec.addScaledVector( normal, clampedIntensity * targetHeight - negated * planeDist * clampedIntensity * 0.3 );\n\n\t\t} else if ( params.brush === 'normal' ) {\n\n\t\t\tintensity = Math.pow( intensity, 2 );\n\t\t\ttempVec.addScaledVector( normal, negated * intensity * targetHeight );\n\n\t\t} else if ( params.brush === 'flatten' ) {\n\n\t\t\tintensity = Math.pow( intensity, 2 );\n\n\t\t\tconst planeDist = plane.distanceToPoint( tempVec );\n\t\t\ttempVec.addScaledVector( normal, - planeDist * intensity * params.intensity * 0.01 * 0.5 );\n\n\t\t}\n\n\t\tposAttr.setXYZ( index, tempVec.x, tempVec.y, tempVec.z );\n\t\tnormalAttr.setXYZ( index, 0, 0, 0 );\n\n\t} );\n\n\t// If we found vertices\n\tif ( indices.size ) {\n\n\t\tposAttr.needsUpdate = true;\n\n\t}\n\n}\n\nfunction updateNormals( triangles, indices ) {\n\n\tconst tempVec = new THREE.Vector3();\n\tconst tempVec2 = new THREE.Vector3();\n\tconst indexAttr = targetMesh.geometry.index;\n\tconst posAttr = targetMesh.geometry.attributes.position;\n\tconst normalAttr = targetMesh.geometry.attributes.normal;\n\n\t// accumulate the normals in place in the normal buffer\n\tconst triangle = new THREE.Triangle();\n\ttriangles.forEach( tri => {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst i0 = tri3 + 0;\n\t\tconst i1 = tri3 + 1;\n\t\tconst i2 = tri3 + 2;\n\n\t\tconst v0 = indexAttr.getX( i0 );\n\t\tconst v1 = indexAttr.getX( i1 );\n\t\tconst v2 = indexAttr.getX( i2 );\n\n\t\ttriangle.a.fromBufferAttribute( posAttr, v0 );\n\t\ttriangle.b.fromBufferAttribute( posAttr, v1 );\n\t\ttriangle.c.fromBufferAttribute( posAttr, v2 );\n\t\ttriangle.getNormal( tempVec2 );\n\n\t\tif ( indices.has( v0 ) ) {\n\n\t\t\ttempVec.fromBufferAttribute( normalAttr, v0 );\n\t\t\ttempVec.add( tempVec2 );\n\t\t\tnormalAttr.setXYZ( v0, tempVec.x, tempVec.y, tempVec.z );\n\n\t\t}\n\n\t\tif ( indices.has( v1 ) ) {\n\n\t\t\ttempVec.fromBufferAttribute( normalAttr, v1 );\n\t\t\ttempVec.add( tempVec2 );\n\t\t\tnormalAttr.setXYZ( v1, tempVec.x, tempVec.y, tempVec.z );\n\n\t\t}\n\n\t\tif ( indices.has( v2 ) ) {\n\n\t\t\ttempVec.fromBufferAttribute( normalAttr, v2 );\n\t\t\ttempVec.add( tempVec2 );\n\t\t\tnormalAttr.setXYZ( v2, tempVec.x, tempVec.y, tempVec.z );\n\n\t\t}\n\n\t} );\n\n\t// normalize the accumulated normals\n\tindices.forEach( index => {\n\n\t\ttempVec.fromBufferAttribute( normalAttr, index );\n\t\ttempVec.normalize();\n\t\tnormalAttr.setXYZ( index, tempVec.x, tempVec.y, tempVec.z );\n\n\t} );\n\n\tnormalAttr.needsUpdate = true;\n\n}\n\nfunction render() {\n\n\trequestAnimationFrame( render );\n\n\tstats.begin();\n\n\tmaterial.matcap = matcaps[ params.matcap ];\n\n\tif ( controls.active || ! brushActive ) {\n\n\t\t// If the controls are being used then don't perform the strokes\n\t\tbrush.visible = false;\n\t\tsymmetryBrush.visible = false;\n\t\tlastCastPose.setScalar( Infinity );\n\n\t} else {\n\n\t\tconst raycaster = new THREE.Raycaster();\n\t\traycaster.setFromCamera( mouse, camera );\n\t\traycaster.firstHitOnly = true;\n\n\t\tconst hit = raycaster.intersectObject( targetMesh, true )[ 0 ];\n\t\t// if we hit the target mesh\n\t\tif ( hit ) {\n\n\t\t\tbrush.visible = true;\n\t\t\tbrush.scale.set( params.size, params.size, 0.1 );\n\t\t\tbrush.position.copy( hit.point );\n\n\t\t\tsymmetryBrush.visible = params.symmetrical;\n\t\t\tsymmetryBrush.scale.set( params.size, params.size, 0.1 );\n\t\t\tsymmetryBrush.position.copy( hit.point );\n\t\t\tsymmetryBrush.position.x *= - 1;\n\n\t\t\tcontrols.enabled = false;\n\n\t\t\t// if the last cast pose was missed in the last frame then set it to\n\t\t\t// the current point so we don't streak across the surface\n\t\t\tif ( lastCastPose.x === Infinity ) {\n\n\t\t\t\tlastCastPose.copy( hit.point );\n\n\t\t\t}\n\n\t\t\t// If the mouse isn't pressed don't perform the stroke\n\t\t\tif ( ! ( mouseState || lastMouseState ) ) {\n\n\t\t\t\tperformStroke( hit.point, brush, true );\n\t\t\t\tif ( params.symmetrical ) {\n\n\t\t\t\t\thit.point.x *= - 1;\n\t\t\t\t\tperformStroke( hit.point, symmetryBrush, true );\n\t\t\t\t\thit.point.x *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tlastMouse.copy( mouse );\n\t\t\t\tlastCastPose.copy( hit.point );\n\n\t\t\t} else {\n\n\t\t\t\t// compute the distance the mouse moved and that the cast point moved\n\t\t\t\tconst mdx = ( mouse.x - lastMouse.x ) * window.innerWidth * window.devicePixelRatio;\n\t\t\t\tconst mdy = ( mouse.y - lastMouse.y ) * window.innerHeight * window.devicePixelRatio;\n\t\t\t\tlet mdist = Math.sqrt( mdx * mdx + mdy * mdy );\n\t\t\t\tlet castDist = hit.point.distanceTo( lastCastPose );\n\n\t\t\t\tconst step = params.size * 0.15;\n\t\t\t\tconst percent = Math.max( step / castDist, 1 / params.maxSteps );\n\t\t\t\tconst mstep = mdist * percent;\n\t\t\t\tlet stepCount = 0;\n\n\t\t\t\t// perform multiple iterations toward the current mouse pose for a consistent stroke\n\t\t\t\t// TODO: recast here so he cursor is on the surface of the model which requires faster\n\t\t\t\t// refitting of the model\n\t\t\t\tconst changedTriangles = new Set();\n\t\t\t\tconst changedIndices = new Set();\n\t\t\t\tconst traversedNodeIndices = new Set();\n\t\t\t\tconst sets = {\n\n\t\t\t\t\taccumulatedTriangles: changedTriangles,\n\t\t\t\t\taccumulatedIndices: changedIndices,\n\t\t\t\t\taccumulatedTraversedNodeIndices: traversedNodeIndices,\n\n\t\t\t\t};\n\t\t\t\twhile ( castDist > step && mdist > params.size * 200 / hit.distance ) {\n\n\t\t\t\t\tlastMouse.lerp( mouse, percent );\n\t\t\t\t\tlastCastPose.lerp( hit.point, percent );\n\t\t\t\t\tcastDist -= step;\n\t\t\t\t\tmdist -= mstep;\n\n\t\t\t\t\tperformStroke( lastCastPose, brush, false, sets );\n\n\t\t\t\t\tif ( params.symmetrical ) {\n\n\t\t\t\t\t\tlastCastPose.x *= - 1;\n\t\t\t\t\t\tperformStroke( lastCastPose, symmetryBrush, false, sets );\n\t\t\t\t\t\tlastCastPose.x *= - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstepCount ++;\n\t\t\t\t\tif ( stepCount > params.maxSteps ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// refit the bounds and update the normals if we adjusted the mesh\n\t\t\t\tif ( stepCount > 0 ) {\n\n\t\t\t\t\t// refit bounds and normal updates could happen after every stroke\n\t\t\t\t\t// so it's up to date for the next one because both of those are used when updating\n\t\t\t\t\t// the model but it's faster to do them here.\n\t\t\t\t\tupdateNormals( changedTriangles, changedIndices );\n\t\t\t\t\ttargetMesh.geometry.boundsTree.refit( traversedNodeIndices );\n\n\t\t\t\t\tif ( bvhHelper.parent !== null ) {\n\n\t\t\t\t\t\tbvhHelper.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tperformStroke( hit.point, brush, true );\n\t\t\t\t\tif ( params.symmetrical ) {\n\n\t\t\t\t\t\thit.point.x *= - 1;\n\t\t\t\t\t\tperformStroke( hit.point, symmetryBrush, true );\n\t\t\t\t\t\thit.point.x *= - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if we didn't hit\n\t\t\tcontrols.enabled = true;\n\t\t\tbrush.visible = false;\n\t\t\tsymmetryBrush.visible = false;\n\t\t\tlastMouse.copy( mouse );\n\t\t\tlastCastPose.setScalar( Infinity );\n\n\t\t}\n\n\t}\n\n\tlastMouseState = mouseState;\n\n\trenderer.render( scene, camera );\n\tstats.end();\n\n}\n"],"names":["$abfc71144f7bffd4$var$stats","$abfc71144f7bffd4$var$scene","$abfc71144f7bffd4$var$camera","$abfc71144f7bffd4$var$renderer","$abfc71144f7bffd4$var$controls","$abfc71144f7bffd4$var$targetMesh","$abfc71144f7bffd4$var$brush","$abfc71144f7bffd4$var$symmetryBrush","$abfc71144f7bffd4$var$bvhHelper","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$cd1d3d651be7f2fc$export$2e2bcd8739ae039","mode","container","document","createElement","addPanel","panel","appendChild","dom","showPanel","i","children","length","style","display","cssText","addEventListener","event","preventDefault","beginTime","performance","Date","now","prevTime","frames","fpsPanel","Panel","msPanel","self","memory","memPanel","REVISION","begin","end","time","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","name","fg","bg","min","Infinity","max","round","Math","PR","window","devicePixelRatio","WIDTH","HEIGHT","TEXT_X","TEXT_Y","GRAPH_X","GRAPH_Y","GRAPH_WIDTH","GRAPH_HEIGHT","canvas","width","height","context","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","value","maxValue","drawImage","$31ccd9a92979d6bb$export$a0dc2935489c814a","$31ccd9a92979d6bb$export$749bba8a65fa6d70","$31ccd9a92979d6bb$export$e0a981a7a32ddba4","$ilwiq","$b4YKL","$ff8ed","$31ccd9a92979d6bb$var$ray","Ray","$31ccd9a92979d6bb$var$tmpInverseMatrix","Matrix4","$31ccd9a92979d6bb$var$origMeshRaycastFunc","Mesh","prototype","raycast","raycaster","intersects","geometry","boundsTree","undefined","material","copy","matrixWorld","invert","ray","applyMatrix4","bvh","firstHitOnly","hit","convertRaycastIntersect","raycastFirst","push","hits","l","options","MeshBVH","$810f31c6ff4f494e$export$adb106eed99e8cd8","object","point","distance","distanceTo","origin","near","far","$3c85f35a8c29fa9b$export$e57d74bcb7e3bec5","$aw71y","$3c85f35a8c29fa9b$var$boundingBox","Box3","$3c85f35a8c29fa9b$var$MeshBVHRootHelper","Object3D","isMesh","displayEdges","isLineSegments","isLine","constructor","depth","group","BufferGeometry","displayParents","_group","dispose","visible","indexArray","indices","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","arrayToBox","x","xVal","y","yVal","z","zVal","Uint8Array","Uint32Array","Uint16Array","indexLength","posOffset","indexOffset","j","setIndex","BufferAttribute","setAttribute","Group","color","edgeMaterial","opacity","meshMaterial","mesh","_roots","LineBasicMaterial","transparent","depthWrite","MeshBasicMaterial","totalRoots","root","pop","remove","add","updateMatrixWorld","args","parent","updateWorldMatrix","matrix","multiply","decompose","position","quaternion","scale","source","clone","$hBOJ2","$jiuw3","$5Rd1x","$7ePFa","$4h5hN","$Mleu6","$5ca9G","acceleratedRaycast","computeBoundsTree","disposeBoundsTree","$abfc71144f7bffd4$var$normalZ","Vector3","$abfc71144f7bffd4$var$brushActive","$abfc71144f7bffd4$var$mouse","Vector2","$abfc71144f7bffd4$var$lastMouse","$abfc71144f7bffd4$var$mouseState","$abfc71144f7bffd4$var$lastMouseState","$abfc71144f7bffd4$var$lastCastPose","$abfc71144f7bffd4$var$material","$abfc71144f7bffd4$var$rightClick","$abfc71144f7bffd4$var$params","matcap","size","brush","intensity","maxSteps","symmetrical","flatShading","displayHelper","$abfc71144f7bffd4$var$matcaps","$abfc71144f7bffd4$var$reset","IcosahedronBufferGeometry","deleteAttribute","mergeVertices","attributes","setUsage","DynamicDrawUsage","normal","setBoundingBox","frustumCulled","MeshBVHHelper","$abfc71144f7bffd4$var$performStroke","brushObject","brushOnly","accumulatedFields","accumulatedTriangles","Set","accumulatedIndices","accumulatedTraversedNodeIndices","inverseMatrix","sphere","Sphere","center","radius","tempVec","indexAttr","index","posAttr","normalAttr","triangles","shapecast","intersectsBounds","box","score","nodeIndex","intersectsBox","containsPoint","INTERSECTED","CONTAINED","NOT_INTERSECTED","intersectsTriangle","tri","contained","i3","va","getX","vb","vc","a","b","c","localPoint","planePoint","totalPoints","forEach","fromBufferAttribute","normalize","setFromUnitVectors","multiplyScalar","targetHeight","plane","Plane","setFromNormalAndCoplanarPoint","dist","negated","pow","planeDist","distanceToPoint","clampedIntensity","addScaledVector","setXYZ","needsUpdate","$abfc71144f7bffd4$var$init","WebGLRenderer","antialias","setPixelRatio","setSize","innerWidth","innerHeight","setClearColor","outputEncoding","sRGBEncoding","body","touchAction","Scene","fog","Fog","light","DirectionalLight","AmbientLight","brushSegments","nexti","x1","sin","PI","y1","cos","x2","y2","key","LineSegments","setFromPoints","PerspectiveCamera","updateProjectionMatrix","default","TextureLoader","load","MeshMatcapMaterial","encoding","gui","GUI","keys","sculptFolder","addFolder","step","onChange","open","helperFolder","d","parseFloat","reset","rebuildBVH","aspect","clientX","clientY","Boolean","buttons","Raycaster","setFromCamera","res","intersectObject","enabled","pointerType","delta","deltaY","deltaMode","controllersRecursive","updateDisplay","OrbitControls","minDistance","active","$abfc71144f7bffd4$var$render","requestAnimationFrame","setScalar","mdx","mdy","mdist","sqrt","castDist","percent","mstep","stepCount","changedTriangles","changedIndices","traversedNodeIndices","sets","lerp","$abfc71144f7bffd4$var$updateNormals","tempVec2","triangle","Triangle","tri3","v0","v1","v2","getNormal","has","refit","render"],"version":3,"file":"sculpt.929b05f9.js.map"}