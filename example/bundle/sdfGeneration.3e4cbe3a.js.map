{"mappings":"IS0BI,EAAU,EAAQ,EAAO,EAAK,EAAO,EACrC,EAAiB,EAAK,EAAU,EAAQ,EACxC,EAAiB,EAAW,EAC5B,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,GR3BJ,IAgBA,EAhBI,EAAU,IAAI,IAgBlB,EAfA,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,C,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,G,I,E,E,SC+BA,IAAM,EAAU,IAAI,EAAA,kBAAiB,CAAG,GAAK,EAAG,EAAG,GAAK,EAAG,GAIrD,EAAY,IAAI,EAAA,cAAa,CACnC,EAAU,YAAY,CAAE,WAAY,IAAI,EAAA,sBAAqB,CAAG,CAAE,GAAK,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,EAAG,CAAE,IACvG,EAAU,YAAY,CAAE,KAAM,IAAI,EAAA,sBAAqB,CAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAE,GAEhF,OAAM,EAEL,YAAa,CAAQ,CAAG,CAEvB,IAAI,CAAC,KAAK,CAAG,IAAI,EAAA,IAAG,CAAG,EAAW,EAEnC,CAEA,SAAU,CAET,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,EAE5B,CAEA,OAAQ,CAAQ,CAAG,CAElB,EAAS,MAAM,CAAE,IAAI,CAAC,KAAK,CAAE,EAE9B,CAEA,IAAI,UAAW,CAEd,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,AAE3B,CAE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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/three/examples/jsm/postprocessing/Pass.js","node_modules/stats.js/build/stats.min.js","src/workers/GenerateMeshBVHWorker.js","src/workers/utils/WorkerBase.js","node_modules/@parcel/runtime-js/lib/runtime-b9d8bae84a2a3c49.js","node_modules/@parcel/runtime-js/lib/helpers/get-worker-url.js","node_modules/@parcel/runtime-js/lib/runtime-59639f53a1b1f397.js","example/sdfGeneration.js","example/utils/GenerateSDFMaterial.js","example/utils/RenderSDFLayerMaterial.js","example/utils/RayMarchSDFMaterial.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = new Map();\nfunction $18c11f3350a906ea$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$18c11f3350a906ea$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping.get(id);\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nparcelRegister(\"RPVlj\", function(module, exports) {\n\n$parcel$export(module.exports, \"FullScreenQuad\", () => $0a1d3a5a6a49de03$export$3983474c8e6e978b);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $0a1d3a5a6a49de03$export$802bc10488da99c7 {\n    constructor(){\n        this.isPass = true;\n        // if set to true, the pass is processed by the composer\n        this.enabled = true;\n        // if set to true, the pass indicates to swap read and write buffer after rendering\n        this.needsSwap = true;\n        // if set to true, the pass clears its buffer before rendering\n        this.clear = false;\n        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n        this.renderToScreen = false;\n    }\n    setSize() {}\n    render() {\n        console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n    }\n    dispose() {}\n}\n// Helper for passes that need to fill the viewport with a single quad.\nconst $0a1d3a5a6a49de03$var$_camera = new (0, $ilwiq.OrthographicCamera)(-1, 1, 1, -1, 0, 1);\n// https://github.com/mrdoob/three.js/pull/21358\nconst $0a1d3a5a6a49de03$var$_geometry = new (0, $ilwiq.BufferGeometry)();\n$0a1d3a5a6a49de03$var$_geometry.setAttribute(\"position\", new (0, $ilwiq.Float32BufferAttribute)([\n    -1,\n    3,\n    0,\n    -1,\n    -1,\n    0,\n    3,\n    -1,\n    0\n], 3));\n$0a1d3a5a6a49de03$var$_geometry.setAttribute(\"uv\", new (0, $ilwiq.Float32BufferAttribute)([\n    0,\n    2,\n    0,\n    0,\n    2,\n    0\n], 2));\nclass $0a1d3a5a6a49de03$export$3983474c8e6e978b {\n    constructor(material){\n        this._mesh = new (0, $ilwiq.Mesh)($0a1d3a5a6a49de03$var$_geometry, material);\n    }\n    dispose() {\n        this._mesh.geometry.dispose();\n    }\n    render(renderer) {\n        renderer.render(this._mesh, $0a1d3a5a6a49de03$var$_camera);\n    }\n    get material() {\n        return this._mesh.material;\n    }\n    set material(value) {\n        this._mesh.material = value;\n    }\n}\n\n});\n\nparcelRegister(\"c8CJQ\", function(module, exports) {\n// stats.js - http://github.com/mrdoob/stats.js\n(function(f, e) {\n    module.exports = e();\n})(module.exports, function() {\n    var f = function() {\n        function e(a) {\n            c.appendChild(a.dom);\n            return a;\n        }\n        function u(a) {\n            for(var d = 0; d < c.children.length; d++)c.children[d].style.display = d === a ? \"block\" : \"none\";\n            l = a;\n        }\n        var l = 0, c = document.createElement(\"div\");\n        c.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n        c.addEventListener(\"click\", function(a) {\n            a.preventDefault();\n            u(++l % c.children.length);\n        }, !1);\n        var k = (performance || Date).now(), g = k, a = 0, r = e(new f.Panel(\"FPS\", \"#0ff\", \"#002\")), h = e(new f.Panel(\"MS\", \"#0f0\", \"#020\"));\n        if (self.performance && self.performance.memory) var t = e(new f.Panel(\"MB\", \"#f08\", \"#201\"));\n        u(0);\n        return {\n            REVISION: 16,\n            dom: c,\n            addPanel: e,\n            showPanel: u,\n            begin: function() {\n                k = (performance || Date).now();\n            },\n            end: function() {\n                a++;\n                var c = (performance || Date).now();\n                h.update(c - k, 200);\n                if (c > g + 1E3 && (r.update(1E3 * a / (c - g), 100), g = c, a = 0, t)) {\n                    var d = performance.memory;\n                    t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);\n                }\n                return c;\n            },\n            update: function() {\n                k = this.end();\n            },\n            domElement: c,\n            setMode: u\n        };\n    };\n    f.Panel = function(e, f, l) {\n        var c = Infinity, k = 0, g = Math.round, a = g(window.devicePixelRatio || 1), r = 80 * a, h = 48 * a, t = 3 * a, v = 2 * a, d = 3 * a, m = 15 * a, n = 74 * a, p = 30 * a, q = document.createElement(\"canvas\");\n        q.width = r;\n        q.height = h;\n        q.style.cssText = \"width:80px;height:48px\";\n        var b = q.getContext(\"2d\");\n        b.font = \"bold \" + 9 * a + \"px Helvetica,Arial,sans-serif\";\n        b.textBaseline = \"top\";\n        b.fillStyle = l;\n        b.fillRect(0, 0, r, h);\n        b.fillStyle = f;\n        b.fillText(e, t, v);\n        b.fillRect(d, m, n, p);\n        b.fillStyle = l;\n        b.globalAlpha = .9;\n        b.fillRect(d, m, n, p);\n        return {\n            dom: q,\n            update: function(h, w) {\n                c = Math.min(c, h);\n                k = Math.max(k, h);\n                b.fillStyle = l;\n                b.globalAlpha = 1;\n                b.fillRect(0, 0, r, m);\n                b.fillStyle = f;\n                b.fillText(g(h) + \" \" + e + \" (\" + g(c) + \"-\" + g(k) + \")\", t, v);\n                b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);\n                b.fillRect(d + n - a, m, a, p);\n                b.fillStyle = l;\n                b.globalAlpha = .9;\n                b.fillRect(d + n - a, m, a, g((1 - h / w) * p));\n            }\n        };\n    };\n    return f;\n});\n\n});\n\nparcelRegister(\"8todg\", function(module, exports) {\n\n$parcel$export(module.exports, \"GenerateMeshBVHWorker\", () => $62b3d05905f83386$export$426cc6213ad628cf);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\n\nvar $77YCt = parcelRequire(\"77YCt\");\n\nclass $62b3d05905f83386$export$426cc6213ad628cf extends (0, $77YCt.WorkerBase) {\n    constructor(){\n        const worker = new Worker((parcelRequire(\"bSef7\")));\n        super(worker);\n        this.name = \"GenerateMeshBVHWorker\";\n    }\n    runTask(worker, geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            if (geometry.getAttribute(\"position\").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.\");\n            worker.onerror = (e)=>{\n                reject(new Error(`GenerateMeshBVHWorker: ${e.message}`));\n            };\n            worker.onmessage = (e)=>{\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.serialized) {\n                    const { serialized: serialized, position: position } = data;\n                    const bvh = (0, $ff8ed.MeshBVH).deserialize(serialized, geometry, {\n                        setIndex: false\n                    });\n                    const boundsOptions = Object.assign({\n                        setBoundingBox: true\n                    }, options);\n                    // we need to replace the arrays because they're neutered entirely by the\n                    // webworker transfer.\n                    geometry.attributes.position.array = position;\n                    if (serialized.index) {\n                        if (geometry.index) geometry.index.array = serialized.index;\n                        else {\n                            const newIndex = new (0, $ilwiq.BufferAttribute)(serialized.index, 1, false);\n                            geometry.setIndex(newIndex);\n                        }\n                    }\n                    if (boundsOptions.setBoundingBox) geometry.boundingBox = bvh.getBoundingBox(new (0, $ilwiq.Box3)());\n                    if (options.onProgress) options.onProgress(data.progress);\n                    resolve(bvh);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array : null;\n            const position = geometry.attributes.position.array;\n            const transferable = [\n                position\n            ];\n            if (index) transferable.push(index);\n            worker.postMessage({\n                index: index,\n                position: position,\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress),\n                    groups: [\n                        ...geometry.groups\n                    ]\n                }\n            }, transferable.map((arr)=>arr.buffer).filter((v)=>typeof SharedArrayBuffer === \"undefined\" || !(v instanceof SharedArrayBuffer)));\n        });\n    }\n}\n\n});\nparcelRegister(\"77YCt\", function(module, exports) {\n\n$parcel$export(module.exports, \"WorkerBase\", () => $5308359e4b33977a$export$8dbf7c43841b75b7);\nclass $5308359e4b33977a$export$8dbf7c43841b75b7 {\n    constructor(worker){\n        this.name = \"WorkerBase\";\n        this.running = false;\n        this.worker = worker;\n        this.worker.onerror = (e)=>{\n            if (e.message) throw new Error(`${this.name}: Could not create Web Worker with error \"${e.message}\"`);\n            else throw new Error(`${this.name}: Could not create Web Worker.`);\n        };\n    }\n    runTask() {}\n    generate(...args) {\n        if (this.running) throw new Error(\"GenerateMeshBVHWorker: Already running job.\");\n        if (this.worker === null) throw new Error(\"GenerateMeshBVHWorker: Worker has been disposed.\");\n        this.running = true;\n        const promise = this.runTask(this.worker, ...args);\n        promise.finally(()=>{\n            this.running = false;\n        });\n        return promise;\n    }\n    dispose() {\n        this.worker.terminate();\n        this.worker = null;\n    }\n}\n\n});\n\nparcelRegister(\"bSef7\", function(module, exports) {\n\nvar $7ryUf = parcelRequire(\"7ryUf\");\nlet $8a4fc930af686efe$var$url = new URL(\"generateMeshBVH.worker.17f4c1c5.js\", import.meta.url);\nmodule.exports = $7ryUf($8a4fc930af686efe$var$url.toString(), $8a4fc930af686efe$var$url.origin, true);\n\n});\nparcelRegister(\"7ryUf\", function(module, exports) {\n\"use strict\";\nmodule.exports = function(workerUrl, origin, isESM) {\n    if (origin === self.location.origin) // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n    else {\n        // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n        var source = isESM ? \"import \" + JSON.stringify(workerUrl) + \";\" : \"importScripts(\" + JSON.stringify(workerUrl) + \");\";\n        return URL.createObjectURL(new Blob([\n            source\n        ], {\n            type: \"application/javascript\"\n        }));\n    }\n};\n\n});\n\n\n\nvar $5f5fbb5fb8d4fd93$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(new URL(\"\", import.meta.url).toString(), JSON.parse('[\"1WzX2\",\"sdfGeneration.3e4cbe3a.js\",\"6J6WW\",\"generateMeshBVH.worker.17f4c1c5.js\",\"acVmZ\",\"generateMeshBVH.worker.aad48e6e.js\",\"gr8Yf\",\"asyncGenerate.22609466.js\",\"j19h5\",\"asyncGenerate.e8b1599c.js\",\"30Pwg\",\"asyncGenerate.77ce35af.js\",\"2tzBs\",\"characterMovement.89c1b67b.js\",\"6UuCC\",\"characterMovement.5fc59dbe.js\",\"6mMEU\",\"characterMovement.fc8349f1.js\",\"3lH4c\",\"characterMovement.933f8c48.js\",\"i0zVc\",\"clippedEdges.dcf40b33.js\",\"gVxlZ\",\"diamond.5b837c44.js\"]'));\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $c8CJQ = parcelRequire(\"c8CJQ\");\n\nvar $8todg = parcelRequire(\"8todg\");\n\nvar $jAT47 = parcelRequire(\"jAT47\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $gcCUH = parcelRequire(\"gcCUH\");\nvar $boAbX = parcelRequire(\"boAbX\");\nclass $445e06dac1d69dea$export$89d8017d8280911a extends (0, $ilwiq.ShaderMaterial) {\n    constructor(params){\n        super({\n            uniforms: {\n                matrix: {\n                    value: new (0, $ilwiq.Matrix4)()\n                },\n                zValue: {\n                    value: 0\n                },\n                bvh: {\n                    value: new (0, $boAbX.MeshBVHUniformStruct)()\n                }\n            },\n            vertexShader: /* glsl */ `\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\n\t\t\t\t${(0, $gcCUH).common_functions}\n\t\t\t\t${(0, $gcCUH).bvh_struct_definitions}\n\t\t\t\t${(0, $gcCUH).bvh_ray_functions}\n\t\t\t\t${(0, $gcCUH).bvh_distance_functions}\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float zValue;\n\t\t\t\tuniform mat4 matrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// compute the point in space to check\n\t\t\t\t\tvec3 point = vec3( vUv, zValue );\n\t\t\t\t\tpoint -= vec3( 0.5 );\n\t\t\t\t\tpoint = ( matrix * vec4( point, 1.0 ) ).xyz;\n\n\t\t\t\t\t// retrieve the distance and other values\n\t\t\t\t\tuvec4 faceIndices;\n\t\t\t\t\tvec3 faceNormal;\n\t\t\t\t\tvec3 barycoord;\n\t\t\t\t\tfloat side;\n\t\t\t\t\tvec3 outPoint;\n\t\t\t\t\tfloat dist = bvhClosestPointToPoint( bvh, point.xyz, faceIndices, faceNormal, barycoord, side, outPoint );\n\n\t\t\t\t\t// if the triangle side is the back then it must be on the inside and the value negative\n\t\t\t\t\tgl_FragColor = vec4( side * dist, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t`\n        });\n        this.setValues(params);\n    }\n}\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $2ff529b7be002585$export$9fb7e1e81432db6c extends (0, $ilwiq.ShaderMaterial) {\n    constructor(params){\n        super({\n            defines: {\n                DISPLAY_GRID: 0\n            },\n            uniforms: {\n                sdfTex: {\n                    value: null\n                },\n                layer: {\n                    value: 0\n                },\n                layers: {\n                    value: 0\n                }\n            },\n            vertexShader: /* glsl */ `\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform float layer;\n\t\t\t\tuniform float layers;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#if DISPLAY_GRID\n\n\t\t\t\t\tfloat dim = ceil( sqrt( layers ) );\n\t\t\t\t\tvec2 cell = floor( vUv * dim );\n\t\t\t\t\tvec2 frac = vUv * dim - cell;\n\t\t\t\t\tfloat zLayer = ( cell.y * dim + cell.x ) / ( dim * dim );\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( frac, zLayer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( vUv, layer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t`\n        });\n        this.setValues(params);\n    }\n}\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $2f2ddb336b460d2c$export$7518dfdc666d2802 extends (0, $ilwiq.ShaderMaterial) {\n    constructor(params){\n        super({\n            defines: {\n                MAX_STEPS: 500,\n                SURFACE_EPSILON: 0.001\n            },\n            uniforms: {\n                surface: {\n                    value: 0\n                },\n                sdfTex: {\n                    value: null\n                },\n                normalStep: {\n                    value: new (0, $ilwiq.Vector3)()\n                },\n                projectionInverse: {\n                    value: new (0, $ilwiq.Matrix4)()\n                },\n                sdfTransformInverse: {\n                    value: new (0, $ilwiq.Matrix4)()\n                }\n            },\n            vertexShader: /* glsl */ `\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform float surface;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform vec3 normalStep;\n\t\t\t\tuniform mat4 projectionInverse;\n\t\t\t\tuniform mat4 sdfTransformInverse;\n\n\t\t\t\t#include <common>\n\n\t\t\t\t// distance to box bounds\n\t\t\t\tvec2 rayBoxDist( vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir ) {\n\n\t\t\t\t\tvec3 t0 = ( boundsMin - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 t1 = ( boundsMax - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 tmin = min( t0, t1 );\n\t\t\t\t\tvec3 tmax = max( t0, t1 );\n\n\t\t\t\t\tfloat distA = max( max( tmin.x, tmin.y ), tmin.z );\n\t\t\t\t\tfloat distB = min( tmax.x, min( tmax.y, tmax.z ) );\n\n\t\t\t\t\tfloat distToBox = max( 0.0, distA );\n\t\t\t\t\tfloat distInsideBox = max( 0.0, distB - distToBox );\n\t\t\t\t\treturn vec2( distToBox, distInsideBox );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// get the inverse of the sdf box transform\n\t\t\t\t\tmat4 sdfTransform = inverse( sdfTransformInverse );\n\n\t\t\t\t\t// convert the uv to clip space for ray transformation\n\t\t\t\t\tvec2 clipSpace = 2.0 * vUv - vec2( 1.0 );\n\n\t\t\t\t\t// get world ray direction\n\t\t\t\t\tvec3 rayOrigin = vec3( 0.0 );\n\t\t\t\t\tvec4 homogenousDirection = projectionInverse * vec4( clipSpace, - 1.0, 1.0 );\n\t\t\t\t\tvec3 rayDirection = normalize( homogenousDirection.xyz / homogenousDirection.w );\n\n\t\t\t\t\t// transform ray into local coordinates of sdf bounds\n\t\t\t\t\tvec3 sdfRayOrigin = ( sdfTransformInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\t\tvec3 sdfRayDirection = normalize( ( sdfTransformInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t\t// find whether our ray hits the box bounds in the local box space\n\t\t\t\t\tvec2 boxIntersectionInfo = rayBoxDist( vec3( - 0.5 ), vec3( 0.5 ), sdfRayOrigin, sdfRayDirection );\n\t\t\t\t\tfloat distToBox = boxIntersectionInfo.x;\n\t\t\t\t\tfloat distInsideBox = boxIntersectionInfo.y;\n\t\t\t\t\tbool intersectsBox = distInsideBox > 0.0;\n\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tif ( intersectsBox ) {\n\n\t\t\t\t\t\t// find the surface point in world space\n\t\t\t\t\t\tbool intersectsSurface = false;\n\t\t\t\t\t\tvec4 localPoint = vec4( sdfRayOrigin + sdfRayDirection * ( distToBox + 1e-5 ), 1.0 );\n\t\t\t\t\t\tvec4 point = sdfTransform * localPoint;\n\n\t\t\t\t\t\t// ray march\n\t\t\t\t\t\tfor ( int i = 0; i < MAX_STEPS; i ++ ) {\n\n\t\t\t\t\t\t\t// sdf box extends from - 0.5 to 0.5\n\t\t\t\t\t\t\t// transform into the local bounds space [ 0, 1 ] and check if we're inside the bounds\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tif ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || uv.z < 0.0 || uv.z > 1.0 ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// get the distance to surface and exit the loop if we're close to the surface\n\t\t\t\t\t\t\tfloat distanceToSurface = texture2D( sdfTex, uv ).r - surface;\n\t\t\t\t\t\t\tif ( distanceToSurface < SURFACE_EPSILON ) {\n\n\t\t\t\t\t\t\t\tintersectsSurface = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// step the ray\n\t\t\t\t\t\t\tpoint.xyz += rayDirection * abs( distanceToSurface );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the surface normal\n\t\t\t\t\t\tif ( intersectsSurface ) {\n\n\t\t\t\t\t\t\t// compute the surface normal\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tfloat dx = texture( sdfTex, uv + vec3( normalStep.x, 0.0, 0.0 ) ).r - texture( sdfTex, uv - vec3( normalStep.x, 0.0, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dy = texture( sdfTex, uv + vec3( 0.0, normalStep.y, 0.0 ) ).r - texture( sdfTex, uv - vec3( 0.0, normalStep.y, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dz = texture( sdfTex, uv + vec3( 0.0, 0.0, normalStep.z ) ).r - texture( sdfTex, uv - vec3( 0.0, 0.0, normalStep.z ) ).r;\n\t\t\t\t\t\t\tvec3 normal = normalize( vec3( dx, dy, dz ) );\n\n\t\t\t\t\t\t\t// compute some basic lighting effects\n\t\t\t\t\t\t\tvec3 lightDirection = normalize( vec3( 1.0 ) );\n\t\t\t\t\t\t\tfloat lightIntensity =\n\t\t\t\t\t\t\t\tsaturate( dot( normal, lightDirection ) ) +\n\t\t\t\t\t\t\t\tsaturate( dot( normal, - lightDirection ) ) * 0.05 +\n\t\t\t\t\t\t\t\t0.1;\n\t\t\t\t\t\t\tgl_FragColor.rgb = vec3( lightIntensity );\n\t\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t`\n        });\n        this.setValues(params);\n    }\n}\n\n\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\nconst $c345b227375090f6$var$params = {\n    gpuGeneration: true,\n    resolution: 75,\n    margin: 0.2,\n    regenerate: ()=>$c345b227375090f6$var$updateSDF(),\n    mode: \"raymarching\",\n    layer: 0,\n    surface: 0.1\n};\nlet $c345b227375090f6$var$renderer, $c345b227375090f6$var$camera, $c345b227375090f6$var$scene, $c345b227375090f6$var$gui, $c345b227375090f6$var$stats, $c345b227375090f6$var$boxHelper;\nlet $c345b227375090f6$var$outputContainer, $c345b227375090f6$var$bvh, $c345b227375090f6$var$geometry, $c345b227375090f6$var$sdfTex, $c345b227375090f6$var$mesh;\nlet $c345b227375090f6$var$generateSdfPass, $c345b227375090f6$var$layerPass, $c345b227375090f6$var$raymarchPass;\nlet $c345b227375090f6$var$bvhGenerationWorker;\nconst $c345b227375090f6$var$inverseBoundsMatrix = new $ilwiq.Matrix4();\n$c345b227375090f6$var$init();\n$c345b227375090f6$var$render();\nfunction $c345b227375090f6$var$init() {\n    $c345b227375090f6$var$outputContainer = document.getElementById(\"output\");\n    // renderer setup\n    $c345b227375090f6$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $c345b227375090f6$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $c345b227375090f6$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $c345b227375090f6$var$renderer.setClearColor(0, 0);\n    $c345b227375090f6$var$renderer.outputEncoding = $ilwiq.sRGBEncoding;\n    document.body.appendChild($c345b227375090f6$var$renderer.domElement);\n    // scene setup\n    $c345b227375090f6$var$scene = new $ilwiq.Scene();\n    const light = new $ilwiq.DirectionalLight(0xffffff, 1);\n    light.position.set(1, 1, 1);\n    $c345b227375090f6$var$scene.add(light);\n    $c345b227375090f6$var$scene.add(new $ilwiq.AmbientLight(0xffffff, 0.2));\n    // camera setup\n    $c345b227375090f6$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);\n    $c345b227375090f6$var$camera.position.set(1, 1, 2);\n    $c345b227375090f6$var$camera.far = 100;\n    $c345b227375090f6$var$camera.updateProjectionMatrix();\n    $c345b227375090f6$var$boxHelper = new $ilwiq.Box3Helper(new $ilwiq.Box3());\n    $c345b227375090f6$var$scene.add($c345b227375090f6$var$boxHelper);\n    new (0, $5Rd1x.OrbitControls)($c345b227375090f6$var$camera, $c345b227375090f6$var$renderer.domElement);\n    // stats setup\n    $c345b227375090f6$var$stats = new (0, (/*@__PURE__*/$parcel$interopDefault($c8CJQ)))();\n    document.body.appendChild($c345b227375090f6$var$stats.dom);\n    // sdf pass to generate the 3d texture\n    $c345b227375090f6$var$generateSdfPass = new (0, $RPVlj.FullScreenQuad)(new (0, $445e06dac1d69dea$export$89d8017d8280911a)());\n    // screen pass to render a single layer of the 3d texture\n    $c345b227375090f6$var$layerPass = new (0, $RPVlj.FullScreenQuad)(new (0, $2ff529b7be002585$export$9fb7e1e81432db6c)());\n    // screen pass to render the sdf ray marching\n    $c345b227375090f6$var$raymarchPass = new (0, $RPVlj.FullScreenQuad)(new (0, $2f2ddb336b460d2c$export$7518dfdc666d2802)());\n    // load model and generate bvh\n    $c345b227375090f6$var$bvhGenerationWorker = new (0, $8todg.GenerateMeshBVHWorker)();\n    new (0, $7lx9d.GLTFLoader)().setMeshoptDecoder((0, $kp7Te.MeshoptDecoder)).loadAsync(\"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/stanford-bunny/bunny.glb\").then((gltf)=>{\n        gltf.scene.updateMatrixWorld(true);\n        const staticGen = new (0, $jAT47.StaticGeometryGenerator)(gltf.scene);\n        staticGen.attributes = [\n            \"position\",\n            \"normal\"\n        ];\n        staticGen.useGroups = false;\n        $c345b227375090f6$var$geometry = staticGen.generate().center();\n        return $c345b227375090f6$var$bvhGenerationWorker.generate($c345b227375090f6$var$geometry, {\n            maxLeafTris: 1\n        });\n    }).then((result)=>{\n        $c345b227375090f6$var$bvh = result;\n        $c345b227375090f6$var$mesh = new $ilwiq.Mesh($c345b227375090f6$var$geometry, new $ilwiq.MeshStandardMaterial());\n        $c345b227375090f6$var$scene.add($c345b227375090f6$var$mesh);\n        $c345b227375090f6$var$updateSDF();\n    });\n    $c345b227375090f6$var$rebuildGUI();\n    window.addEventListener(\"resize\", function() {\n        $c345b227375090f6$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $c345b227375090f6$var$camera.updateProjectionMatrix();\n        $c345b227375090f6$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    }, false);\n}\n// build the gui with parameters based on the selected display mode\nfunction $c345b227375090f6$var$rebuildGUI() {\n    if ($c345b227375090f6$var$gui) $c345b227375090f6$var$gui.destroy();\n    $c345b227375090f6$var$params.layer = Math.min($c345b227375090f6$var$params.resolution, $c345b227375090f6$var$params.layer);\n    $c345b227375090f6$var$gui = new (0, $jiuw3.GUI)();\n    const generationFolder = $c345b227375090f6$var$gui.addFolder(\"generation\");\n    generationFolder.add($c345b227375090f6$var$params, \"gpuGeneration\");\n    generationFolder.add($c345b227375090f6$var$params, \"resolution\", 10, 200, 1);\n    generationFolder.add($c345b227375090f6$var$params, \"margin\", 0, 1);\n    generationFolder.add($c345b227375090f6$var$params, \"regenerate\");\n    const displayFolder = $c345b227375090f6$var$gui.addFolder(\"display\");\n    displayFolder.add($c345b227375090f6$var$params, \"mode\", [\n        \"geometry\",\n        \"raymarching\",\n        \"layer\",\n        \"grid layers\"\n    ]).onChange(()=>{\n        $c345b227375090f6$var$rebuildGUI();\n    });\n    if ($c345b227375090f6$var$params.mode === \"layer\") displayFolder.add($c345b227375090f6$var$params, \"layer\", 0, $c345b227375090f6$var$params.resolution, 1);\n    if ($c345b227375090f6$var$params.mode === \"raymarching\") displayFolder.add($c345b227375090f6$var$params, \"surface\", -0.2, 0.5);\n}\n// update the sdf texture based on the selected parameters\nfunction $c345b227375090f6$var$updateSDF() {\n    const dim = $c345b227375090f6$var$params.resolution;\n    const matrix = new $ilwiq.Matrix4();\n    const center = new $ilwiq.Vector3();\n    const quat = new $ilwiq.Quaternion();\n    const scale = new $ilwiq.Vector3();\n    // compute the bounding box of the geometry including the margin which is used to\n    // define the range of the SDF\n    $c345b227375090f6$var$geometry.boundingBox.getCenter(center);\n    scale.subVectors($c345b227375090f6$var$geometry.boundingBox.max, $c345b227375090f6$var$geometry.boundingBox.min);\n    scale.x += 2 * $c345b227375090f6$var$params.margin;\n    scale.y += 2 * $c345b227375090f6$var$params.margin;\n    scale.z += 2 * $c345b227375090f6$var$params.margin;\n    matrix.compose(center, quat, scale);\n    $c345b227375090f6$var$inverseBoundsMatrix.copy(matrix).invert();\n    // update the box helper\n    $c345b227375090f6$var$boxHelper.box.copy($c345b227375090f6$var$geometry.boundingBox);\n    $c345b227375090f6$var$boxHelper.box.min.x -= $c345b227375090f6$var$params.margin;\n    $c345b227375090f6$var$boxHelper.box.min.y -= $c345b227375090f6$var$params.margin;\n    $c345b227375090f6$var$boxHelper.box.min.z -= $c345b227375090f6$var$params.margin;\n    $c345b227375090f6$var$boxHelper.box.max.x += $c345b227375090f6$var$params.margin;\n    $c345b227375090f6$var$boxHelper.box.max.y += $c345b227375090f6$var$params.margin;\n    $c345b227375090f6$var$boxHelper.box.max.z += $c345b227375090f6$var$params.margin;\n    // dispose of the existing sdf\n    if ($c345b227375090f6$var$sdfTex) $c345b227375090f6$var$sdfTex.dispose();\n    const pxWidth = 1 / dim;\n    const halfWidth = 0.5 * pxWidth;\n    const startTime = window.performance.now();\n    if ($c345b227375090f6$var$params.gpuGeneration) {\n        // create a new 3d render target texture\n        const floatLinearExtSupported = $c345b227375090f6$var$renderer.extensions.get(\"OES_texture_float_linear\");\n        $c345b227375090f6$var$sdfTex = new $ilwiq.WebGL3DRenderTarget(dim, dim, dim);\n        $c345b227375090f6$var$sdfTex.texture.format = $ilwiq.RedFormat;\n        $c345b227375090f6$var$sdfTex.texture.type = floatLinearExtSupported ? $ilwiq.FloatType : $ilwiq.HalfFloatType;\n        $c345b227375090f6$var$sdfTex.texture.minFilter = $ilwiq.LinearFilter;\n        $c345b227375090f6$var$sdfTex.texture.magFilter = $ilwiq.LinearFilter;\n        // prep the sdf generation material pass\n        $c345b227375090f6$var$generateSdfPass.material.uniforms.bvh.value.updateFrom($c345b227375090f6$var$bvh);\n        $c345b227375090f6$var$generateSdfPass.material.uniforms.matrix.value.copy(matrix);\n        // render into each layer\n        for(let i = 0; i < dim; i++){\n            $c345b227375090f6$var$generateSdfPass.material.uniforms.zValue.value = i * pxWidth + halfWidth;\n            $c345b227375090f6$var$renderer.setRenderTarget($c345b227375090f6$var$sdfTex, i);\n            $c345b227375090f6$var$generateSdfPass.render($c345b227375090f6$var$renderer);\n        }\n        // initiate read back to get a rough estimate of time taken to generate the sdf\n        $c345b227375090f6$var$renderer.readRenderTargetPixels($c345b227375090f6$var$sdfTex, 0, 0, 1, 1, new Float32Array(4));\n        $c345b227375090f6$var$renderer.setRenderTarget(null);\n    } else {\n        // create a new 3d data texture\n        $c345b227375090f6$var$sdfTex = new $ilwiq.Data3DTexture(new Float32Array(dim ** 3), dim, dim, dim);\n        $c345b227375090f6$var$sdfTex.format = $ilwiq.RedFormat;\n        $c345b227375090f6$var$sdfTex.type = $ilwiq.FloatType;\n        $c345b227375090f6$var$sdfTex.minFilter = $ilwiq.LinearFilter;\n        $c345b227375090f6$var$sdfTex.magFilter = $ilwiq.LinearFilter;\n        $c345b227375090f6$var$sdfTex.needsUpdate = true;\n        const posAttr = $c345b227375090f6$var$geometry.attributes.position;\n        const indexAttr = $c345b227375090f6$var$geometry.index;\n        const point = new $ilwiq.Vector3();\n        const normal = new $ilwiq.Vector3();\n        const delta = new $ilwiq.Vector3();\n        const tri = new $ilwiq.Triangle();\n        const target = {};\n        // iterate over all pixels and check distance\n        for(let x = 0; x < dim; x++){\n            for(let y = 0; y < dim; y++)for(let z = 0; z < dim; z++){\n                // adjust by half width of the pixel so we sample the pixel center\n                // and offset by half the box size.\n                point.set(halfWidth + x * pxWidth - 0.5, halfWidth + y * pxWidth - 0.5, halfWidth + z * pxWidth - 0.5).applyMatrix4(matrix);\n                const index = x + y * dim + z * dim * dim;\n                const dist = $c345b227375090f6$var$bvh.closestPointToPoint(point, target).distance;\n                // get the face normal to determine if the distance should be positive or negative\n                const faceIndex = target.faceIndex;\n                const i0 = indexAttr.getX(faceIndex * 3 + 0);\n                const i1 = indexAttr.getX(faceIndex * 3 + 1);\n                const i2 = indexAttr.getX(faceIndex * 3 + 2);\n                tri.setFromAttributeAndIndices(posAttr, i0, i1, i2);\n                tri.getNormal(normal);\n                delta.subVectors(target.point, point);\n                // set the distance in the texture data\n                $c345b227375090f6$var$sdfTex.image.data[index] = normal.dot(delta) > 0.0 ? -dist : dist;\n            }\n        }\n    }\n    // update the timing display\n    const delta = window.performance.now() - startTime;\n    $c345b227375090f6$var$outputContainer.innerText = `${delta.toFixed(2)}ms`;\n    $c345b227375090f6$var$rebuildGUI();\n}\nfunction $c345b227375090f6$var$render() {\n    $c345b227375090f6$var$stats.update();\n    requestAnimationFrame($c345b227375090f6$var$render);\n    if (!$c345b227375090f6$var$sdfTex) // render nothing\n    return;\n    else if ($c345b227375090f6$var$params.mode === \"geometry\") // render the rasterized geometry\n    $c345b227375090f6$var$renderer.render($c345b227375090f6$var$scene, $c345b227375090f6$var$camera);\n    else if ($c345b227375090f6$var$params.mode === \"layer\" || $c345b227375090f6$var$params.mode === \"grid layers\") {\n        // render a layer of the 3d texture\n        let tex;\n        const material = $c345b227375090f6$var$layerPass.material;\n        if ($c345b227375090f6$var$sdfTex.isData3DTexture) {\n            material.uniforms.layer.value = $c345b227375090f6$var$params.layer / $c345b227375090f6$var$sdfTex.image.width;\n            material.uniforms.sdfTex.value = $c345b227375090f6$var$sdfTex;\n            tex = $c345b227375090f6$var$sdfTex;\n        } else {\n            material.uniforms.layer.value = $c345b227375090f6$var$params.layer / $c345b227375090f6$var$sdfTex.width;\n            material.uniforms.sdfTex.value = $c345b227375090f6$var$sdfTex.texture;\n            tex = $c345b227375090f6$var$sdfTex.texture;\n        }\n        material.uniforms.layers.value = tex.image.width;\n        const gridMode = $c345b227375090f6$var$params.mode === \"layer\" ? 0 : 1;\n        if (gridMode !== material.defines.DISPLAY_GRID) {\n            material.defines.DISPLAY_GRID = gridMode;\n            material.needsUpdate = true;\n        }\n        $c345b227375090f6$var$layerPass.render($c345b227375090f6$var$renderer);\n    } else if ($c345b227375090f6$var$params.mode === \"raymarching\") {\n        // render the ray marched texture\n        $c345b227375090f6$var$camera.updateMatrixWorld();\n        $c345b227375090f6$var$mesh.updateMatrixWorld();\n        let tex;\n        if ($c345b227375090f6$var$sdfTex.isData3DTexture) tex = $c345b227375090f6$var$sdfTex;\n        else tex = $c345b227375090f6$var$sdfTex.texture;\n        const { width: width, depth: depth, height: height } = tex.image;\n        $c345b227375090f6$var$raymarchPass.material.uniforms.sdfTex.value = tex;\n        $c345b227375090f6$var$raymarchPass.material.uniforms.normalStep.value.set(1 / width, 1 / height, 1 / depth);\n        $c345b227375090f6$var$raymarchPass.material.uniforms.surface.value = $c345b227375090f6$var$params.surface;\n        $c345b227375090f6$var$raymarchPass.material.uniforms.projectionInverse.value.copy($c345b227375090f6$var$camera.projectionMatrixInverse);\n        $c345b227375090f6$var$raymarchPass.material.uniforms.sdfTransformInverse.value.copy($c345b227375090f6$var$mesh.matrixWorld).invert().premultiply($c345b227375090f6$var$inverseBoundsMatrix).multiply($c345b227375090f6$var$camera.matrixWorld);\n        $c345b227375090f6$var$raymarchPass.render($c345b227375090f6$var$renderer);\n    }\n}\n\n\n//# sourceMappingURL=sdfGeneration.3e4cbe3a.js.map\n","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\tthis.isPass = true;\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nconst _geometry = new BufferGeometry();\n_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","import { Box3, BufferAttribute } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport { WorkerBase } from './utils/WorkerBase.js';\n\nexport class GenerateMeshBVHWorker extends WorkerBase {\n\n\tconstructor() {\n\n\t\tconst worker = new Worker( new URL( './generateMeshBVH.worker.js', import.meta.url ), { type: 'module' } );\n\t\tsuper( worker );\n\t\tthis.name = 'GenerateMeshBVHWorker';\n\n\t}\n\n\trunTask( worker, geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tif (\n\t\t\t\tgeometry.getAttribute( 'position' ).isInterleavedBufferAttribute ||\n\t\t\t\tgeometry.index && geometry.index.isInterleavedBufferAttribute\n\t\t\t) {\n\n\t\t\t\tthrow new Error( 'GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.' );\n\n\t\t\t}\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `GenerateMeshBVHWorker: ${ e.message }` ) );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.serialized ) {\n\n\t\t\t\t\tconst { serialized, position } = data;\n\t\t\t\t\tconst bvh = MeshBVH.deserialize( serialized, geometry, { setIndex: false } );\n\t\t\t\t\tconst boundsOptions = Object.assign( {\n\n\t\t\t\t\t\tsetBoundingBox: true,\n\n\t\t\t\t\t}, options );\n\n\t\t\t\t\t// we need to replace the arrays because they're neutered entirely by the\n\t\t\t\t\t// webworker transfer.\n\t\t\t\t\tgeometry.attributes.position.array = position;\n\t\t\t\t\tif ( serialized.index ) {\n\n\t\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\t\tgeometry.index.array = serialized.index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst newIndex = new BufferAttribute( serialized.index, 1, false );\n\t\t\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundsOptions.setBoundingBox ) {\n\n\t\t\t\t\t\tgeometry.boundingBox = bvh.getBoundingBox( new Box3() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( bvh );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\t\tconst position = geometry.attributes.position.array;\n\t\t\tconst transferable = [ position ];\n\t\t\tif ( index ) {\n\n\t\t\t\ttransferable.push( index );\n\n\t\t\t}\n\n\t\t\tworker.postMessage( {\n\n\t\t\t\tindex,\n\t\t\t\tposition,\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t\tgroups: [ ... geometry.groups ],\n\t\t\t\t},\n\n\t\t\t}, transferable.map( arr => arr.buffer ).filter( v => ( typeof SharedArrayBuffer === 'undefined' ) || ! ( v instanceof SharedArrayBuffer ) ) );\n\n\t\t} );\n\n\t}\n\n}\n","export class WorkerBase {\n\n\tconstructor( worker ) {\n\n\t\tthis.name = 'WorkerBase';\n\t\tthis.running = false;\n\t\tthis.worker = worker;\n\t\tthis.worker.onerror = e => {\n\n\t\t\tif ( e.message ) {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker with error \"${ e.message }\"` );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker.` );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\trunTask() {}\n\n\tgenerate( ...args ) {\n\n\t\tif ( this.running ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Already running job.' );\n\n\t\t}\n\n\t\tif ( this.worker === null ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Worker has been disposed.' );\n\n\t\t}\n\n\t\tthis.running = true;\n\n\t\tconst promise = this.runTask( this.worker, ...args );\n\t\tpromise.finally( () => {\n\n\t\t\tthis.running = false;\n\n\t\t} );\n\n\t\treturn promise;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.worker.terminate();\n\t\tthis.worker = null;\n\n\t}\n\n}\n","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(\"generateMeshBVH.worker.17f4c1c5.js\");\nmodule.exports = workerURL(url.toString(), url.origin, true);","\"use strict\";\n\nmodule.exports = function (workerUrl, origin, isESM) {\n  if (origin === self.location.origin) {\n    // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n  } else {\n    // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n    var source = isESM ? 'import ' + JSON.stringify(workerUrl) + ';' : 'importScripts(' + JSON.stringify(workerUrl) + ');';\n    return URL.createObjectURL(new Blob([source], {\n      type: 'application/javascript'\n    }));\n  }\n};","require('./helpers/bundle-manifest').register(new __parcel__URL__(\"\").toString(),JSON.parse(\"[\\\"1WzX2\\\",\\\"sdfGeneration.3e4cbe3a.js\\\",\\\"6J6WW\\\",\\\"generateMeshBVH.worker.17f4c1c5.js\\\",\\\"acVmZ\\\",\\\"generateMeshBVH.worker.aad48e6e.js\\\",\\\"gr8Yf\\\",\\\"asyncGenerate.22609466.js\\\",\\\"j19h5\\\",\\\"asyncGenerate.e8b1599c.js\\\",\\\"30Pwg\\\",\\\"asyncGenerate.77ce35af.js\\\",\\\"2tzBs\\\",\\\"characterMovement.89c1b67b.js\\\",\\\"6UuCC\\\",\\\"characterMovement.5fc59dbe.js\\\",\\\"6mMEU\\\",\\\"characterMovement.fc8349f1.js\\\",\\\"3lH4c\\\",\\\"characterMovement.933f8c48.js\\\",\\\"i0zVc\\\",\\\"clippedEdges.dcf40b33.js\\\",\\\"gVxlZ\\\",\\\"diamond.5b837c44.js\\\"]\"));","import * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'stats.js';\nimport { GenerateMeshBVHWorker } from '../src/workers/GenerateMeshBVHWorker.js';\nimport { StaticGeometryGenerator } from '..';\nimport { GenerateSDFMaterial } from './utils/GenerateSDFMaterial.js';\nimport { RenderSDFLayerMaterial } from './utils/RenderSDFLayerMaterial.js';\nimport { RayMarchSDFMaterial } from './utils/RayMarchSDFMaterial.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\n\nconst params = {\n\n\tgpuGeneration: true,\n\tresolution: 75,\n\tmargin: 0.2,\n\tregenerate: () => updateSDF(),\n\n\tmode: 'raymarching',\n\tlayer: 0,\n\tsurface: 0.1,\n\n};\n\nlet renderer, camera, scene, gui, stats, boxHelper;\nlet outputContainer, bvh, geometry, sdfTex, mesh;\nlet generateSdfPass, layerPass, raymarchPass;\nlet bvhGenerationWorker;\nconst inverseBoundsMatrix = new THREE.Matrix4();\n\ninit();\nrender();\n\nfunction init() {\n\n\toutputContainer = document.getElementById( 'output' );\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0, 0 );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.position.set( 1, 1, 1 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 1, 1, 2 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\tboxHelper = new THREE.Box3Helper( new THREE.Box3() );\n\tscene.add( boxHelper );\n\n\tnew OrbitControls( camera, renderer.domElement );\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// sdf pass to generate the 3d texture\n\tgenerateSdfPass = new FullScreenQuad( new GenerateSDFMaterial() );\n\n\t// screen pass to render a single layer of the 3d texture\n\tlayerPass = new FullScreenQuad( new RenderSDFLayerMaterial() );\n\n\t// screen pass to render the sdf ray marching\n\traymarchPass = new FullScreenQuad( new RayMarchSDFMaterial() );\n\n\t// load model and generate bvh\n\tbvhGenerationWorker = new GenerateMeshBVHWorker();\n\n\tnew GLTFLoader()\n\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t.loadAsync( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/stanford-bunny/bunny.glb' )\n\t\t.then( gltf => {\n\n\t\t\tgltf.scene.updateMatrixWorld( true );\n\n\t\t\tconst staticGen = new StaticGeometryGenerator( gltf.scene );\n\t\t\tstaticGen.attributes = [ 'position', 'normal' ];\n\t\t\tstaticGen.useGroups = false;\n\n\t\t\tgeometry = staticGen.generate().center();\n\n\t\t\treturn bvhGenerationWorker.generate( geometry, { maxLeafTris: 1 } );\n\n\t\t} )\n\t\t.then( result => {\n\n\t\t\tbvh = result;\n\n\t\t\tmesh = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\t\tscene.add( mesh );\n\n\t\t\tupdateSDF();\n\n\t\t} );\n\n\trebuildGUI();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n}\n\n// build the gui with parameters based on the selected display mode\nfunction rebuildGUI() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tparams.layer = Math.min( params.resolution, params.layer );\n\n\tgui = new GUI();\n\n\tconst generationFolder = gui.addFolder( 'generation' );\n\tgenerationFolder.add( params, 'gpuGeneration' );\n\tgenerationFolder.add( params, 'resolution', 10, 200, 1 );\n\tgenerationFolder.add( params, 'margin', 0, 1 );\n\tgenerationFolder.add( params, 'regenerate' );\n\n\tconst displayFolder = gui.addFolder( 'display' );\n\tdisplayFolder.add( params, 'mode', [ 'geometry', 'raymarching', 'layer', 'grid layers' ] ).onChange( () => {\n\n\t\trebuildGUI();\n\n\t} );\n\n\tif ( params.mode === 'layer' ) {\n\n\t\tdisplayFolder.add( params, 'layer', 0, params.resolution, 1 );\n\n\t}\n\n\tif ( params.mode === 'raymarching' ) {\n\n\t\tdisplayFolder.add( params, 'surface', - 0.2, 0.5 );\n\n\t}\n\n}\n\n// update the sdf texture based on the selected parameters\nfunction updateSDF() {\n\n\tconst dim = params.resolution;\n\tconst matrix = new THREE.Matrix4();\n\tconst center = new THREE.Vector3();\n\tconst quat = new THREE.Quaternion();\n\tconst scale = new THREE.Vector3();\n\n\t// compute the bounding box of the geometry including the margin which is used to\n\t// define the range of the SDF\n\tgeometry.boundingBox.getCenter( center );\n\tscale.subVectors( geometry.boundingBox.max, geometry.boundingBox.min );\n\tscale.x += 2 * params.margin;\n\tscale.y += 2 * params.margin;\n\tscale.z += 2 * params.margin;\n\tmatrix.compose( center, quat, scale );\n\tinverseBoundsMatrix.copy( matrix ).invert();\n\n\t// update the box helper\n\tboxHelper.box.copy( geometry.boundingBox );\n\tboxHelper.box.min.x -= params.margin;\n\tboxHelper.box.min.y -= params.margin;\n\tboxHelper.box.min.z -= params.margin;\n\tboxHelper.box.max.x += params.margin;\n\tboxHelper.box.max.y += params.margin;\n\tboxHelper.box.max.z += params.margin;\n\n\t// dispose of the existing sdf\n\tif ( sdfTex ) {\n\n\t\tsdfTex.dispose();\n\n\t}\n\n\tconst pxWidth = 1 / dim;\n\tconst halfWidth = 0.5 * pxWidth;\n\n\tconst startTime = window.performance.now();\n\tif ( params.gpuGeneration ) {\n\n\t\t// create a new 3d render target texture\n\t\tconst floatLinearExtSupported = renderer.extensions.get( 'OES_texture_float_linear' );\n\t\tsdfTex = new THREE.WebGL3DRenderTarget( dim, dim, dim );\n\t\tsdfTex.texture.format = THREE.RedFormat;\n\t\tsdfTex.texture.type = floatLinearExtSupported ? THREE.FloatType : THREE.HalfFloatType;\n\t\tsdfTex.texture.minFilter = THREE.LinearFilter;\n\t\tsdfTex.texture.magFilter = THREE.LinearFilter;\n\n\t\t// prep the sdf generation material pass\n\t\tgenerateSdfPass.material.uniforms.bvh.value.updateFrom( bvh );\n\t\tgenerateSdfPass.material.uniforms.matrix.value.copy( matrix );\n\n\t\t// render into each layer\n\t\tfor ( let i = 0; i < dim; i ++ ) {\n\n\t\t\tgenerateSdfPass.material.uniforms.zValue.value = i * pxWidth + halfWidth;\n\n\t\t\trenderer.setRenderTarget( sdfTex, i );\n\t\t\tgenerateSdfPass.render( renderer );\n\n\t\t}\n\n\t\t// initiate read back to get a rough estimate of time taken to generate the sdf\n\t\trenderer.readRenderTargetPixels( sdfTex, 0, 0, 1, 1, new Float32Array( 4 ) );\n\t\trenderer.setRenderTarget( null );\n\n\t} else {\n\n\t\t// create a new 3d data texture\n\t\tsdfTex = new THREE.Data3DTexture( new Float32Array( dim ** 3 ), dim, dim, dim );\n\t\tsdfTex.format = THREE.RedFormat;\n\t\tsdfTex.type = THREE.FloatType;\n\t\tsdfTex.minFilter = THREE.LinearFilter;\n\t\tsdfTex.magFilter = THREE.LinearFilter;\n\t\tsdfTex.needsUpdate = true;\n\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst indexAttr = geometry.index;\n\t\tconst point = new THREE.Vector3();\n\t\tconst normal = new THREE.Vector3();\n\t\tconst delta = new THREE.Vector3();\n\t\tconst tri = new THREE.Triangle();\n\t\tconst target = {};\n\n\t\t// iterate over all pixels and check distance\n\t\tfor ( let x = 0; x < dim; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < dim; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z < dim; z ++ ) {\n\n\t\t\t\t\t// adjust by half width of the pixel so we sample the pixel center\n\t\t\t\t\t// and offset by half the box size.\n\t\t\t\t\tpoint.set(\n\t\t\t\t\t\thalfWidth + x * pxWidth - 0.5,\n\t\t\t\t\t\thalfWidth + y * pxWidth - 0.5,\n\t\t\t\t\t\thalfWidth + z * pxWidth - 0.5,\n\t\t\t\t\t).applyMatrix4( matrix );\n\n\t\t\t\t\tconst index = x + y * dim + z * dim * dim;\n\t\t\t\t\tconst dist = bvh.closestPointToPoint( point, target ).distance;\n\n\t\t\t\t\t// get the face normal to determine if the distance should be positive or negative\n\t\t\t\t\tconst faceIndex = target.faceIndex;\n\t\t\t\t\tconst i0 = indexAttr.getX( faceIndex * 3 + 0 );\n\t\t\t\t\tconst i1 = indexAttr.getX( faceIndex * 3 + 1 );\n\t\t\t\t\tconst i2 = indexAttr.getX( faceIndex * 3 + 2 );\n\t\t\t\t\ttri.setFromAttributeAndIndices( posAttr, i0, i1, i2 );\n\t\t\t\t\ttri.getNormal( normal );\n\t\t\t\t\tdelta.subVectors( target.point, point );\n\n\t\t\t\t\t// set the distance in the texture data\n\t\t\t\t\tsdfTex.image.data[ index ] = normal.dot( delta ) > 0.0 ? - dist : dist;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// update the timing display\n\tconst delta = window.performance.now() - startTime;\n\toutputContainer.innerText = `${ delta.toFixed( 2 ) }ms`;\n\n\trebuildGUI();\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tif ( ! sdfTex ) {\n\n\t\t// render nothing\n\t\treturn;\n\n\t} else if ( params.mode === 'geometry' ) {\n\n\t\t// render the rasterized geometry\n\t\trenderer.render( scene, camera );\n\n\t} else if ( params.mode === 'layer' || params.mode === 'grid layers' ) {\n\n\t\t// render a layer of the 3d texture\n\t\tlet tex;\n\t\tconst material = layerPass.material;\n\t\tif ( sdfTex.isData3DTexture ) {\n\n\t\t\tmaterial.uniforms.layer.value = params.layer / sdfTex.image.width;\n\t\t\tmaterial.uniforms.sdfTex.value = sdfTex;\n\t\t\ttex = sdfTex;\n\n\t\t} else {\n\n\t\t\tmaterial.uniforms.layer.value = params.layer / sdfTex.width;\n\t\t\tmaterial.uniforms.sdfTex.value = sdfTex.texture;\n\t\t\ttex = sdfTex.texture;\n\n\t\t}\n\n\t\tmaterial.uniforms.layers.value = tex.image.width;\n\n\t\tconst gridMode = params.mode === 'layer' ? 0 : 1;\n\t\tif ( gridMode !== material.defines.DISPLAY_GRID ) {\n\n\t\t\tmaterial.defines.DISPLAY_GRID = gridMode;\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tlayerPass.render( renderer );\n\n\t} else if ( params.mode === 'raymarching' ) {\n\n\t\t// render the ray marched texture\n\t\tcamera.updateMatrixWorld();\n\t\tmesh.updateMatrixWorld();\n\n\t\tlet tex;\n\t\tif ( sdfTex.isData3DTexture ) {\n\n\t\t\ttex = sdfTex;\n\n\t\t} else {\n\n\t\t\ttex = sdfTex.texture;\n\n\t\t}\n\n\t\tconst { width, depth, height } = tex.image;\n\t\traymarchPass.material.uniforms.sdfTex.value = tex;\n\t\traymarchPass.material.uniforms.normalStep.value.set( 1 / width, 1 / height, 1 / depth );\n\t\traymarchPass.material.uniforms.surface.value = params.surface;\n\t\traymarchPass.material.uniforms.projectionInverse.value.copy( camera.projectionMatrixInverse );\n\t\traymarchPass.material.uniforms.sdfTransformInverse.value.copy( mesh.matrixWorld ).invert().premultiply( inverseBoundsMatrix ).multiply( camera.matrixWorld );\n\t\traymarchPass.render( renderer );\n\n\t}\n\n}\n","import { ShaderMaterial, Matrix4 } from 'three';\nimport { BVHShaderGLSL, MeshBVHUniformStruct } from '../..';\n\nexport class GenerateSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tmatrix: { value: new Matrix4() },\n\t\t\t\tzValue: { value: 0 },\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\n\t\t\t\t${ BVHShaderGLSL.common_functions }\n\t\t\t\t${ BVHShaderGLSL.bvh_struct_definitions }\n\t\t\t\t${ BVHShaderGLSL.bvh_ray_functions }\n\t\t\t\t${ BVHShaderGLSL.bvh_distance_functions }\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float zValue;\n\t\t\t\tuniform mat4 matrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// compute the point in space to check\n\t\t\t\t\tvec3 point = vec3( vUv, zValue );\n\t\t\t\t\tpoint -= vec3( 0.5 );\n\t\t\t\t\tpoint = ( matrix * vec4( point, 1.0 ) ).xyz;\n\n\t\t\t\t\t// retrieve the distance and other values\n\t\t\t\t\tuvec4 faceIndices;\n\t\t\t\t\tvec3 faceNormal;\n\t\t\t\t\tvec3 barycoord;\n\t\t\t\t\tfloat side;\n\t\t\t\t\tvec3 outPoint;\n\t\t\t\t\tfloat dist = bvhClosestPointToPoint( bvh, point.xyz, faceIndices, faceNormal, barycoord, side, outPoint );\n\n\t\t\t\t\t// if the triangle side is the back then it must be on the inside and the value negative\n\t\t\t\t\tgl_FragColor = vec4( side * dist, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { ShaderMaterial } from 'three';\n\nexport class RenderSDFLayerMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tDISPLAY_GRID: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsdfTex: { value: null },\n\t\t\t\tlayer: { value: 0 },\n\t\t\t\tlayers: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform float layer;\n\t\t\t\tuniform float layers;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#if DISPLAY_GRID\n\n\t\t\t\t\tfloat dim = ceil( sqrt( layers ) );\n\t\t\t\t\tvec2 cell = floor( vUv * dim );\n\t\t\t\t\tvec2 frac = vUv * dim - cell;\n\t\t\t\t\tfloat zLayer = ( cell.y * dim + cell.x ) / ( dim * dim );\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( frac, zLayer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( vUv, layer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { ShaderMaterial, Matrix4, Vector3 } from 'three';\n\nexport class RayMarchSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tMAX_STEPS: 500,\n\t\t\t\tSURFACE_EPSILON: 0.001,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsurface: { value: 0 },\n\t\t\t\tsdfTex: { value: null },\n\t\t\t\tnormalStep: { value: new Vector3() },\n\t\t\t\tprojectionInverse: { value: new Matrix4() },\n\t\t\t\tsdfTransformInverse: { value: new Matrix4() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform float surface;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform vec3 normalStep;\n\t\t\t\tuniform mat4 projectionInverse;\n\t\t\t\tuniform mat4 sdfTransformInverse;\n\n\t\t\t\t#include <common>\n\n\t\t\t\t// distance to box bounds\n\t\t\t\tvec2 rayBoxDist( vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir ) {\n\n\t\t\t\t\tvec3 t0 = ( boundsMin - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 t1 = ( boundsMax - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 tmin = min( t0, t1 );\n\t\t\t\t\tvec3 tmax = max( t0, t1 );\n\n\t\t\t\t\tfloat distA = max( max( tmin.x, tmin.y ), tmin.z );\n\t\t\t\t\tfloat distB = min( tmax.x, min( tmax.y, tmax.z ) );\n\n\t\t\t\t\tfloat distToBox = max( 0.0, distA );\n\t\t\t\t\tfloat distInsideBox = max( 0.0, distB - distToBox );\n\t\t\t\t\treturn vec2( distToBox, distInsideBox );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// get the inverse of the sdf box transform\n\t\t\t\t\tmat4 sdfTransform = inverse( sdfTransformInverse );\n\n\t\t\t\t\t// convert the uv to clip space for ray transformation\n\t\t\t\t\tvec2 clipSpace = 2.0 * vUv - vec2( 1.0 );\n\n\t\t\t\t\t// get world ray direction\n\t\t\t\t\tvec3 rayOrigin = vec3( 0.0 );\n\t\t\t\t\tvec4 homogenousDirection = projectionInverse * vec4( clipSpace, - 1.0, 1.0 );\n\t\t\t\t\tvec3 rayDirection = normalize( homogenousDirection.xyz / homogenousDirection.w );\n\n\t\t\t\t\t// transform ray into local coordinates of sdf bounds\n\t\t\t\t\tvec3 sdfRayOrigin = ( sdfTransformInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\t\tvec3 sdfRayDirection = normalize( ( sdfTransformInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t\t// find whether our ray hits the box bounds in the local box space\n\t\t\t\t\tvec2 boxIntersectionInfo = rayBoxDist( vec3( - 0.5 ), vec3( 0.5 ), sdfRayOrigin, sdfRayDirection );\n\t\t\t\t\tfloat distToBox = boxIntersectionInfo.x;\n\t\t\t\t\tfloat distInsideBox = boxIntersectionInfo.y;\n\t\t\t\t\tbool intersectsBox = distInsideBox > 0.0;\n\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tif ( intersectsBox ) {\n\n\t\t\t\t\t\t// find the surface point in world space\n\t\t\t\t\t\tbool intersectsSurface = false;\n\t\t\t\t\t\tvec4 localPoint = vec4( sdfRayOrigin + sdfRayDirection * ( distToBox + 1e-5 ), 1.0 );\n\t\t\t\t\t\tvec4 point = sdfTransform * localPoint;\n\n\t\t\t\t\t\t// ray march\n\t\t\t\t\t\tfor ( int i = 0; i < MAX_STEPS; i ++ ) {\n\n\t\t\t\t\t\t\t// sdf box extends from - 0.5 to 0.5\n\t\t\t\t\t\t\t// transform into the local bounds space [ 0, 1 ] and check if we're inside the bounds\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tif ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || uv.z < 0.0 || uv.z > 1.0 ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// get the distance to surface and exit the loop if we're close to the surface\n\t\t\t\t\t\t\tfloat distanceToSurface = texture2D( sdfTex, uv ).r - surface;\n\t\t\t\t\t\t\tif ( distanceToSurface < SURFACE_EPSILON ) {\n\n\t\t\t\t\t\t\t\tintersectsSurface = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// step the ray\n\t\t\t\t\t\t\tpoint.xyz += rayDirection * abs( distanceToSurface );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the surface normal\n\t\t\t\t\t\tif ( intersectsSurface ) {\n\n\t\t\t\t\t\t\t// compute the surface normal\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tfloat dx = texture( sdfTex, uv + vec3( normalStep.x, 0.0, 0.0 ) ).r - texture( sdfTex, uv - vec3( normalStep.x, 0.0, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dy = texture( sdfTex, uv + vec3( 0.0, normalStep.y, 0.0 ) ).r - texture( sdfTex, uv - vec3( 0.0, normalStep.y, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dz = texture( sdfTex, uv + vec3( 0.0, 0.0, normalStep.z ) ).r - texture( sdfTex, uv - vec3( 0.0, 0.0, normalStep.z ) ).r;\n\t\t\t\t\t\t\tvec3 normal = normalize( vec3( dx, dy, dz ) );\n\n\t\t\t\t\t\t\t// compute some basic lighting effects\n\t\t\t\t\t\t\tvec3 lightDirection = normalize( vec3( 1.0 ) );\n\t\t\t\t\t\t\tfloat lightIntensity =\n\t\t\t\t\t\t\t\tsaturate( dot( normal, lightDirection ) ) +\n\t\t\t\t\t\t\t\tsaturate( dot( normal, - lightDirection ) ) * 0.05 +\n\t\t\t\t\t\t\t\t0.1;\n\t\t\t\t\t\t\tgl_FragColor.rgb = vec3( lightIntensity );\n\t\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n"],"names":["$c345b227375090f6$var$renderer","$c345b227375090f6$var$camera","$c345b227375090f6$var$scene","$c345b227375090f6$var$gui","$c345b227375090f6$var$stats","$c345b227375090f6$var$boxHelper","$c345b227375090f6$var$outputContainer","$c345b227375090f6$var$bvh","$c345b227375090f6$var$geometry","$c345b227375090f6$var$sdfTex","$c345b227375090f6$var$mesh","$c345b227375090f6$var$generateSdfPass","$c345b227375090f6$var$layerPass","$c345b227375090f6$var$raymarchPass","$c345b227375090f6$var$bvhGenerationWorker","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$var$mapping","Map","baseUrl","manifest","i","length","path","$0a1d3a5a6a49de03$export$3983474c8e6e978b","$ilwiq","$0a1d3a5a6a49de03$var$_camera","OrthographicCamera","$0a1d3a5a6a49de03$var$_geometry","BufferGeometry","setAttribute","Float32BufferAttribute","constructor","material","_mesh","Mesh","dispose","geometry","render","renderer","value","f","a","c","appendChild","dom","u","d","children","style","display","l","document","createElement","cssText","addEventListener","preventDefault","k","performance","Date","now","g","r","Panel","h","self","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","Infinity","Math","round","window","devicePixelRatio","m","p","q","width","height","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","w","min","max","drawImage","$62b3d05905f83386$export$426cc6213ad628cf","$ff8ed","$77YCt","WorkerBase","Worker","name","runTask","worker","options","Promise","resolve","reject","getAttribute","isInterleavedBufferAttribute","index","onerror","message","onmessage","data","error","serialized","position","bvh","MeshBVH","deserialize","setIndex","boundsOptions","assign","setBoundingBox","attributes","array","newIndex","BufferAttribute","boundingBox","getBoundingBox","Box3","onProgress","progress","transferable","push","postMessage","includedProgressCallback","Boolean","groups","map","arr","buffer","filter","SharedArrayBuffer","$5308359e4b33977a$export$8dbf7c43841b75b7","running","generate","args","promise","finally","terminate","$7ryUf","$8a4fc930af686efe$var$url","URL","url","toString","origin","workerUrl","isESM","location","source","JSON","stringify","createObjectURL","Blob","type","parse","$7lx9d","$RPVlj","$5Rd1x","$jiuw3","$c8CJQ","$8todg","$jAT47","$gcCUH","$boAbX","$445e06dac1d69dea$export$89d8017d8280911a","ShaderMaterial","params","uniforms","matrix","Matrix4","zValue","MeshBVHUniformStruct","vertexShader","fragmentShader","common_functions","bvh_struct_definitions","bvh_ray_functions","bvh_distance_functions","setValues","$2ff529b7be002585$export$9fb7e1e81432db6c","defines","DISPLAY_GRID","sdfTex","layer","layers","$2f2ddb336b460d2c$export$7518dfdc666d2802","MAX_STEPS","SURFACE_EPSILON","surface","normalStep","Vector3","projectionInverse","sdfTransformInverse","$kp7Te","$c345b227375090f6$var$params","gpuGeneration","resolution","margin","regenerate","$c345b227375090f6$var$updateSDF","mode","$c345b227375090f6$var$inverseBoundsMatrix","$c345b227375090f6$var$rebuildGUI","destroy","generationFolder","GUI","addFolder","add","displayFolder","onChange","dim","center","quat","Quaternion","scale","getCenter","subVectors","x","y","z","compose","copy","invert","box","pxWidth","halfWidth","startTime","floatLinearExtSupported","extensions","WebGL3DRenderTarget","texture","format","RedFormat","FloatType","HalfFloatType","minFilter","LinearFilter","magFilter","updateFrom","setRenderTarget","readRenderTargetPixels","Float32Array","Data3DTexture","needsUpdate","posAttr","indexAttr","point","normal","delta","tri","Triangle","target","applyMatrix4","dist","closestPointToPoint","distance","faceIndex","i0","getX","i1","i2","setFromAttributeAndIndices","getNormal","image","dot","innerText","toFixed","$c345b227375090f6$var$init","getElementById","WebGLRenderer","antialias","setPixelRatio","setSize","innerWidth","innerHeight","setClearColor","outputEncoding","sRGBEncoding","body","Scene","light","DirectionalLight","AmbientLight","PerspectiveCamera","far","updateProjectionMatrix","Box3Helper","OrbitControls","__esModule","default","FullScreenQuad","GenerateMeshBVHWorker","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","loadAsync","then","gltf","scene","updateMatrixWorld","staticGen","StaticGeometryGenerator","useGroups","maxLeafTris","result","MeshStandardMaterial","aspect","$c345b227375090f6$var$render","requestAnimationFrame","tex","isData3DTexture","gridMode","depth","projectionMatrixInverse","matrixWorld","premultiply","multiply"],"version":3,"file":"sdfGeneration.3e4cbe3a.js.map"}