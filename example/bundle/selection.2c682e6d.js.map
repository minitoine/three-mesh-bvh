{"mappings":"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","sources":["<anon>","node_modules/stats.js/build/stats.min.js","src/objects/MeshBVHHelper.js","example/selection.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4485\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4485\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"c8CJQ\", function(module, exports) {\n// stats.js - http://github.com/mrdoob/stats.js\n(function(f, e) {\n    module.exports = e();\n})(module.exports, function() {\n    var f = function() {\n        function e(a) {\n            c.appendChild(a.dom);\n            return a;\n        }\n        function u(a) {\n            for(var d = 0; d < c.children.length; d++)c.children[d].style.display = d === a ? \"block\" : \"none\";\n            l = a;\n        }\n        var l = 0, c = document.createElement(\"div\");\n        c.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n        c.addEventListener(\"click\", function(a) {\n            a.preventDefault();\n            u(++l % c.children.length);\n        }, !1);\n        var k = (performance || Date).now(), g = k, a = 0, r = e(new f.Panel(\"FPS\", \"#0ff\", \"#002\")), h = e(new f.Panel(\"MS\", \"#0f0\", \"#020\"));\n        if (self.performance && self.performance.memory) var t = e(new f.Panel(\"MB\", \"#f08\", \"#201\"));\n        u(0);\n        return {\n            REVISION: 16,\n            dom: c,\n            addPanel: e,\n            showPanel: u,\n            begin: function() {\n                k = (performance || Date).now();\n            },\n            end: function() {\n                a++;\n                var c = (performance || Date).now();\n                h.update(c - k, 200);\n                if (c > g + 1E3 && (r.update(1E3 * a / (c - g), 100), g = c, a = 0, t)) {\n                    var d = performance.memory;\n                    t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);\n                }\n                return c;\n            },\n            update: function() {\n                k = this.end();\n            },\n            domElement: c,\n            setMode: u\n        };\n    };\n    f.Panel = function(e, f, l) {\n        var c = Infinity, k = 0, g = Math.round, a = g(window.devicePixelRatio || 1), r = 80 * a, h = 48 * a, t = 3 * a, v = 2 * a, d = 3 * a, m = 15 * a, n = 74 * a, p = 30 * a, q = document.createElement(\"canvas\");\n        q.width = r;\n        q.height = h;\n        q.style.cssText = \"width:80px;height:48px\";\n        var b = q.getContext(\"2d\");\n        b.font = \"bold \" + 9 * a + \"px Helvetica,Arial,sans-serif\";\n        b.textBaseline = \"top\";\n        b.fillStyle = l;\n        b.fillRect(0, 0, r, h);\n        b.fillStyle = f;\n        b.fillText(e, t, v);\n        b.fillRect(d, m, n, p);\n        b.fillStyle = l;\n        b.globalAlpha = .9;\n        b.fillRect(d, m, n, p);\n        return {\n            dom: q,\n            update: function(h, w) {\n                c = Math.min(c, h);\n                k = Math.max(k, h);\n                b.fillStyle = l;\n                b.globalAlpha = 1;\n                b.fillRect(0, 0, r, m);\n                b.fillStyle = f;\n                b.fillText(g(h) + \" \" + e + \" (\" + g(c) + \"-\" + g(k) + \")\", t, v);\n                b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);\n                b.fillRect(d + n - a, m, a, p);\n                b.fillStyle = l;\n                b.globalAlpha = .9;\n                b.fillRect(d + n - a, m, a, g((1 - h / w) * p));\n            }\n        };\n    };\n    return f;\n});\n\n});\n\nparcelRegister(\"5ca9G\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshBVHHelper\", () => $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $aw71y = parcelRequire(\"aw71y\");\n\nvar $ff8ed = parcelRequire(\"ff8ed\");\nconst $3c85f35a8c29fa9b$var$boundingBox = /* @__PURE__ */ new (0, $ilwiq.Box3)();\nclass $3c85f35a8c29fa9b$var$MeshBVHRootHelper extends (0, $ilwiq.Object3D) {\n    get isMesh() {\n        return !this.displayEdges;\n    }\n    get isLineSegments() {\n        return this.displayEdges;\n    }\n    get isLine() {\n        return this.displayEdges;\n    }\n    constructor(bvh, material, depth = 10, group = 0){\n        super();\n        this.material = material;\n        this.geometry = new (0, $ilwiq.BufferGeometry)();\n        this.name = \"MeshBVHRootHelper\";\n        this.depth = depth;\n        this.displayParents = false;\n        this.bvh = bvh;\n        this.displayEdges = true;\n        this._group = group;\n    }\n    raycast() {}\n    update() {\n        const geometry = this.geometry;\n        const boundsTree = this.bvh;\n        const group = this._group;\n        geometry.dispose();\n        this.visible = false;\n        if (boundsTree) {\n            // count the number of bounds required\n            const targetDepth = this.depth - 1;\n            const displayParents = this.displayParents;\n            let boundsCount = 0;\n            boundsTree.traverse((depth, isLeaf)=>{\n                if (depth >= targetDepth || isLeaf) {\n                    boundsCount++;\n                    return true;\n                } else if (displayParents) boundsCount++;\n            }, group);\n            // fill in the position buffer with the bounds corners\n            let posIndex = 0;\n            const positionArray = new Float32Array(24 * boundsCount);\n            boundsTree.traverse((depth, isLeaf, boundingData)=>{\n                const terminate = depth >= targetDepth || isLeaf;\n                if (terminate || displayParents) {\n                    (0, $aw71y.arrayToBox)(0, boundingData, $3c85f35a8c29fa9b$var$boundingBox);\n                    const { min: min, max: max } = $3c85f35a8c29fa9b$var$boundingBox;\n                    for(let x = -1; x <= 1; x += 2){\n                        const xVal = x < 0 ? min.x : max.x;\n                        for(let y = -1; y <= 1; y += 2){\n                            const yVal = y < 0 ? min.y : max.y;\n                            for(let z = -1; z <= 1; z += 2){\n                                const zVal = z < 0 ? min.z : max.z;\n                                positionArray[posIndex + 0] = xVal;\n                                positionArray[posIndex + 1] = yVal;\n                                positionArray[posIndex + 2] = zVal;\n                                posIndex += 3;\n                            }\n                        }\n                    }\n                    return terminate;\n                }\n            }, group);\n            let indexArray;\n            let indices;\n            if (this.displayEdges) // fill in the index buffer to point to the corner points\n            indices = new Uint8Array([\n                // x axis\n                0,\n                4,\n                1,\n                5,\n                2,\n                6,\n                3,\n                7,\n                // y axis\n                0,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                7,\n                // z axis\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7\n            ]);\n            else indices = new Uint8Array([\n                // X-, X+\n                0,\n                1,\n                2,\n                2,\n                1,\n                3,\n                4,\n                6,\n                5,\n                6,\n                7,\n                5,\n                // Y-, Y+\n                1,\n                4,\n                5,\n                0,\n                4,\n                1,\n                2,\n                3,\n                6,\n                3,\n                7,\n                6,\n                // Z-, Z+\n                0,\n                2,\n                4,\n                2,\n                6,\n                4,\n                1,\n                5,\n                3,\n                3,\n                5,\n                7\n            ]);\n            if (positionArray.length > 65535) indexArray = new Uint32Array(indices.length * boundsCount);\n            else indexArray = new Uint16Array(indices.length * boundsCount);\n            const indexLength = indices.length;\n            for(let i = 0; i < boundsCount; i++){\n                const posOffset = i * 8;\n                const indexOffset = i * indexLength;\n                for(let j = 0; j < indexLength; j++)indexArray[indexOffset + j] = posOffset + indices[j];\n            }\n            // update the geometry\n            geometry.setIndex(new (0, $ilwiq.BufferAttribute)(indexArray, 1, false));\n            geometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(positionArray, 3, false));\n            this.visible = true;\n        }\n    }\n}\nclass $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 extends (0, $ilwiq.Group) {\n    get color() {\n        return this.edgeMaterial.color;\n    }\n    get opacity() {\n        return this.edgeMaterial.opacity;\n    }\n    set opacity(v) {\n        this.edgeMaterial.opacity = v;\n        this.meshMaterial.opacity = v;\n    }\n    constructor(mesh = null, bvh = null, depth = 10){\n        // handle bvh, depth signature\n        if (mesh instanceof (0, $ff8ed.MeshBVH)) {\n            depth = bvh || 10;\n            bvh = mesh;\n            mesh = null;\n        }\n        // handle mesh, depth signature\n        if (typeof bvh === \"number\") {\n            depth = bvh;\n            bvh = null;\n        }\n        super();\n        this.name = \"MeshBVHHelper\";\n        this.depth = depth;\n        this.mesh = mesh;\n        this.bvh = bvh;\n        this.displayParents = false;\n        this.displayEdges = true;\n        this._roots = [];\n        const edgeMaterial = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        const meshMaterial = new (0, $ilwiq.MeshBasicMaterial)({\n            color: 0x00FF88,\n            transparent: true,\n            opacity: 0.3,\n            depthWrite: false\n        });\n        meshMaterial.color = edgeMaterial.color;\n        this.edgeMaterial = edgeMaterial;\n        this.meshMaterial = meshMaterial;\n        this.update();\n    }\n    update() {\n        const bvh = this.bvh || this.mesh.geometry.boundsTree;\n        const totalRoots = bvh ? bvh._roots.length : 0;\n        while(this._roots.length > totalRoots){\n            const root = this._roots.pop();\n            root.geometry.dispose();\n            this.remove(root);\n        }\n        for(let i = 0; i < totalRoots; i++){\n            const { depth: depth, edgeMaterial: edgeMaterial, meshMaterial: meshMaterial, displayParents: displayParents, displayEdges: displayEdges } = this;\n            if (i >= this._roots.length) {\n                const root = new $3c85f35a8c29fa9b$var$MeshBVHRootHelper(bvh, edgeMaterial, depth, i);\n                this.add(root);\n                this._roots.push(root);\n            }\n            const root = this._roots[i];\n            root.bvh = bvh;\n            root.depth = depth;\n            root.displayParents = displayParents;\n            root.displayEdges = displayEdges;\n            root.material = displayEdges ? edgeMaterial : meshMaterial;\n            root.update();\n        }\n    }\n    updateMatrixWorld(...args) {\n        const mesh = this.mesh;\n        const parent = this.parent;\n        if (mesh !== null) {\n            mesh.updateWorldMatrix(true, false);\n            if (parent) this.matrix.copy(parent.matrixWorld).invert().multiply(mesh.matrixWorld);\n            else this.matrix.copy(mesh.matrixWorld);\n            this.matrix.decompose(this.position, this.quaternion, this.scale);\n        }\n        super.updateMatrixWorld(...args);\n    }\n    copy(source) {\n        this.depth = source.depth;\n        this.mesh = source.mesh;\n        this.bvh = source.bvh;\n        this.opacity = source.opacity;\n        this.color.copy(source.color);\n    }\n    clone() {\n        return new $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5(this.mesh, this.bvh, this.depth);\n    }\n    dispose() {\n        this.edgeMaterial.dispose();\n        this.meshMaterial.dispose();\n        const children = this.children;\n        for(let i = 0, l = children.length; i < l; i++)children[i].geometry.dispose();\n    }\n}\nclass $3c85f35a8c29fa9b$export$5ead38ed5c75a1c8 extends $3c85f35a8c29fa9b$export$e57d74bcb7e3bec5 {\n    constructor(...args){\n        super(...args);\n        console.warn(\"MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.\");\n    }\n}\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $c8CJQ = parcelRequire(\"c8CJQ\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $Mleu6 = parcelRequire(\"Mleu6\");\nvar $ff8ed = parcelRequire(\"ff8ed\");\nvar $5ca9G = parcelRequire(\"5ca9G\");\nconst $cdfe6782841c53e7$var$params = {\n    toolMode: \"lasso\",\n    selectionMode: \"intersection\",\n    liveUpdate: false,\n    selectModel: false,\n    wireframe: false,\n    useBoundsTree: true,\n    displayHelper: false,\n    helperDepth: 10,\n    rotate: true\n};\nlet $cdfe6782841c53e7$var$renderer, $cdfe6782841c53e7$var$camera, $cdfe6782841c53e7$var$scene, $cdfe6782841c53e7$var$gui, $cdfe6782841c53e7$var$stats, $cdfe6782841c53e7$var$controls, $cdfe6782841c53e7$var$selectionShape, $cdfe6782841c53e7$var$mesh, $cdfe6782841c53e7$var$helper;\nlet $cdfe6782841c53e7$var$highlightMesh, $cdfe6782841c53e7$var$highlightWireframeMesh, $cdfe6782841c53e7$var$outputContainer, $cdfe6782841c53e7$var$group;\nconst $cdfe6782841c53e7$var$selectionPoints = [];\nlet $cdfe6782841c53e7$var$dragging = false;\nlet $cdfe6782841c53e7$var$selectionShapeNeedsUpdate = false;\nlet $cdfe6782841c53e7$var$selectionNeedsUpdate = false;\n$cdfe6782841c53e7$var$init();\n$cdfe6782841c53e7$var$render();\nfunction $cdfe6782841c53e7$var$init() {\n    $cdfe6782841c53e7$var$outputContainer = document.getElementById(\"output\");\n    const bgColor = new $ilwiq.Color(0x263238);\n    // renderer setup\n    $cdfe6782841c53e7$var$renderer = new $ilwiq.WebGLRenderer({\n        antialias: true\n    });\n    $cdfe6782841c53e7$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $cdfe6782841c53e7$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $cdfe6782841c53e7$var$renderer.setClearColor(bgColor, 1);\n    $cdfe6782841c53e7$var$renderer.shadowMap.enabled = true;\n    $cdfe6782841c53e7$var$renderer.outputEncoding = $ilwiq.sRGBEncoding;\n    document.body.appendChild($cdfe6782841c53e7$var$renderer.domElement);\n    // scene setup\n    $cdfe6782841c53e7$var$scene = new $ilwiq.Scene();\n    const light = new $ilwiq.DirectionalLight(0xffffff, 1);\n    light.castShadow = true;\n    light.shadow.mapSize.set(2048, 2048);\n    light.position.set(10, 10, 10);\n    $cdfe6782841c53e7$var$scene.add(light);\n    $cdfe6782841c53e7$var$scene.add(new $ilwiq.AmbientLight(0xb0bec5, 0.8));\n    // camera setup\n    $cdfe6782841c53e7$var$camera = new $ilwiq.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);\n    $cdfe6782841c53e7$var$camera.position.set(2, 4, 6);\n    $cdfe6782841c53e7$var$camera.far = 100;\n    $cdfe6782841c53e7$var$camera.updateProjectionMatrix();\n    $cdfe6782841c53e7$var$scene.add($cdfe6782841c53e7$var$camera);\n    // selection shape\n    $cdfe6782841c53e7$var$selectionShape = new $ilwiq.Line();\n    $cdfe6782841c53e7$var$selectionShape.material.color.set(0xff9800).convertSRGBToLinear();\n    $cdfe6782841c53e7$var$selectionShape.renderOrder = 1;\n    $cdfe6782841c53e7$var$selectionShape.position.z = -0.2;\n    $cdfe6782841c53e7$var$selectionShape.depthTest = false;\n    $cdfe6782841c53e7$var$selectionShape.scale.setScalar(1);\n    $cdfe6782841c53e7$var$camera.add($cdfe6782841c53e7$var$selectionShape);\n    // group for rotation\n    $cdfe6782841c53e7$var$group = new $ilwiq.Group();\n    $cdfe6782841c53e7$var$scene.add($cdfe6782841c53e7$var$group);\n    // base mesh\n    $cdfe6782841c53e7$var$mesh = new $ilwiq.Mesh(new $ilwiq.TorusKnotGeometry(1.5, 0.5, 500, 60).toNonIndexed(), new $ilwiq.MeshStandardMaterial({\n        polygonOffset: true,\n        polygonOffsetFactor: 1\n    }));\n    $cdfe6782841c53e7$var$mesh.geometry.boundsTree = new (0, $ff8ed.MeshBVH)($cdfe6782841c53e7$var$mesh.geometry);\n    $cdfe6782841c53e7$var$mesh.geometry.setAttribute(\"color\", new $ilwiq.Uint8BufferAttribute(new Array($cdfe6782841c53e7$var$mesh.geometry.index.count * 3).fill(255), 3, true));\n    $cdfe6782841c53e7$var$mesh.castShadow = true;\n    $cdfe6782841c53e7$var$mesh.receiveShadow = true;\n    $cdfe6782841c53e7$var$group.add($cdfe6782841c53e7$var$mesh);\n    $cdfe6782841c53e7$var$helper = new (0, $5ca9G.MeshBVHHelper)($cdfe6782841c53e7$var$mesh, 10);\n    $cdfe6782841c53e7$var$group.add($cdfe6782841c53e7$var$helper);\n    // meshes for selection highlights\n    $cdfe6782841c53e7$var$highlightMesh = new $ilwiq.Mesh();\n    $cdfe6782841c53e7$var$highlightMesh.geometry = $cdfe6782841c53e7$var$mesh.geometry.clone();\n    $cdfe6782841c53e7$var$highlightMesh.geometry.drawRange.count = 0;\n    $cdfe6782841c53e7$var$highlightMesh.material = new $ilwiq.MeshBasicMaterial({\n        opacity: 0.05,\n        transparent: true,\n        depthWrite: false\n    });\n    $cdfe6782841c53e7$var$highlightMesh.material.color.set(0xff9800).convertSRGBToLinear();\n    $cdfe6782841c53e7$var$highlightMesh.renderOrder = 1;\n    $cdfe6782841c53e7$var$group.add($cdfe6782841c53e7$var$highlightMesh);\n    $cdfe6782841c53e7$var$highlightWireframeMesh = new $ilwiq.Mesh();\n    $cdfe6782841c53e7$var$highlightWireframeMesh.geometry = $cdfe6782841c53e7$var$highlightMesh.geometry;\n    $cdfe6782841c53e7$var$highlightWireframeMesh.material = new $ilwiq.MeshBasicMaterial({\n        opacity: 0.25,\n        transparent: true,\n        wireframe: true,\n        depthWrite: false\n    });\n    $cdfe6782841c53e7$var$highlightWireframeMesh.material.color.copy($cdfe6782841c53e7$var$highlightMesh.material.color);\n    $cdfe6782841c53e7$var$highlightWireframeMesh.renderOrder = 2;\n    $cdfe6782841c53e7$var$group.add($cdfe6782841c53e7$var$highlightWireframeMesh);\n    // add floor\n    const gridHelper = new $ilwiq.GridHelper(10, 10, 0xffffff, 0xffffff);\n    gridHelper.material.opacity = 0.2;\n    gridHelper.material.transparent = true;\n    gridHelper.position.y = -2.75;\n    $cdfe6782841c53e7$var$scene.add(gridHelper);\n    const shadowPlane = new $ilwiq.Mesh(new $ilwiq.PlaneBufferGeometry(), new $ilwiq.ShadowMaterial({\n        color: 0,\n        opacity: 0.2,\n        depthWrite: false\n    }));\n    shadowPlane.position.y = -2.74;\n    shadowPlane.rotation.x = -Math.PI / 2;\n    shadowPlane.scale.setScalar(20);\n    shadowPlane.renderOrder = 2;\n    shadowPlane.receiveShadow = true;\n    $cdfe6782841c53e7$var$scene.add(shadowPlane);\n    // stats setup\n    $cdfe6782841c53e7$var$stats = new (0, (/*@__PURE__*/$parcel$interopDefault($c8CJQ)))();\n    document.body.appendChild($cdfe6782841c53e7$var$stats.dom);\n    // controls\n    $cdfe6782841c53e7$var$controls = new (0, $5Rd1x.OrbitControls)($cdfe6782841c53e7$var$camera, $cdfe6782841c53e7$var$renderer.domElement);\n    $cdfe6782841c53e7$var$controls.minDistance = 3;\n    $cdfe6782841c53e7$var$controls.touches.ONE = $ilwiq.TOUCH.PAN;\n    $cdfe6782841c53e7$var$controls.mouseButtons.LEFT = $ilwiq.MOUSE.PAN;\n    $cdfe6782841c53e7$var$controls.touches.TWO = $ilwiq.TOUCH.ROTATE;\n    $cdfe6782841c53e7$var$controls.mouseButtons.RIGHT = $ilwiq.MOUSE.ROTATE;\n    $cdfe6782841c53e7$var$controls.enablePan = false;\n    // gui\n    $cdfe6782841c53e7$var$gui = new (0, $jiuw3.GUI)();\n    const selectionFolder = $cdfe6782841c53e7$var$gui.addFolder(\"selection\");\n    selectionFolder.add($cdfe6782841c53e7$var$params, \"toolMode\", [\n        \"lasso\",\n        \"box\"\n    ]);\n    selectionFolder.add($cdfe6782841c53e7$var$params, \"selectionMode\", [\n        \"centroid\",\n        \"centroid-visible\",\n        \"intersection\"\n    ]);\n    selectionFolder.add($cdfe6782841c53e7$var$params, \"selectModel\");\n    selectionFolder.add($cdfe6782841c53e7$var$params, \"liveUpdate\");\n    selectionFolder.add($cdfe6782841c53e7$var$params, \"useBoundsTree\");\n    selectionFolder.open();\n    const displayFolder = $cdfe6782841c53e7$var$gui.addFolder(\"display\");\n    displayFolder.add($cdfe6782841c53e7$var$params, \"wireframe\");\n    displayFolder.add($cdfe6782841c53e7$var$params, \"rotate\");\n    displayFolder.add($cdfe6782841c53e7$var$params, \"displayHelper\");\n    displayFolder.add($cdfe6782841c53e7$var$params, \"helperDepth\", 1, 30, 1).onChange((v)=>{\n        $cdfe6782841c53e7$var$helper.depth = v;\n        $cdfe6782841c53e7$var$helper.update();\n    });\n    displayFolder.open();\n    $cdfe6782841c53e7$var$gui.open();\n    // handle building lasso shape\n    let startX = -Infinity;\n    let startY = -Infinity;\n    let prevX = -Infinity;\n    let prevY = -Infinity;\n    const tempVec0 = new $ilwiq.Vector2();\n    const tempVec1 = new $ilwiq.Vector2();\n    const tempVec2 = new $ilwiq.Vector2();\n    $cdfe6782841c53e7$var$renderer.domElement.addEventListener(\"pointerdown\", (e)=>{\n        prevX = e.clientX;\n        prevY = e.clientY;\n        startX = e.clientX / window.innerWidth * 2 - 1;\n        startY = -(e.clientY / window.innerHeight * 2 - 1);\n        $cdfe6782841c53e7$var$selectionPoints.length = 0;\n        $cdfe6782841c53e7$var$dragging = true;\n    });\n    $cdfe6782841c53e7$var$renderer.domElement.addEventListener(\"pointerup\", ()=>{\n        $cdfe6782841c53e7$var$selectionShape.visible = false;\n        $cdfe6782841c53e7$var$dragging = false;\n        if ($cdfe6782841c53e7$var$selectionPoints.length) $cdfe6782841c53e7$var$selectionNeedsUpdate = true;\n    });\n    $cdfe6782841c53e7$var$renderer.domElement.addEventListener(\"pointermove\", (e)=>{\n        // If the left mouse button is not pressed\n        if ((1 & e.buttons) === 0) return;\n        const ex = e.clientX;\n        const ey = e.clientY;\n        const nx = e.clientX / window.innerWidth * 2 - 1;\n        const ny = -(e.clientY / window.innerHeight * 2 - 1);\n        if ($cdfe6782841c53e7$var$params.toolMode === \"box\") {\n            // set points for the corner of the box\n            $cdfe6782841c53e7$var$selectionPoints.length = 15;\n            $cdfe6782841c53e7$var$selectionPoints[0] = startX;\n            $cdfe6782841c53e7$var$selectionPoints[1] = startY;\n            $cdfe6782841c53e7$var$selectionPoints[2] = 0;\n            $cdfe6782841c53e7$var$selectionPoints[3] = nx;\n            $cdfe6782841c53e7$var$selectionPoints[4] = startY;\n            $cdfe6782841c53e7$var$selectionPoints[5] = 0;\n            $cdfe6782841c53e7$var$selectionPoints[6] = nx;\n            $cdfe6782841c53e7$var$selectionPoints[7] = ny;\n            $cdfe6782841c53e7$var$selectionPoints[8] = 0;\n            $cdfe6782841c53e7$var$selectionPoints[9] = startX;\n            $cdfe6782841c53e7$var$selectionPoints[10] = ny;\n            $cdfe6782841c53e7$var$selectionPoints[11] = 0;\n            $cdfe6782841c53e7$var$selectionPoints[12] = startX;\n            $cdfe6782841c53e7$var$selectionPoints[13] = startY;\n            $cdfe6782841c53e7$var$selectionPoints[14] = 0;\n            if (ex !== prevX || ey !== prevY) $cdfe6782841c53e7$var$selectionShapeNeedsUpdate = true;\n            prevX = ex;\n            prevY = ey;\n            $cdfe6782841c53e7$var$selectionShape.visible = true;\n            if ($cdfe6782841c53e7$var$params.liveUpdate) $cdfe6782841c53e7$var$selectionNeedsUpdate = true;\n        } else // If the mouse hasn't moved a lot since the last point\n        if (Math.abs(ex - prevX) >= 3 || Math.abs(ey - prevY) >= 3) {\n            // Check if the mouse moved in roughly the same direction as the previous point\n            // and replace it if so.\n            const i = $cdfe6782841c53e7$var$selectionPoints.length / 3 - 1;\n            const i3 = i * 3;\n            let doReplace = false;\n            if ($cdfe6782841c53e7$var$selectionPoints.length > 3) {\n                // prev segment direction\n                tempVec0.set($cdfe6782841c53e7$var$selectionPoints[i3 - 3], $cdfe6782841c53e7$var$selectionPoints[i3 - 3 + 1]);\n                tempVec1.set($cdfe6782841c53e7$var$selectionPoints[i3], $cdfe6782841c53e7$var$selectionPoints[i3 + 1]);\n                tempVec1.sub(tempVec0).normalize();\n                // this segment direction\n                tempVec0.set($cdfe6782841c53e7$var$selectionPoints[i3], $cdfe6782841c53e7$var$selectionPoints[i3 + 1]);\n                tempVec2.set(nx, ny);\n                tempVec2.sub(tempVec0).normalize();\n                const dot = tempVec1.dot(tempVec2);\n                doReplace = dot > 0.99;\n            }\n            if (doReplace) {\n                $cdfe6782841c53e7$var$selectionPoints[i3] = nx;\n                $cdfe6782841c53e7$var$selectionPoints[i3 + 1] = ny;\n            } else $cdfe6782841c53e7$var$selectionPoints.push(nx, ny, 0);\n            $cdfe6782841c53e7$var$selectionShapeNeedsUpdate = true;\n            $cdfe6782841c53e7$var$selectionShape.visible = true;\n            prevX = ex;\n            prevY = ey;\n            if ($cdfe6782841c53e7$var$params.liveUpdate) $cdfe6782841c53e7$var$selectionNeedsUpdate = true;\n        }\n    });\n    window.addEventListener(\"resize\", function() {\n        $cdfe6782841c53e7$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $cdfe6782841c53e7$var$camera.updateProjectionMatrix();\n        $cdfe6782841c53e7$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    }, false);\n}\nfunction $cdfe6782841c53e7$var$render() {\n    $cdfe6782841c53e7$var$stats.update();\n    requestAnimationFrame($cdfe6782841c53e7$var$render);\n    $cdfe6782841c53e7$var$mesh.material.wireframe = $cdfe6782841c53e7$var$params.wireframe;\n    $cdfe6782841c53e7$var$helper.visible = $cdfe6782841c53e7$var$params.displayHelper;\n    // Update the selection lasso lines\n    if ($cdfe6782841c53e7$var$selectionShapeNeedsUpdate) {\n        if ($cdfe6782841c53e7$var$params.toolMode === \"lasso\") {\n            const ogLength = $cdfe6782841c53e7$var$selectionPoints.length;\n            $cdfe6782841c53e7$var$selectionPoints.push($cdfe6782841c53e7$var$selectionPoints[0], $cdfe6782841c53e7$var$selectionPoints[1], $cdfe6782841c53e7$var$selectionPoints[2]);\n            $cdfe6782841c53e7$var$selectionShape.geometry.setAttribute(\"position\", new $ilwiq.Float32BufferAttribute($cdfe6782841c53e7$var$selectionPoints, 3, false));\n            $cdfe6782841c53e7$var$selectionPoints.length = ogLength;\n        } else $cdfe6782841c53e7$var$selectionShape.geometry.setAttribute(\"position\", new $ilwiq.Float32BufferAttribute($cdfe6782841c53e7$var$selectionPoints, 3, false));\n        $cdfe6782841c53e7$var$selectionShape.frustumCulled = false;\n        $cdfe6782841c53e7$var$selectionShapeNeedsUpdate = false;\n    }\n    if ($cdfe6782841c53e7$var$selectionNeedsUpdate) {\n        $cdfe6782841c53e7$var$selectionNeedsUpdate = false;\n        if ($cdfe6782841c53e7$var$selectionPoints.length > 0) $cdfe6782841c53e7$var$updateSelection();\n    }\n    const yScale = Math.tan($ilwiq.MathUtils.DEG2RAD * $cdfe6782841c53e7$var$camera.fov / 2) * $cdfe6782841c53e7$var$selectionShape.position.z;\n    $cdfe6782841c53e7$var$selectionShape.scale.set(-yScale * $cdfe6782841c53e7$var$camera.aspect, -yScale, 1);\n    $cdfe6782841c53e7$var$renderer.render($cdfe6782841c53e7$var$scene, $cdfe6782841c53e7$var$camera);\n    if ($cdfe6782841c53e7$var$params.rotate) {\n        $cdfe6782841c53e7$var$group.rotation.y += 0.01;\n        if ($cdfe6782841c53e7$var$params.liveUpdate && $cdfe6782841c53e7$var$dragging) $cdfe6782841c53e7$var$selectionNeedsUpdate = true;\n    }\n}\nconst $cdfe6782841c53e7$var$invWorldMatrix = new $ilwiq.Matrix4();\nconst $cdfe6782841c53e7$var$camLocalPosition = new $ilwiq.Vector3();\nconst $cdfe6782841c53e7$var$tempRay = new $ilwiq.Ray();\nconst $cdfe6782841c53e7$var$centroid = new $ilwiq.Vector3();\nconst $cdfe6782841c53e7$var$screenCentroid = new $ilwiq.Vector3();\nconst $cdfe6782841c53e7$var$faceNormal = new $ilwiq.Vector3();\nconst $cdfe6782841c53e7$var$toScreenSpaceMatrix = new $ilwiq.Matrix4();\nconst $cdfe6782841c53e7$var$boxPoints = new Array(8).fill().map(()=>new $ilwiq.Vector3());\nconst $cdfe6782841c53e7$var$boxLines = new Array(12).fill().map(()=>new $ilwiq.Line3());\nconst $cdfe6782841c53e7$var$lassoSegments = [];\nconst $cdfe6782841c53e7$var$perBoundsSegments = [];\nfunction $cdfe6782841c53e7$var$updateSelection() {\n    // TODO: Possible improvements\n    // - Correctly handle the camera near clip\n    // - Improve line line intersect performance?\n    $cdfe6782841c53e7$var$toScreenSpaceMatrix.copy($cdfe6782841c53e7$var$mesh.matrixWorld).premultiply($cdfe6782841c53e7$var$camera.matrixWorldInverse).premultiply($cdfe6782841c53e7$var$camera.projectionMatrix);\n    // create scratch points and lines to use for selection\n    while($cdfe6782841c53e7$var$lassoSegments.length < $cdfe6782841c53e7$var$selectionPoints.length)$cdfe6782841c53e7$var$lassoSegments.push(new $ilwiq.Line3());\n    $cdfe6782841c53e7$var$lassoSegments.length = $cdfe6782841c53e7$var$selectionPoints.length;\n    for(let s = 0, l = $cdfe6782841c53e7$var$selectionPoints.length; s < l; s += 3){\n        const line = $cdfe6782841c53e7$var$lassoSegments[s];\n        const sNext = (s + 3) % l;\n        line.start.x = $cdfe6782841c53e7$var$selectionPoints[s];\n        line.start.y = $cdfe6782841c53e7$var$selectionPoints[s + 1];\n        line.end.x = $cdfe6782841c53e7$var$selectionPoints[sNext];\n        line.end.y = $cdfe6782841c53e7$var$selectionPoints[sNext + 1];\n    }\n    $cdfe6782841c53e7$var$invWorldMatrix.copy($cdfe6782841c53e7$var$mesh.matrixWorld).invert();\n    $cdfe6782841c53e7$var$camLocalPosition.set(0, 0, 0).applyMatrix4($cdfe6782841c53e7$var$camera.matrixWorld).applyMatrix4($cdfe6782841c53e7$var$invWorldMatrix);\n    const startTime = window.performance.now();\n    const indices = [];\n    $cdfe6782841c53e7$var$mesh.geometry.boundsTree.shapecast({\n        intersectsBounds: (box, isLeaf, score, depth)=>{\n            // check if bounds intersect or contain the lasso region\n            if (!$cdfe6782841c53e7$var$params.useBoundsTree) return 0, $Mleu6.INTERSECTED;\n            // Get the bounding box points\n            const { min: min, max: max } = box;\n            let index = 0;\n            let minY = Infinity;\n            let maxY = -Infinity;\n            let minX = Infinity;\n            for(let x = 0; x <= 1; x++){\n                for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                    const v = $cdfe6782841c53e7$var$boxPoints[index];\n                    v.x = x === 0 ? min.x : max.x;\n                    v.y = y === 0 ? min.y : max.y;\n                    v.z = z === 0 ? min.z : max.z;\n                    v.w = 1;\n                    v.applyMatrix4($cdfe6782841c53e7$var$toScreenSpaceMatrix);\n                    index++;\n                    if (v.y < minY) minY = v.y;\n                    if (v.y > maxY) maxY = v.y;\n                    if (v.x < minX) minX = v.x;\n                }\n            }\n            // Find all the relevant segments here and cache them in the above array for\n            // subsequent child checks to use.\n            const parentSegments = $cdfe6782841c53e7$var$perBoundsSegments[depth - 1] || $cdfe6782841c53e7$var$lassoSegments;\n            const segmentsToCheck = $cdfe6782841c53e7$var$perBoundsSegments[depth] || [];\n            segmentsToCheck.length = 0;\n            $cdfe6782841c53e7$var$perBoundsSegments[depth] = segmentsToCheck;\n            for(let i = 0, l = parentSegments.length; i < l; i++){\n                const line = parentSegments[i];\n                const sx = line.start.x;\n                const sy = line.start.y;\n                const ex = line.end.x;\n                const ey = line.end.y;\n                if (sx < minX && ex < minX) continue;\n                const startAbove = sy > maxY;\n                const endAbove = ey > maxY;\n                if (startAbove && endAbove) continue;\n                const startBelow = sy < minY;\n                const endBelow = ey < minY;\n                if (startBelow && endBelow) continue;\n                segmentsToCheck.push(line);\n            }\n            if (segmentsToCheck.length === 0) return 0, $Mleu6.NOT_INTERSECTED;\n            // Get the screen space hull lines\n            const hull = $cdfe6782841c53e7$var$getConvexHull($cdfe6782841c53e7$var$boxPoints);\n            const lines = hull.map((p, i)=>{\n                const nextP = hull[(i + 1) % hull.length];\n                const line = $cdfe6782841c53e7$var$boxLines[i];\n                line.start.copy(p);\n                line.end.copy(nextP);\n                return line;\n            });\n            // If a lasso point is inside the hull then it's intersected and cannot be contained\n            if ($cdfe6782841c53e7$var$pointRayCrossesSegments(segmentsToCheck[0].start, lines) % 2 === 1) return 0, $Mleu6.INTERSECTED;\n            // check if the screen space hull is in the lasso\n            let crossings = 0;\n            for(let i = 0, l = hull.length; i < l; i++){\n                const v = hull[i];\n                const pCrossings = $cdfe6782841c53e7$var$pointRayCrossesSegments(v, segmentsToCheck);\n                if (i === 0) crossings = pCrossings;\n                // if two points on the hull have different amounts of crossings then\n                // it can only be intersected\n                if (crossings !== pCrossings) return 0, $Mleu6.INTERSECTED;\n            }\n            // check if there are any intersections\n            for(let i = 0, l = lines.length; i < l; i++){\n                const boxLine = lines[i];\n                for(let s = 0, ls = segmentsToCheck.length; s < ls; s++){\n                    if ($cdfe6782841c53e7$var$lineCrossesLine(boxLine, segmentsToCheck[s])) return 0, $Mleu6.INTERSECTED;\n                }\n            }\n            return crossings % 2 === 0 ? (0, $Mleu6.NOT_INTERSECTED) : (0, $Mleu6.CONTAINED);\n        },\n        intersectsTriangle: (tri, index, contained, depth)=>{\n            const i3 = index * 3;\n            const a = i3 + 0;\n            const b = i3 + 1;\n            const c = i3 + 2;\n            // check all the segments if using no bounds tree\n            const segmentsToCheck = $cdfe6782841c53e7$var$params.useBoundsTree ? $cdfe6782841c53e7$var$perBoundsSegments[depth] : $cdfe6782841c53e7$var$lassoSegments;\n            if ($cdfe6782841c53e7$var$params.selectionMode === \"centroid\" || $cdfe6782841c53e7$var$params.selectionMode === \"centroid-visible\") {\n                // get the center of the triangle\n                $cdfe6782841c53e7$var$centroid.copy(tri.a).add(tri.b).add(tri.c).multiplyScalar(1 / 3);\n                $cdfe6782841c53e7$var$screenCentroid.copy($cdfe6782841c53e7$var$centroid).applyMatrix4($cdfe6782841c53e7$var$toScreenSpaceMatrix);\n                // counting the crossings\n                if (contained || $cdfe6782841c53e7$var$pointRayCrossesSegments($cdfe6782841c53e7$var$screenCentroid, segmentsToCheck) % 2 === 1) {\n                    // if we're only selecting visible faces then perform a ray check to ensure the centroid\n                    // is visible.\n                    if ($cdfe6782841c53e7$var$params.selectionMode === \"centroid-visible\") {\n                        tri.getNormal($cdfe6782841c53e7$var$faceNormal);\n                        $cdfe6782841c53e7$var$tempRay.origin.copy($cdfe6782841c53e7$var$centroid).addScaledVector($cdfe6782841c53e7$var$faceNormal, 1e-6);\n                        $cdfe6782841c53e7$var$tempRay.direction.subVectors($cdfe6782841c53e7$var$camLocalPosition, $cdfe6782841c53e7$var$centroid);\n                        const res = $cdfe6782841c53e7$var$mesh.geometry.boundsTree.raycastFirst($cdfe6782841c53e7$var$tempRay, $ilwiq.DoubleSide);\n                        if (res) return false;\n                    }\n                    indices.push(a, b, c);\n                    return $cdfe6782841c53e7$var$params.selectModel;\n                }\n            } else if ($cdfe6782841c53e7$var$params.selectionMode === \"intersection\") {\n                // if the parent bounds were marked as contained then we contain all the triangles within\n                if (contained) {\n                    indices.push(a, b, c);\n                    return $cdfe6782841c53e7$var$params.selectModel;\n                }\n                // get the projected vertices\n                const vertices = [\n                    tri.a,\n                    tri.b,\n                    tri.c\n                ];\n                // check if any of the vertices are inside the selection and if so then the triangle is selected\n                for(let j = 0; j < 3; j++){\n                    const v = vertices[j];\n                    v.applyMatrix4($cdfe6782841c53e7$var$toScreenSpaceMatrix);\n                    const crossings = $cdfe6782841c53e7$var$pointRayCrossesSegments(v, segmentsToCheck);\n                    if (crossings % 2 === 1) {\n                        indices.push(a, b, c);\n                        return $cdfe6782841c53e7$var$params.selectModel;\n                    }\n                }\n                // get the lines for the triangle\n                const lines = [\n                    $cdfe6782841c53e7$var$boxLines[0],\n                    $cdfe6782841c53e7$var$boxLines[1],\n                    $cdfe6782841c53e7$var$boxLines[2]\n                ];\n                lines[0].start.copy(tri.a);\n                lines[0].end.copy(tri.b);\n                lines[1].start.copy(tri.b);\n                lines[1].end.copy(tri.c);\n                lines[2].start.copy(tri.c);\n                lines[2].end.copy(tri.a);\n                // check for the case where a selection intersects a triangle but does not contain any\n                // of the vertices\n                for(let i = 0; i < 3; i++){\n                    const l = lines[i];\n                    for(let s = 0, sl = segmentsToCheck.length; s < sl; s++)if ($cdfe6782841c53e7$var$lineCrossesLine(l, segmentsToCheck[s])) {\n                        indices.push(a, b, c);\n                        return $cdfe6782841c53e7$var$params.selectModel;\n                    }\n                }\n            }\n            return false;\n        }\n    });\n    const traverseTime = window.performance.now() - startTime;\n    $cdfe6782841c53e7$var$outputContainer.innerText = `${traverseTime.toFixed(3)}ms`;\n    const indexAttr = $cdfe6782841c53e7$var$mesh.geometry.index;\n    const newIndexAttr = $cdfe6782841c53e7$var$highlightMesh.geometry.index;\n    if (indices.length && $cdfe6782841c53e7$var$params.selectModel) {\n        // if we found indices and we want to select the whole model\n        for(let i = 0, l = indexAttr.count; i < l; i++){\n            const i2 = indexAttr.getX(i);\n            newIndexAttr.setX(i, i2);\n        }\n        $cdfe6782841c53e7$var$highlightMesh.geometry.drawRange.count = Infinity;\n        newIndexAttr.needsUpdate = true;\n    } else {\n        // update the highlight mesh\n        for(let i = 0, l = indices.length; i < l; i++){\n            const i2 = indexAttr.getX(indices[i]);\n            newIndexAttr.setX(i, i2);\n        }\n        $cdfe6782841c53e7$var$highlightMesh.geometry.drawRange.count = indices.length;\n        newIndexAttr.needsUpdate = true;\n    }\n}\n// Math Functions\n// https://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/\nfunction $cdfe6782841c53e7$var$getConvexHull(points) {\n    function orientation(p, q, r) {\n        const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        if (val == 0) return 0; // colinear\n        // clockwise or counterclockwise\n        return val > 0 ? 1 : 2;\n    }\n    function distSq(p1, p2) {\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n    }\n    function compare(p1, p2) {\n        // Find orientation\n        const o = orientation(p0, p1, p2);\n        if (o == 0) return distSq(p0, p2) >= distSq(p0, p1) ? -1 : 1;\n        return o == 2 ? -1 : 1;\n    }\n    // find the lowest point in 2d\n    let lowestY = Infinity;\n    let lowestIndex = -1;\n    for(let i = 0, l = points.length; i < l; i++){\n        const p = points[i];\n        if (p.y < lowestY) {\n            lowestIndex = i;\n            lowestY = p.y;\n        }\n    }\n    // sort the points\n    const p0 = points[lowestIndex];\n    points[lowestIndex] = points[0];\n    points[0] = p0;\n    points = points.sort(compare);\n    // filter the points\n    let m = 1;\n    const n = points.length;\n    for(let i = 1; i < n; i++){\n        while(i < n - 1 && orientation(p0, points[i], points[i + 1]) == 0)i++;\n        points[m] = points[i];\n        m++;\n    }\n    // early out if we don't have enough points for a hull\n    if (m < 3) return null;\n    // generate the hull\n    const hull = [\n        points[0],\n        points[1],\n        points[2]\n    ];\n    for(let i = 3; i < m; i++){\n        while(orientation(hull[hull.length - 2], hull[hull.length - 1], points[i]) !== 2)hull.pop();\n        hull.push(points[i]);\n    }\n    return hull;\n}\nfunction $cdfe6782841c53e7$var$pointRayCrossesLine(point, line, prevDirection, thisDirection) {\n    const { start: start, end: end } = line;\n    const px = point.x;\n    const py = point.y;\n    const sy = start.y;\n    const ey = end.y;\n    if (sy === ey) return false;\n    if (py > sy && py > ey) return false; // above\n    if (py < sy && py < ey) return false; // below\n    const sx = start.x;\n    const ex = end.x;\n    if (px > sx && px > ex) return false; // right\n    if (px < sx && px < ex) {\n        if (py === sy && prevDirection !== thisDirection) return false;\n        return true;\n    }\n    // check the side\n    const dx = ex - sx;\n    const dy = ey - sy;\n    const perpx = dy;\n    const perpy = -dx;\n    const pdx = px - sx;\n    const pdy = py - sy;\n    const dot = perpx * pdx + perpy * pdy;\n    if (Math.sign(dot) !== Math.sign(perpx)) return true;\n    return false;\n}\nfunction $cdfe6782841c53e7$var$pointRayCrossesSegments(point, segments) {\n    let crossings = 0;\n    const firstSeg = segments[segments.length - 1];\n    let prevDirection = firstSeg.start.y > firstSeg.end.y;\n    for(let s = 0, l = segments.length; s < l; s++){\n        const line = segments[s];\n        const thisDirection = line.start.y > line.end.y;\n        if ($cdfe6782841c53e7$var$pointRayCrossesLine(point, line, prevDirection, thisDirection)) crossings++;\n        prevDirection = thisDirection;\n    }\n    return crossings;\n}\n// https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\nfunction $cdfe6782841c53e7$var$lineCrossesLine(l1, l2) {\n    function ccw(A, B, C) {\n        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);\n    }\n    const A = l1.start;\n    const B = l1.end;\n    const C = l2.start;\n    const D = l2.end;\n    return ccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D);\n}\n\n\n//# sourceMappingURL=selection.2c682e6d.js.map\n","// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.bvh || this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n","import * as THREE from 'three';\nimport Stats from 'stats.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport {\n\tMeshBVHHelper,\n\tMeshBVH,\n\tCONTAINED,\n\tINTERSECTED,\n\tNOT_INTERSECTED,\n} from '..';\n\nconst params = {\n\n\ttoolMode: 'lasso',\n\tselectionMode: 'intersection',\n\tliveUpdate: false,\n\tselectModel: false,\n\twireframe: false,\n\tuseBoundsTree: true,\n\n\tdisplayHelper: false,\n\thelperDepth: 10,\n\trotate: true,\n\n};\n\nlet renderer, camera, scene, gui, stats, controls, selectionShape, mesh, helper;\nlet highlightMesh, highlightWireframeMesh, outputContainer, group;\nconst selectionPoints = [];\nlet dragging = false;\nlet selectionShapeNeedsUpdate = false;\nlet selectionNeedsUpdate = false;\n\ninit();\nrender();\n\nfunction init() {\n\n\toutputContainer = document.getElementById( 'output' );\n\n\tconst bgColor = new THREE.Color( 0x263238 );\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.shadowMap.enabled = true;\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.castShadow = true;\n\tlight.shadow.mapSize.set( 2048, 2048 );\n\tlight.position.set( 10, 10, 10 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xb0bec5, 0.8 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 2, 4, 6 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\tscene.add( camera );\n\n\t// selection shape\n\tselectionShape = new THREE.Line();\n\tselectionShape.material.color.set( 0xff9800 ).convertSRGBToLinear();\n\tselectionShape.renderOrder = 1;\n\tselectionShape.position.z = - .2;\n\tselectionShape.depthTest = false;\n\tselectionShape.scale.setScalar( 1 );\n\tcamera.add( selectionShape );\n\n\t// group for rotation\n\tgroup = new THREE.Group();\n\tscene.add( group );\n\n\t// base mesh\n\tmesh = new THREE.Mesh(\n\t\tnew THREE.TorusKnotGeometry( 1.5, 0.5, 500, 60 ).toNonIndexed(),\n\t\tnew THREE.MeshStandardMaterial( {\n\t\t\tpolygonOffset: true,\n\t\t\tpolygonOffsetFactor: 1,\n\t\t} )\n\t);\n\tmesh.geometry.boundsTree = new MeshBVH( mesh.geometry );\n\tmesh.geometry.setAttribute( 'color', new THREE.Uint8BufferAttribute(\n\t\tnew Array( mesh.geometry.index.count * 3 ).fill( 255 ), 3, true\n\t) );\n\tmesh.castShadow = true;\n\tmesh.receiveShadow = true;\n\tgroup.add( mesh );\n\n\thelper = new MeshBVHHelper( mesh, 10 );\n\tgroup.add( helper );\n\n\t// meshes for selection highlights\n\thighlightMesh = new THREE.Mesh();\n\thighlightMesh.geometry = mesh.geometry.clone();\n\thighlightMesh.geometry.drawRange.count = 0;\n\thighlightMesh.material = new THREE.MeshBasicMaterial( {\n\t\topacity: 0.05,\n\t\ttransparent: true,\n\t\tdepthWrite: false,\n\t} );\n\thighlightMesh.material.color.set( 0xff9800 ).convertSRGBToLinear();\n\thighlightMesh.renderOrder = 1;\n\tgroup.add( highlightMesh );\n\n\thighlightWireframeMesh = new THREE.Mesh();\n\thighlightWireframeMesh.geometry = highlightMesh.geometry;\n\thighlightWireframeMesh.material = new THREE.MeshBasicMaterial( {\n\t\topacity: 0.25,\n\t\ttransparent: true,\n\t\twireframe: true,\n\t\tdepthWrite: false,\n\t} );\n\thighlightWireframeMesh.material.color.copy( highlightMesh.material.color );\n\thighlightWireframeMesh.renderOrder = 2;\n\tgroup.add( highlightWireframeMesh );\n\n\t// add floor\n\tconst gridHelper = new THREE.GridHelper( 10, 10, 0xffffff, 0xffffff );\n\tgridHelper.material.opacity = 0.2;\n\tgridHelper.material.transparent = true;\n\tgridHelper.position.y = - 2.75;\n\tscene.add( gridHelper );\n\n\tconst shadowPlane = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry(),\n\t\tnew THREE.ShadowMaterial( { color: 0, opacity: 0.2, depthWrite: false } )\n\t);\n\tshadowPlane.position.y = - 2.74;\n\tshadowPlane.rotation.x = - Math.PI / 2;\n\tshadowPlane.scale.setScalar( 20 );\n\tshadowPlane.renderOrder = 2;\n\tshadowPlane.receiveShadow = true;\n\tscene.add( shadowPlane );\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// controls\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.minDistance = 3;\n\tcontrols.touches.ONE = THREE.TOUCH.PAN;\n\tcontrols.mouseButtons.LEFT = THREE.MOUSE.PAN;\n\tcontrols.touches.TWO = THREE.TOUCH.ROTATE;\n\tcontrols.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;\n\tcontrols.enablePan = false;\n\n\t// gui\n\tgui = new GUI();\n\tconst selectionFolder = gui.addFolder( 'selection' );\n\tselectionFolder.add( params, 'toolMode', [ 'lasso', 'box' ] );\n\tselectionFolder.add( params, 'selectionMode', [ 'centroid', 'centroid-visible', 'intersection' ] );\n\tselectionFolder.add( params, 'selectModel' );\n\tselectionFolder.add( params, 'liveUpdate' );\n\tselectionFolder.add( params, 'useBoundsTree' );\n\tselectionFolder.open();\n\n\tconst displayFolder = gui.addFolder( 'display' );\n\tdisplayFolder.add( params, 'wireframe' );\n\tdisplayFolder.add( params, 'rotate' );\n\tdisplayFolder.add( params, 'displayHelper' );\n\tdisplayFolder.add( params, 'helperDepth', 1, 30, 1 ).onChange( v => {\n\n\t\thelper.depth = v;\n\t\thelper.update();\n\n\t} );\n\tdisplayFolder.open();\n\tgui.open();\n\n\t// handle building lasso shape\n\tlet startX = - Infinity;\n\tlet startY = - Infinity;\n\n\tlet prevX = - Infinity;\n\tlet prevY = - Infinity;\n\n\tconst tempVec0 = new THREE.Vector2();\n\tconst tempVec1 = new THREE.Vector2();\n\tconst tempVec2 = new THREE.Vector2();\n\trenderer.domElement.addEventListener( 'pointerdown', e => {\n\n\t\tprevX = e.clientX;\n\t\tprevY = e.clientY;\n\t\tstartX = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tstartY = - ( ( e.clientY / window.innerHeight ) * 2 - 1 );\n\t\tselectionPoints.length = 0;\n\t\tdragging = true;\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointerup', () => {\n\n\t\tselectionShape.visible = false;\n\t\tdragging = false;\n\t\tif ( selectionPoints.length ) {\n\n\t\t\tselectionNeedsUpdate = true;\n\n\t\t}\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointermove', e => {\n\n\t\t// If the left mouse button is not pressed\n\t\tif ( ( 1 & e.buttons ) === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst ex = e.clientX;\n\t\tconst ey = e.clientY;\n\n\t\tconst nx = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tconst ny = - ( ( e.clientY / window.innerHeight ) * 2 - 1 );\n\n\t\tif ( params.toolMode === 'box' ) {\n\n\t\t\t// set points for the corner of the box\n\t\t\tselectionPoints.length = 3 * 5;\n\n\t\t\tselectionPoints[ 0 ] = startX;\n\t\t\tselectionPoints[ 1 ] = startY;\n\t\t\tselectionPoints[ 2 ] = 0;\n\n\t\t\tselectionPoints[ 3 ] = nx;\n\t\t\tselectionPoints[ 4 ] = startY;\n\t\t\tselectionPoints[ 5 ] = 0;\n\n\t\t\tselectionPoints[ 6 ] = nx;\n\t\t\tselectionPoints[ 7 ] = ny;\n\t\t\tselectionPoints[ 8 ] = 0;\n\n\t\t\tselectionPoints[ 9 ] = startX;\n\t\t\tselectionPoints[ 10 ] = ny;\n\t\t\tselectionPoints[ 11 ] = 0;\n\n\t\t\tselectionPoints[ 12 ] = startX;\n\t\t\tselectionPoints[ 13 ] = startY;\n\t\t\tselectionPoints[ 14 ] = 0;\n\n\t\t\tif ( ex !== prevX || ey !== prevY ) {\n\n\t\t\t\tselectionShapeNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t\tprevX = ex;\n\t\t\tprevY = ey;\n\t\t\tselectionShape.visible = true;\n\t\t\tif ( params.liveUpdate ) {\n\n\t\t\t\tselectionNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If the mouse hasn't moved a lot since the last point\n\t\t\tif (\n\t\t\t\tMath.abs( ex - prevX ) >= 3 ||\n\t\t\t\tMath.abs( ey - prevY ) >= 3\n\t\t\t) {\n\n\t\t\t\t// Check if the mouse moved in roughly the same direction as the previous point\n\t\t\t\t// and replace it if so.\n\t\t\t\tconst i = ( selectionPoints.length / 3 ) - 1;\n\t\t\t\tconst i3 = i * 3;\n\t\t\t\tlet doReplace = false;\n\t\t\t\tif ( selectionPoints.length > 3 ) {\n\n\t\t\t\t\t// prev segment direction\n\t\t\t\t\ttempVec0.set( selectionPoints[ i3 - 3 ], selectionPoints[ i3 - 3 + 1 ] );\n\t\t\t\t\ttempVec1.set( selectionPoints[ i3 ], selectionPoints[ i3 + 1 ] );\n\t\t\t\t\ttempVec1.sub( tempVec0 ).normalize();\n\n\t\t\t\t\t// this segment direction\n\t\t\t\t\ttempVec0.set( selectionPoints[ i3 ], selectionPoints[ i3 + 1 ] );\n\t\t\t\t\ttempVec2.set( nx, ny );\n\t\t\t\t\ttempVec2.sub( tempVec0 ).normalize();\n\n\t\t\t\t\tconst dot = tempVec1.dot( tempVec2 );\n\t\t\t\t\tdoReplace = dot > 0.99;\n\n\t\t\t\t}\n\n\t\t\t\tif ( doReplace ) {\n\n\t\t\t\t\tselectionPoints[ i3 ] = nx;\n\t\t\t\t\tselectionPoints[ i3 + 1 ] = ny;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tselectionPoints.push( nx, ny, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tselectionShapeNeedsUpdate = true;\n\t\t\t\tselectionShape.visible = true;\n\n\t\t\t\tprevX = ex;\n\t\t\t\tprevY = ey;\n\n\t\t\t\tif ( params.liveUpdate ) {\n\n\t\t\t\t\tselectionNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tmesh.material.wireframe = params.wireframe;\n\thelper.visible = params.displayHelper;\n\n\t// Update the selection lasso lines\n\tif ( selectionShapeNeedsUpdate ) {\n\n\t\tif ( params.toolMode === 'lasso' ) {\n\n\t\t\tconst ogLength = selectionPoints.length;\n\t\t\tselectionPoints.push(\n\t\t\t\tselectionPoints[ 0 ],\n\t\t\t\tselectionPoints[ 1 ],\n\t\t\t\tselectionPoints[ 2 ]\n\t\t\t);\n\n\t\t\tselectionShape.geometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew THREE.Float32BufferAttribute( selectionPoints, 3, false )\n\t\t\t);\n\n\t\t\tselectionPoints.length = ogLength;\n\n\t\t} else {\n\n\t\t\tselectionShape.geometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew THREE.Float32BufferAttribute( selectionPoints, 3, false )\n\t\t\t);\n\n\t\t}\n\n\t\tselectionShape.frustumCulled = false;\n\t\tselectionShapeNeedsUpdate = false;\n\n\t}\n\n\tif ( selectionNeedsUpdate ) {\n\n\t\tselectionNeedsUpdate = false;\n\n\t\tif ( selectionPoints.length > 0 ) {\n\n\t\t\tupdateSelection();\n\n\t\t}\n\n\t}\n\n\tconst yScale = Math.tan( THREE.MathUtils.DEG2RAD * camera.fov / 2 ) * selectionShape.position.z;\n\tselectionShape.scale.set( - yScale * camera.aspect, - yScale, 1 );\n\n\trenderer.render( scene, camera );\n\n\tif ( params.rotate ) {\n\n\t\tgroup.rotation.y += 0.01;\n\t\tif ( params.liveUpdate && dragging ) {\n\n\t\t\tselectionNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst invWorldMatrix = new THREE.Matrix4();\nconst camLocalPosition = new THREE.Vector3();\nconst tempRay = new THREE.Ray();\nconst centroid = new THREE.Vector3();\nconst screenCentroid = new THREE.Vector3();\nconst faceNormal = new THREE.Vector3();\nconst toScreenSpaceMatrix = new THREE.Matrix4();\nconst boxPoints = new Array( 8 ).fill().map( () => new THREE.Vector3() );\nconst boxLines = new Array( 12 ).fill().map( () => new THREE.Line3() );\nconst lassoSegments = [];\nconst perBoundsSegments = [];\nfunction updateSelection() {\n\n\t// TODO: Possible improvements\n\t// - Correctly handle the camera near clip\n\t// - Improve line line intersect performance?\n\n\ttoScreenSpaceMatrix\n\t\t.copy( mesh.matrixWorld )\n\t\t.premultiply( camera.matrixWorldInverse )\n\t\t.premultiply( camera.projectionMatrix );\n\n\t// create scratch points and lines to use for selection\n\twhile ( lassoSegments.length < selectionPoints.length ) {\n\n\t\tlassoSegments.push( new THREE.Line3() );\n\n\t}\n\n\tlassoSegments.length = selectionPoints.length;\n\n\tfor ( let s = 0, l = selectionPoints.length; s < l; s += 3 ) {\n\n\t\tconst line = lassoSegments[ s ];\n\t\tconst sNext = ( s + 3 ) % l;\n\t\tline.start.x = selectionPoints[ s ];\n\t\tline.start.y = selectionPoints[ s + 1 ];\n\n\t\tline.end.x = selectionPoints[ sNext ];\n\t\tline.end.y = selectionPoints[ sNext + 1 ];\n\n\t}\n\n\tinvWorldMatrix.copy( mesh.matrixWorld ).invert();\n\tcamLocalPosition.set( 0, 0, 0 ).applyMatrix4( camera.matrixWorld ).applyMatrix4( invWorldMatrix );\n\n\tconst startTime = window.performance.now();\n\tconst indices = [];\n\tmesh.geometry.boundsTree.shapecast( {\n\t\tintersectsBounds: ( box, isLeaf, score, depth ) => {\n\n\t\t\t// check if bounds intersect or contain the lasso region\n\t\t\tif ( ! params.useBoundsTree ) {\n\n\t\t\t\treturn INTERSECTED;\n\n\t\t\t}\n\n\t\t\t// Get the bounding box points\n\t\t\tconst { min, max } = box;\n\t\t\tlet index = 0;\n\n\t\t\tlet minY = Infinity;\n\t\t\tlet maxY = - Infinity;\n\t\t\tlet minX = Infinity;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tconst v = boxPoints[ index ];\n\t\t\t\t\t\tv.x = x === 0 ? min.x : max.x;\n\t\t\t\t\t\tv.y = y === 0 ? min.y : max.y;\n\t\t\t\t\t\tv.z = z === 0 ? min.z : max.z;\n\t\t\t\t\t\tv.w = 1;\n\t\t\t\t\t\tv.applyMatrix4( toScreenSpaceMatrix );\n\t\t\t\t\t\tindex ++;\n\n\t\t\t\t\t\tif ( v.y < minY ) minY = v.y;\n\t\t\t\t\t\tif ( v.y > maxY ) maxY = v.y;\n\t\t\t\t\t\tif ( v.x < minX ) minX = v.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Find all the relevant segments here and cache them in the above array for\n\t\t\t// subsequent child checks to use.\n\t\t\tconst parentSegments = perBoundsSegments[ depth - 1 ] || lassoSegments;\n\t\t\tconst segmentsToCheck = perBoundsSegments[ depth ] || [];\n\t\t\tsegmentsToCheck.length = 0;\n\t\t\tperBoundsSegments[ depth ] = segmentsToCheck;\n\t\t\tfor ( let i = 0, l = parentSegments.length; i < l; i ++ ) {\n\n\t\t\t\tconst line = parentSegments[ i ];\n\t\t\t\tconst sx = line.start.x;\n\t\t\t\tconst sy = line.start.y;\n\t\t\t\tconst ex = line.end.x;\n\t\t\t\tconst ey = line.end.y;\n\t\t\t\tif ( sx < minX && ex < minX ) continue;\n\n\t\t\t\tconst startAbove = sy > maxY;\n\t\t\t\tconst endAbove = ey > maxY;\n\t\t\t\tif ( startAbove && endAbove ) continue;\n\n\t\t\t\tconst startBelow = sy < minY;\n\t\t\t\tconst endBelow = ey < minY;\n\t\t\t\tif ( startBelow && endBelow ) continue;\n\n\t\t\t\tsegmentsToCheck.push( line );\n\n\t\t\t}\n\n\t\t\tif ( segmentsToCheck.length === 0 ) {\n\n\t\t\t\treturn NOT_INTERSECTED;\n\n\t\t\t}\n\n\t\t\t// Get the screen space hull lines\n\t\t\tconst hull = getConvexHull( boxPoints );\n\t\t\tconst lines = hull.map( ( p, i ) => {\n\n\t\t\t\tconst nextP = hull[ ( i + 1 ) % hull.length ];\n\t\t\t\tconst line = boxLines[ i ];\n\t\t\t\tline.start.copy( p );\n\t\t\t\tline.end.copy( nextP );\n\t\t\t\treturn line;\n\n\t\t\t} );\n\n\t\t\t// If a lasso point is inside the hull then it's intersected and cannot be contained\n\t\t\tif ( pointRayCrossesSegments( segmentsToCheck[ 0 ].start, lines ) % 2 === 1 ) {\n\n\t\t\t\treturn INTERSECTED;\n\n\t\t\t}\n\n\t\t\t// check if the screen space hull is in the lasso\n\t\t\tlet crossings = 0;\n\t\t\tfor ( let i = 0, l = hull.length; i < l; i ++ ) {\n\n\t\t\t\tconst v = hull[ i ];\n\t\t\t\tconst pCrossings = pointRayCrossesSegments( v, segmentsToCheck );\n\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tcrossings = pCrossings;\n\n\t\t\t\t}\n\n\t\t\t\t// if two points on the hull have different amounts of crossings then\n\t\t\t\t// it can only be intersected\n\t\t\t\tif ( crossings !== pCrossings ) {\n\n\t\t\t\t\treturn INTERSECTED;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check if there are any intersections\n\t\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tconst boxLine = lines[ i ];\n\t\t\t\tfor ( let s = 0, ls = segmentsToCheck.length; s < ls; s ++ ) {\n\n\t\t\t\t\tif ( lineCrossesLine( boxLine, segmentsToCheck[ s ] ) ) {\n\n\t\t\t\t\t\treturn INTERSECTED;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn crossings % 2 === 0 ? NOT_INTERSECTED : CONTAINED;\n\n\t\t},\n\n\t\tintersectsTriangle: ( tri, index, contained, depth ) => {\n\n\t\t\tconst i3 = index * 3;\n\t\t\tconst a = i3 + 0;\n\t\t\tconst b = i3 + 1;\n\t\t\tconst c = i3 + 2;\n\n\t\t\t// check all the segments if using no bounds tree\n\t\t\tconst segmentsToCheck = params.useBoundsTree ? perBoundsSegments[ depth ] : lassoSegments;\n\t\t\tif ( params.selectionMode === 'centroid' || params.selectionMode === 'centroid-visible' ) {\n\n\t\t\t\t// get the center of the triangle\n\t\t\t\tcentroid.copy( tri.a ).add( tri.b ).add( tri.c ).multiplyScalar( 1 / 3 );\n\t\t\t\tscreenCentroid.copy( centroid ).applyMatrix4( toScreenSpaceMatrix );\n\n\t\t\t\t// counting the crossings\n\t\t\t\tif (\n\t\t\t\t\tcontained ||\n\t\t\t\t\tpointRayCrossesSegments( screenCentroid, segmentsToCheck ) % 2 === 1\n\t\t\t\t) {\n\n\t\t\t\t\t// if we're only selecting visible faces then perform a ray check to ensure the centroid\n\t\t\t\t\t// is visible.\n\t\t\t\t\tif ( params.selectionMode === 'centroid-visible' ) {\n\n\t\t\t\t\t\ttri.getNormal( faceNormal );\n\t\t\t\t\t\ttempRay.origin.copy( centroid ).addScaledVector( faceNormal, 1e-6 );\n\t\t\t\t\t\ttempRay.direction.subVectors( camLocalPosition, centroid );\n\n\t\t\t\t\t\tconst res = mesh.geometry.boundsTree.raycastFirst( tempRay, THREE.DoubleSide );\n\t\t\t\t\t\tif ( res ) {\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\treturn params.selectModel;\n\n\t\t\t\t}\n\n\t\t\t} else if ( params.selectionMode === 'intersection' ) {\n\n\t\t\t\t// if the parent bounds were marked as contained then we contain all the triangles within\n\t\t\t\tif ( contained ) {\n\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\treturn params.selectModel;\n\n\t\t\t\t}\n\n\t\t\t\t// get the projected vertices\n\t\t\t\tconst vertices = [\n\t\t\t\t\ttri.a,\n\t\t\t\t\ttri.b,\n\t\t\t\t\ttri.c,\n\t\t\t\t];\n\n\t\t\t\t// check if any of the vertices are inside the selection and if so then the triangle is selected\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tconst v = vertices[ j ];\n\t\t\t\t\tv.applyMatrix4( toScreenSpaceMatrix );\n\n\t\t\t\t\tconst crossings = pointRayCrossesSegments( v, segmentsToCheck );\n\t\t\t\t\tif ( crossings % 2 === 1 ) {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\treturn params.selectModel;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// get the lines for the triangle\n\t\t\t\tconst lines = [\n\t\t\t\t\tboxLines[ 0 ],\n\t\t\t\t\tboxLines[ 1 ],\n\t\t\t\t\tboxLines[ 2 ],\n\t\t\t\t];\n\n\t\t\t\tlines[ 0 ].start.copy( tri.a );\n\t\t\t\tlines[ 0 ].end.copy( tri.b );\n\n\t\t\t\tlines[ 1 ].start.copy( tri.b );\n\t\t\t\tlines[ 1 ].end.copy( tri.c );\n\n\t\t\t\tlines[ 2 ].start.copy( tri.c );\n\t\t\t\tlines[ 2 ].end.copy( tri.a );\n\n\t\t\t\t// check for the case where a selection intersects a triangle but does not contain any\n\t\t\t\t// of the vertices\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst l = lines[ i ];\n\t\t\t\t\tfor ( let s = 0, sl = segmentsToCheck.length; s < sl; s ++ ) {\n\n\t\t\t\t\t\tif ( lineCrossesLine( l, segmentsToCheck[ s ] ) ) {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\treturn params.selectModel;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\tconst traverseTime = window.performance.now() - startTime;\n\toutputContainer.innerText = `${ traverseTime.toFixed( 3 ) }ms`;\n\n\tconst indexAttr = mesh.geometry.index;\n\tconst newIndexAttr = highlightMesh.geometry.index;\n\tif ( indices.length && params.selectModel ) {\n\n\t\t// if we found indices and we want to select the whole model\n\t\tfor ( let i = 0, l = indexAttr.count; i < l; i ++ ) {\n\n\t\t\tconst i2 = indexAttr.getX( i );\n\t\t\tnewIndexAttr.setX( i, i2 );\n\n\t\t}\n\n\t\thighlightMesh.geometry.drawRange.count = Infinity;\n\t\tnewIndexAttr.needsUpdate = true;\n\n\t} else {\n\n\t\t// update the highlight mesh\n\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tconst i2 = indexAttr.getX( indices[ i ] );\n\t\t\tnewIndexAttr.setX( i, i2 );\n\n\t\t}\n\n\t\thighlightMesh.geometry.drawRange.count = indices.length;\n\t\tnewIndexAttr.needsUpdate = true;\n\n\t}\n\n}\n\n// Math Functions\n// https://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/\nfunction getConvexHull( points ) {\n\n\tfunction orientation( p, q, r ) {\n\n\t\tconst val =\n\t\t\t( q.y - p.y ) * ( r.x - q.x ) -\n\t\t\t( q.x - p.x ) * ( r.y - q.y );\n\n\t\tif ( val == 0 ) {\n\n\t\t\treturn 0; // colinear\n\n\t\t}\n\n\t\t// clockwise or counterclockwise\n\t\treturn ( val > 0 ) ? 1 : 2;\n\n\t}\n\n\tfunction distSq( p1, p2 ) {\n\n\t\treturn ( p1.x - p2.x ) * ( p1.x - p2.x ) +\n\t\t\t( p1.y - p2.y ) * ( p1.y - p2.y );\n\n\t}\n\n\tfunction compare( p1, p2 ) {\n\n\t   // Find orientation\n\t   const o = orientation( p0, p1, p2 );\n\t   if ( o == 0 )\n\t\t return ( distSq( p0, p2 ) >= distSq( p0, p1 ) ) ? - 1 : 1;\n\n\t   return ( o == 2 ) ? - 1 : 1;\n\n\t}\n\n\t// find the lowest point in 2d\n\tlet lowestY = Infinity;\n\tlet lowestIndex = - 1;\n\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\tconst p = points[ i ];\n\t\tif ( p.y < lowestY ) {\n\n\t\t\tlowestIndex = i;\n\t\t\tlowestY = p.y;\n\n\t\t}\n\n\t}\n\n\t// sort the points\n\tconst p0 = points[ lowestIndex ];\n\tpoints[ lowestIndex ] = points[ 0 ];\n\tpoints[ 0 ] = p0;\n\n\tpoints = points.sort( compare );\n\n\t// filter the points\n\tlet m = 1;\n\tconst n = points.length;\n\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\twhile ( i < n - 1 && orientation( p0, points[ i ], points[ i + 1 ] ) == 0 ) {\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\tpoints[ m ] = points[ i ];\n\t\tm ++;\n\n\t}\n\n\t// early out if we don't have enough points for a hull\n\tif ( m < 3 ) return null;\n\n\t// generate the hull\n\tconst hull = [ points[ 0 ], points[ 1 ], points[ 2 ] ];\n\tfor ( let i = 3; i < m; i ++ ) {\n\n\t\twhile ( orientation( hull[ hull.length - 2 ], hull[ hull.length - 1 ], points[ i ] ) !== 2 ) {\n\n\t\t\thull.pop();\n\n\t\t}\n\n\t\thull.push( points[ i ] );\n\n\t}\n\n\treturn hull;\n\n}\n\nfunction pointRayCrossesLine( point, line, prevDirection, thisDirection ) {\n\n\tconst { start, end } = line;\n\tconst px = point.x;\n\tconst py = point.y;\n\n\tconst sy = start.y;\n\tconst ey = end.y;\n\n\tif ( sy === ey ) return false;\n\n\tif ( py > sy && py > ey ) return false; // above\n\tif ( py < sy && py < ey ) return false; // below\n\n\tconst sx = start.x;\n\tconst ex = end.x;\n\tif ( px > sx && px > ex ) return false; // right\n\tif ( px < sx && px < ex ) { // left\n\n\t\tif ( py === sy && prevDirection !== thisDirection ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t// check the side\n\tconst dx = ex - sx;\n\tconst dy = ey - sy;\n\tconst perpx = dy;\n\tconst perpy = - dx;\n\n\tconst pdx = px - sx;\n\tconst pdy = py - sy;\n\n\tconst dot = perpx * pdx + perpy * pdy;\n\n\tif ( Math.sign( dot ) !== Math.sign( perpx ) ) {\n\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n}\n\nfunction pointRayCrossesSegments( point, segments ) {\n\n\tlet crossings = 0;\n\tconst firstSeg = segments[ segments.length - 1 ];\n\tlet prevDirection = firstSeg.start.y > firstSeg.end.y;\n\tfor ( let s = 0, l = segments.length; s < l; s ++ ) {\n\n\t\tconst line = segments[ s ];\n\t\tconst thisDirection = line.start.y > line.end.y;\n\t\tif ( pointRayCrossesLine( point, line, prevDirection, thisDirection ) ) {\n\n\t\t\tcrossings ++;\n\n\t\t}\n\n\t\tprevDirection = thisDirection;\n\n\t}\n\n\treturn crossings;\n\n}\n\n// https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\nfunction lineCrossesLine( l1, l2 ) {\n\n\tfunction ccw( A, B, C ) {\n\n\t\treturn ( C.y - A.y ) * ( B.x - A.x ) > ( B.y - A.y ) * ( C.x - A.x );\n\n\t}\n\n\tconst A = l1.start;\n\tconst B = l1.end;\n\n\tconst C = l2.start;\n\tconst D = l2.end;\n\n\treturn ccw( A, C, D ) !== ccw( B, C, D ) && ccw( A, B, C ) !== ccw( A, B, D );\n\n}\n"],"names":["$cdfe6782841c53e7$var$renderer","$cdfe6782841c53e7$var$camera","$cdfe6782841c53e7$var$scene","$cdfe6782841c53e7$var$gui","$cdfe6782841c53e7$var$stats","$cdfe6782841c53e7$var$controls","$cdfe6782841c53e7$var$selectionShape","$cdfe6782841c53e7$var$mesh","$cdfe6782841c53e7$var$helper","$cdfe6782841c53e7$var$highlightMesh","$cdfe6782841c53e7$var$highlightWireframeMesh","$cdfe6782841c53e7$var$outputContainer","$cdfe6782841c53e7$var$group","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","f","e","a","c","appendChild","dom","u","d","children","length","style","display","l","document","createElement","cssText","addEventListener","preventDefault","k","performance","Date","now","g","r","Panel","h","self","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","Infinity","Math","round","window","devicePixelRatio","v","m","n","p","q","width","height","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","w","min","max","drawImage","Object","defineProperty","get","$3c85f35a8c29fa9b$export$e57d74bcb7e3bec5","set","s","enumerable","configurable","$ilwiq","$aw71y","$ff8ed","$3c85f35a8c29fa9b$var$boundingBox","Box3","$3c85f35a8c29fa9b$var$MeshBVHRootHelper","Object3D","isMesh","displayEdges","isLineSegments","isLine","constructor","bvh","material","depth","group","geometry","BufferGeometry","name","displayParents","_group","raycast","boundsTree","dispose","visible","indexArray","indices","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","arrayToBox","x","xVal","y","yVal","z","zVal","Uint8Array","Uint32Array","Uint16Array","indexLength","i","posOffset","indexOffset","j","setIndex","BufferAttribute","setAttribute","Group","color","edgeMaterial","opacity","meshMaterial","mesh","MeshBVH","_roots","LineBasicMaterial","transparent","depthWrite","MeshBasicMaterial","totalRoots","root","pop","remove","add","push","updateMatrixWorld","args","parent","updateWorldMatrix","matrix","copy","matrixWorld","invert","multiply","decompose","position","quaternion","scale","source","clone","$c8CJQ","$jiuw3","$5Rd1x","$Mleu6","$5ca9G","$cdfe6782841c53e7$var$params","toolMode","selectionMode","liveUpdate","selectModel","wireframe","useBoundsTree","displayHelper","helperDepth","rotate","$cdfe6782841c53e7$var$selectionPoints","$cdfe6782841c53e7$var$dragging","$cdfe6782841c53e7$var$selectionShapeNeedsUpdate","$cdfe6782841c53e7$var$selectionNeedsUpdate","$cdfe6782841c53e7$var$init","getElementById","bgColor","Color","WebGLRenderer","antialias","setPixelRatio","setSize","innerWidth","innerHeight","setClearColor","shadowMap","enabled","outputEncoding","sRGBEncoding","body","Scene","light","DirectionalLight","castShadow","shadow","mapSize","AmbientLight","PerspectiveCamera","far","updateProjectionMatrix","Line","convertSRGBToLinear","renderOrder","depthTest","setScalar","Mesh","TorusKnotGeometry","toNonIndexed","MeshStandardMaterial","polygonOffset","polygonOffsetFactor","Uint8BufferAttribute","Array","index","count","fill","receiveShadow","MeshBVHHelper","drawRange","gridHelper","GridHelper","shadowPlane","PlaneBufferGeometry","ShadowMaterial","rotation","PI","__esModule","default","OrbitControls","minDistance","touches","ONE","TOUCH","PAN","mouseButtons","LEFT","MOUSE","TWO","ROTATE","RIGHT","enablePan","selectionFolder","GUI","addFolder","open","displayFolder","onChange","startX","startY","prevX","prevY","tempVec0","Vector2","tempVec1","tempVec2","clientX","clientY","buttons","ex","ey","nx","ny","abs","i3","doReplace","sub","normalize","dot","aspect","$cdfe6782841c53e7$var$render","requestAnimationFrame","ogLength","Float32BufferAttribute","frustumCulled","$cdfe6782841c53e7$var$updateSelection","$cdfe6782841c53e7$var$toScreenSpaceMatrix","premultiply","matrixWorldInverse","projectionMatrix","$cdfe6782841c53e7$var$lassoSegments","Line3","line","sNext","start","$cdfe6782841c53e7$var$invWorldMatrix","$cdfe6782841c53e7$var$camLocalPosition","applyMatrix4","startTime","shapecast","intersectsBounds","box","score","INTERSECTED","minY","maxY","minX","$cdfe6782841c53e7$var$boxPoints","parentSegments","$cdfe6782841c53e7$var$perBoundsSegments","segmentsToCheck","sx","sy","startAbove","endAbove","startBelow","endBelow","NOT_INTERSECTED","hull","$cdfe6782841c53e7$var$getConvexHull","points","orientation","val","distSq","p1","p2","lowestY","lowestIndex","p0","sort","o","lines","map","nextP","$cdfe6782841c53e7$var$boxLines","$cdfe6782841c53e7$var$pointRayCrossesSegments","crossings","pCrossings","boxLine","ls","$cdfe6782841c53e7$var$lineCrossesLine","CONTAINED","intersectsTriangle","tri","contained","$cdfe6782841c53e7$var$centroid","multiplyScalar","$cdfe6782841c53e7$var$screenCentroid","getNormal","$cdfe6782841c53e7$var$faceNormal","$cdfe6782841c53e7$var$tempRay","origin","addScaledVector","direction","subVectors","raycastFirst","DoubleSide","vertices","sl","traverseTime","innerText","toFixed","indexAttr","newIndexAttr","i2","getX","setX","needsUpdate","yScale","tan","MathUtils","DEG2RAD","fov","render","Matrix4","Vector3","Ray","point","segments","firstSeg","prevDirection","thisDirection","$cdfe6782841c53e7$var$pointRayCrossesLine","px","py","perpx","sign","perpy","l1","l2","ccw","A","B","C","D"],"version":3,"file":"selection.2c682e6d.js.map"}